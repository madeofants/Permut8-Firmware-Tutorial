<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Permut8 Firmware Development Documentation</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --background-color: #f8f9fa;
            --text-color: #2c3e50;
            --code-background: #f4f4f4;
            --border-color: #e1e8ed;
            --success-color: #27ae60;
            --warning-color: #f39c12;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 300;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        /* Navigation */
        .nav {
            background: white;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-links a {
            color: var(--text-color);
            text-decoration: none;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .nav-links a:hover {
            background-color: var(--secondary-color);
            color: white;
        }

        /* Main Content */
        .main-content {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 2rem;
            padding: 2rem 0;
            min-height: calc(100vh - 200px);
        }

        /* Sidebar */
        .sidebar {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
            position: sticky;
            top: 100px;
        }

        .sidebar h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.1rem;
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 0.5rem;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar ul li {
            margin-bottom: 0.5rem;
        }

        .sidebar ul li a {
            color: var(--text-color);
            text-decoration: none;
            padding: 0.3rem 0;
            display: block;
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        .sidebar ul li a:hover {
            color: var(--secondary-color);
            padding-left: 0.5rem;
        }

        /* Content */
        .content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .section {
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border-color);
        }

        .section:last-child {
            border-bottom: none;
        }

        .section h2 {
            color: var(--primary-color);
            font-size: 2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--secondary-color);
        }

        .section h3 {
            color: var(--primary-color);
            font-size: 1.5rem;
            margin: 2rem 0 1rem 0;
        }

        .section h4 {
            color: var(--secondary-color);
            font-size: 1.2rem;
            margin: 1.5rem 0 0.5rem 0;
        }

        /* Code Blocks */
        .code-block {
            background: var(--code-background);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .inline-code {
            background: var(--code-background);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }

        /* Tables */
        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .table th,
        .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .table th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
        }

        .table tbody tr:hover {
            background-color: #f8f9fa;
        }

        /* Cards */
        .card {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .card-header {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        /* Alerts */
        .alert {
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
            border-left: 4px solid;
        }

        .alert-info {
            background-color: #e3f2fd;
            border-color: var(--secondary-color);
            color: #0277bd;
        }

        .alert-success {
            background-color: #e8f5e8;
            border-color: var(--success-color);
            color: #2e7d32;
        }

        .alert-warning {
            background-color: #fff8e1;
            border-color: var(--warning-color);
            color: #f57c00;
        }

        .alert-danger {
            background-color: #ffebee;
            border-color: var(--accent-color);
            color: #c62828;
        }

        /* Lists */
        .content ul,
        .content ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }

        .content li {
            margin-bottom: 0.5rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: static;
                margin-bottom: 2rem;
            }

            .nav-links {
                flex-direction: column;
                gap: 0.5rem;
            }

            .header h1 {
                font-size: 2rem;
            }
        }

        /* Print Styles */
        @media print {
            .nav, .sidebar {
                display: none;
            }

            .main-content {
                grid-template-columns: 1fr;
            }

            .content {
                box-shadow: none;
                padding: 0;
            }

            .section {
                page-break-inside: avoid;
            }
        }

        /* Search Box */
        .search-box {
            margin-bottom: 1rem;
        }

        .search-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-size: 0.9rem;
        }

        /* Back to Top */
        .back-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .back-to-top:hover {
            background: var(--primary-color);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <h1>Permut8 Firmware Development</h1>
            <p>Comprehensive Documentation for Audio DSP Programming</p>
        </div>
    </header>

    <nav class="nav">
        <div class="container nav-container">
            <div class="logo">
                <strong>Permut8 Docs</strong>
            </div>
            <ul class="nav-links">
                <li><a href="#quickstart">Quick Start</a></li>
                <li><a href="#language">Language</a></li>
                <li><a href="#cookbook">Cookbook</a></li>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#reference">Reference</a></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <div class="main-content">
            <aside class="sidebar">
                <div class="search-box">
                    <input type="text" class="search-input" placeholder="Search documentation..." id="searchInput">
                </div>
                
                <h3>Navigation</h3>
                <ul>
                    <li><a href="#quickstart">Quick Start Guide</a></li>
                    <li><a href="#language">Language Reference</a></li>
                    <li><a href="#fundamentals">Fundamentals</a></li>
                    <li><a href="#cookbook">Cookbook Recipes</a></li>
                    <li><a href="#architecture">Architecture</a></li>
                    <li><a href="#reference">API Reference</a></li>
                    <li><a href="#tutorials">Tutorials</a></li>
                    <li><a href="#glossary">Glossary</a></li>
                </ul>

                <h3>Getting Started</h3>
                <ul>
                    <li><a href="#audio-io">Audio I/O</a></li>
                    <li><a href="#first-sound">First Sound</a></li>
                    <li><a href="#basic-filter">Basic Filter</a></li>
                    <li><a href="#make-delay">Make a Delay</a></li>
                </ul>

                <h3>Advanced Topics</h3>
                <ul>
                    <li><a href="#mod-vs-full">Mod vs Full</a></li>
                    <li><a href="#memory-model">Memory Model</a></li>
                    <li><a href="#optimization">Optimization</a></li>
                    <li><a href="#assembly">Assembly</a></li>
                </ul>
            </aside>

            <main class="content">
                <!-- Quick Start Section -->
                <section id="quickstart" class="section">
                    <h2>Permut8 Firmware in 30 Minutes</h2>
                    
                    <div class="alert alert-info">
                        <strong>New to Permut8?</strong> This quick start guide will get your first custom firmware running in just 30 minutes!
                    </div>

                    <h3>What is Firmware? (For Complete Beginners)</h3>
                    <p>If you're new to audio programming, here's what you need to know:</p>

                    <h4>Firmware vs Plugins</h4>
                    <ul>
                        <li><strong>Regular Audio Plugin</strong>: Software that processes audio on your computer</li>
                        <li><strong>Permut8 Firmware</strong>: Code that runs directly on Permut8 hardware for ultra-low latency</li>
                    </ul>

                    <h4>Why Firmware?</h4>
                    <ul>
                        <li><strong>No Computer Latency</strong>: Audio processing happens instantly on dedicated hardware</li>
                        <li><strong>Real-time Performance</strong>: Perfect for live performance and recording</li>
                        <li><strong>Custom Effects</strong>: Create effects that don't exist anywhere else</li>
                        <li><strong>Hardware Integration</strong>: Direct control from knobs and LEDs</li>
                    </ul>

                    <h3>Five-Minute Setup</h3>
                    
                    <h4>1. Check Your Installation</h4>
                    <p>Navigate to your Permut8 Firmware Code directory and verify you have:</p>
                    <div class="code-block">
Permut8 Firmware Code/
├── PikaCmd.exe           # The Impala compiler
├── ringmod_code.impala   # Example firmware
└── linsub_code.impala    # Example firmware
                    </div>

                    <h4>2. Test the Compiler</h4>
                    <p>Open a command prompt/terminal in this directory and run:</p>
                    <div class="code-block">
PikaCmd.exe -compile ringmod_code.impala
                    </div>
                    <p>You should see <span class="inline-code">ringmod_code.gazl</span> created - that's your compiled firmware!</p>

                    <h4>3. Create and Load Firmware Bank</h4>
                    <ol>
                        <li>Open Permut8 in your DAW</li>
                        <li>Create a firmware bank:
                            <ul>
                                <li>Package your <span class="inline-code">ringmod_code.gazl</span> into <span class="inline-code">ringmod.p8bank</span></li>
                                <li>Add preset configuration (A0: "Ring Modulator")</li>
                            </ul>
                        </li>
                        <li>Load bank: File → Load Bank → <span class="inline-code">ringmod.p8bank</span></li>
                        <li>Select A0 preset</li>
                    </ol>

                    <div class="alert alert-success">
                        <strong>You just loaded custom firmware!</strong> The ring modulator is now running.
                    </div>

                    <h3>Your First Firmware (10 minutes)</h3>
                    <p>Let's create a simple bit crusher from scratch.</p>

                    <h4>1. Create a New File</h4>
                    <p>Create <span class="inline-code">bitcrush.impala</span> with this code:</p>

                    <div class="code-block">
// Bit Crusher - Your First Permut8 Firmware
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2

// Required native function declarations
extern native yield             // Return control to Permut8 audio engine

// Panel text (optional but cool!)
readonly array panelTextRows[8] = {
    "",
    "BIT |-------- CRUSH AMOUNT (MORE BITS = LESS CRUSH) --------|",
    "",
    "",
    "",
    "",
    "",
    ""
}

// Global variables
global array signal[2]          // Left/Right audio samples
global array params[8]          // Knob values
global array displayLEDs[4]     // LED displays

// Main processing function
function process()
locals int bits, int shift, int mask
{
    loop {
        // Read bit depth from first knob (0-255 mapped to 1-12 bits)
        bits = ((int) global params[3] >> 5) + 1;  // 1-8 bits
        shift = 12 - bits;
        mask = 0xFFF0 << shift;
        
        // Light up LEDs to show bit depth
        global displayLEDs[0] = 1 << (bits - 1);
        
        // Process audio: reduce bit depth
        global signal[0] = ((int) global signal[0]) & mask;
        global signal[1] = ((int) global signal[1]) & mask;
        
        // Return control to Permut8
        yield();
    }
}
                    </div>

                    <h4>2. Compile Your Firmware</h4>
                    <div class="code-block">
PikaCmd.exe -compile bitcrush.impala
                    </div>

                    <h4>3. Create Firmware Bank</h4>
                    <p>Package your compiled firmware for distribution:</p>
                    <div class="code-block">
bitcrush.p8bank: {
    CurrentProgram: A0
    Programs: {
        A0: { Name: "Light Crush", Operator1: "2" }
        A1: { Name: "Heavy Crush", Operator1: "6" }
    }
    Firmware: {
        Name: "bitcrush"
        Code: { /* compiled bitcrush.gazl */ }
    }
}
                    </div>

                    <h4>4. Load and Test</h4>
                    <ol>
                        <li>Load bank: File → Load Bank → <span class="inline-code">bitcrush.p8bank</span></li>
                        <li>Select A0 preset (Light Crush) or A1 (Heavy Crush)</li>
                        <li>Play some audio through Permut8</li>
                        <li>Turn the first knob - hear the bit crushing!</li>
                    </ol>

                    <div class="alert alert-success">
                        <strong>Congratulations!</strong> You just created working DSP firmware. The first knob now controls bit depth, creating that classic lo-fi digital sound.
                    </div>
                </section>

                <!-- Language Reference Section -->
                <section id="language" class="section">
                    <h2>Core Language Reference - Essential Impala</h2>
                    
                    <p>The minimal language reference you need to start creating Permut8 firmware.</p>

                    <h3>Impala Basics</h3>
                    <p>Impala is a C-like language that compiles to GAZL assembly. If you know C, you know 90% of Impala.</p>

                    <h4>Key Differences from C:</h4>
                    <ul>
                        <li>No <span class="inline-code">#include</span> or preprocessor</li>
                        <li>No pointers to functions</li>
                        <li>No <span class="inline-code">malloc/free</span> (static memory only)</li>
                        <li>Built-in <span class="inline-code">loop</span> construct</li>
                        <li>Native <span class="inline-code">yield()</span> for cooperative multitasking</li>
                    </ul>

                    <h3>Essential Firmware Structure</h3>

                    <h4>Full Patch (Audio Processing)</h4>
                    <div class="code-block">
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2  // Required!

// Standard Global Layout (Bank-Compatible)
global array signal[2]       // Audio I/O [left, right]
global array params[PARAM_COUNT]  // Plugin parameters  
global array displayLEDs[4]  // LED displays
global int clock = 0         // Clock counter

function process() {
    loop {  // Infinite processing loop
        // Process global signal[0] and signal[1]
        // Audio range: -2047 to 2047 (12-bit)
        
        yield();  // Return control to Permut8
    }
}
                    </div>

                    <h4>Core Global Variables</h4>
                    
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Global</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><span class="inline-code">global array params[PARAM_COUNT]</span></td>
                                <td>int array</td>
                                <td>Knob/switch values (0-255)</td>
                            </tr>
                            <tr>
                                <td><span class="inline-code">global array displayLEDs[4]</span></td>
                                <td>int array</td>
                                <td>LED displays under knobs</td>
                            </tr>
                            <tr>
                                <td><span class="inline-code">global int clock</span></td>
                                <td>int</td>
                                <td>Sample counter (0-65535)</td>
                            </tr>
                            <tr>
                                <td><span class="inline-code">global array signal[2]</span></td>
                                <td>int array</td>
                                <td>Audio samples L/R (-2047 to 2047)</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Data Types</h3>
                    
                    <h4>Basic Types</h4>
                    <ul>
                        <li><span class="inline-code">int</span> - 32-bit signed integer</li>
                        <li><span class="inline-code">float</span> - 32-bit floating point</li>
                        <li><span class="inline-code">pointer</span> - Memory address</li>
                        <li><span class="inline-code">array</span> - Fixed-size array</li>
                    </ul>

                    <h4>Type Casting</h4>
                    <div class="code-block">
int x = (int) global params[3];     // Always cast params[]
float f = itof(x);                  // int to float
int i = ftoi(f);                    // float to int
                    </div>

                    <h3>Control Flow</h3>

                    <h4>Loops</h4>
                    <div class="code-block">
loop { }                // Infinite loop (use yield()!)
for (i = 0 to n) { }    // Inclusive: 0,1,2,...,n
while (x < 10) { }      // Standard while
                    </div>

                    <h4>Conditionals</h4>
                    <div class="code-block">
if (x > 0) { }
else if (x < 0) { }
else { }
                    </div>

                    <h3>LED Display Patterns</h3>
                    <p>LEDs are 8-bit values (0-255) where each bit lights one LED:</p>

                    <div class="code-block">
global displayLEDs[0] = 0x01;  // Single LED (leftmost)
global displayLEDs[0] = 0x80;  // Single LED (rightmost)
global displayLEDs[0] = 0xFF;  // All LEDs on
global displayLEDs[0] = 0x0F;  // Left 4 LEDs
global displayLEDs[0] = 1 << position;  // Variable position
                    </div>
                </section>

                <!-- Audio Engineering for Programmers -->
                <section id="fundamentals" class="section">
                    <h2>Audio Engineering Concepts for Programmers</h2>
                    
                    <p><em>Essential audio knowledge explained in programming terms - Bridge tutorial for developers (25 minutes)</em></p>

                    <h3>What You'll Learn</h3>
                    <p>This tutorial translates essential audio engineering concepts into programming language, giving you the professional foundation needed for quality audio development:</p>

                    <ul>
                        <li><strong>Gain compensation</strong> (like auto-scaling algorithms)</li>
                        <li><strong>Parameter smoothing</strong> (like interpolation techniques)</li>
                        <li><strong>Dynamic range management</strong> (like data type overflow handling)</li>
                        <li><strong>Professional audio practices</strong> (like defensive programming for audio)</li>
                    </ul>

                    <h3>Audio Engineering vs Programming: The Translation</h3>
                    <p>As a programmer, you already understand many audio engineering concepts - you just don't know the audio terminology yet. This tutorial bridges that gap.</p>

                    <table class="table">
                        <thead>
                            <tr>
                                <th>Audio Engineering Term</th>
                                <th>Programming Equivalent</th>
                                <th>What It Means</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Gain Compensation</strong></td>
                                <td>Auto-scaling algorithm</td>
                                <td>Keep output volume consistent when processing changes</td>
                            </tr>
                            <tr>
                                <td><strong>Parameter Smoothing</strong></td>
                                <td>Value interpolation</td>
                                <td>Prevent clicks when values change suddenly</td>
                            </tr>
                            <tr>
                                <td><strong>Dynamic Range</strong></td>
                                <td>Data type range limits</td>
                                <td>Available "space" between quietest and loudest sounds</td>
                            </tr>
                            <tr>
                                <td><strong>Headroom</strong></td>
                                <td>Buffer space</td>
                                <td>Safety margin before clipping/overflow</td>
                            </tr>
                            <tr>
                                <td><strong>Signal-to-Noise Ratio</strong></td>
                                <td>Useful data vs garbage</td>
                                <td>Quality of audio vs unwanted artifacts</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Concept 1: Gain Compensation (Like Auto-Scaling)</h3>

                    <h4>The Programming Problem</h4>
                    <p>Imagine you have a function that processes arrays of numbers, but the processing makes the output unpredictably louder or quieter. This is exactly what happens with audio effects - they change volume as a side effect.</p>

                    <h4>The Audio Engineering Solution</h4>
                    <p><strong>Gain compensation</strong> automatically adjusts the output level to match the input level:</p>

                    <div class="code-block">
function process() {
    loop {
        // Original input level
        int inputLevel = signal[0];
        
        // Apply some effect that changes volume
        int distortionAmount = params[0] / 32;  // 0-7
        int processed = inputLevel * distortionAmount;
        
        // GAIN COMPENSATION: Auto-scale back to original level
        int compensatedGain = 256 / (distortionAmount + 1);  // Inverse scaling
        int compensated = (processed * compensatedGain) / 256;
        
        // Result: Effect applied but volume stays consistent
        signal[0] = compensated;
        signal[1] = compensated;  // Same for right channel
        
        yield();
    }
}
                    </div>

                    <h3>Concept 2: Parameter Smoothing (Like Interpolation)</h3>

                    <h4>The Programming Problem</h4>
                    <p>In audio, sudden parameter changes create audible clicks and pops. Parameter smoothing gradually transitions between values:</p>

                    <div class="code-block">
// Smoothed parameter storage
global int smoothedVolume = 128;
global int smoothedFilter = 128;

function process() {
    loop {
        // Read current knob positions
        int targetVolume = params[0];    // 0-255
        int targetFilter = params[1];    // 0-255
        
        // PARAMETER SMOOTHING: Gradually approach target values
        // Like interpolation: current = current + (target - current) / speed
        smoothedVolume = smoothedVolume + ((targetVolume - smoothedVolume) / 8);
        smoothedFilter = smoothedFilter + ((targetFilter - smoothedFilter) / 16);
        
        // Use smoothed values for processing
        int volume = smoothedVolume;
        int filterAmount = smoothedFilter;
        
        // Apply smoothed parameters
        int processed = (signal[0] * volume) / 255;
        
        signal[0] = processed;
        signal[1] = processed;
        
        yield();
    }
}
                    </div>

                    <div class="alert alert-info">
                        <strong>Why This Matters:</strong> Without parameter smoothing, knob changes sound harsh and unprofessional. With smoothing, knob changes sound smooth and musical.
                    </div>
                </section>

                <!-- Cookbook Recipes -->
                <section id="cookbook" class="section">
                    <h2>Cookbook Recipes</h2>
                    
                    <p>Complete working effects with full source code that you can copy, modify, and learn from.</p>

                    <div id="basic-oscillator" class="card">
                        <div class="card-header">Basic Oscillator</div>
                        <p><em>Generate fundamental audio waveforms</em></p>

                        <h4>What This Does</h4>
                        <p>Generates basic audio waveforms - sine, square, sawtooth, and triangle waves. These are the building blocks of synthesis, providing raw tones that filters and effects can shape into complex sounds.</p>

                        <h4>Quick Reference</h4>
                        <p><strong>Essential Parameters:</strong></p>
                        <ul>
                            <li><span class="inline-code">params[0]</span>: Frequency (0-255, controls pitch)</li>
                            <li><span class="inline-code">params[1]</span>: Waveform type (0-255, selects wave shape)</li>
                            <li><span class="inline-code">params[2]</span>: Amplitude (0-255, controls volume)</li>
                            <li><span class="inline-code">params[3]</span>: Fine tune (0-255, pitch adjustment)</li>
                        </ul>

                        <p><strong>Waveform Types:</strong></p>
                        <ul>
                            <li><strong>Sine</strong>: Pure tone, no harmonics</li>
                            <li><strong>Square</strong>: Hollow, woody character</li>
                            <li><strong>Sawtooth</strong>: Bright, buzzy character</li>
                            <li><strong>Triangle</strong>: Warm, mellow character</li>
                        </ul>

                        <h4>Complete Code</h4>
                        <div class="code-block">
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2

// Required native function declarations
extern native yield             // Return control to Permut8 audio engine

// Standard global variables
global array signal[2]          // Left/Right audio samples
global array params[8]          // Parameter values (0-255)
global array displayLEDs[4]     // LED displays

// Simple oscillator state
global int phase = 0            // Current phase position (0-65535)

function process()
locals int frequency, int wave_type, int amplitude, int fine_tune, int phase_inc, int wave_output, int output
{
    loop {
        // Read parameters
        frequency = ((int)global params[0] << 4) + 100;  // 100-4196 range
        wave_type = ((int)global params[1] >> 6);         // 0-3 wave types
        amplitude = ((int)global params[2] << 3);         // 0-2040 amplitude
        fine_tune = ((int)global params[3] >> 3) - 16;    // -16 to +15 fine tune
        
        // Calculate phase increment (determines frequency)
        phase_inc = frequency + fine_tune;
        if (phase_inc < 50) phase_inc = 50;  // Minimum frequency
        
        // Update phase accumulator
        global phase = global phase + phase_inc;
        if (global phase > 65535) global phase = global phase - 65535;
        
        // Generate waveform based on type
        if (wave_type == 0) {
            // Sine wave (approximation using triangle + smoothing)
            if (global phase < 16384) {
                wave_output = global phase >> 2;          // Rising 0 to 4095
            } else if (global phase < 32768) {
                wave_output = 4095 - ((global phase - 16384) >> 2);  // Falling 4095 to 0
            } else if (global phase < 49152) {
                wave_output = -((global phase - 32768) >> 2);        // Falling 0 to -4095
            } else {
                wave_output = -4095 + ((global phase - 49152) >> 2); // Rising -4095 to 0
            }
            
        } else if (wave_type == 1) {
            // Square wave
            if (global phase < 32768) {
                wave_output = 2047;   // High
            } else {
                wave_output = -2047;  // Low
            }
            
        } else if (wave_type == 2) {
            // Sawtooth wave
            wave_output = (global phase >> 4) - 2047;  // -2047 to 2047 ramp
            
        } else {
            // Triangle wave
            if (global phase < 32768) {
                wave_output = (global phase >> 3) - 2047;     // Rising -2047 to 2047
            } else {
                wave_output = 2047 - ((global phase - 32768) >> 3); // Falling 2047 to -2047
            }
        }
        
        // Apply amplitude scaling
        output = (wave_output * amplitude) >> 11;  // Scale by amplitude
        
        // Prevent clipping
        if (output > 2047) output = 2047;
        if (output < -2047) output = -2047;
        
        // Output same signal to both channels
        global signal[0] = output;
        global signal[1] = output;
        
        // Show activity on LEDs
        global displayLEDs[0] = frequency >> 4;
        global displayLEDs[1] = wave_type << 6;
        global displayLEDs[2] = amplitude >> 3;
        global displayLEDs[3] = (global phase >> 8);  // Show phase position
        
        yield();
    }
}
                        </div>
                    </div>

                    <div id="make-delay" class="card">
                        <div class="card-header">Make a Delay</div>
                        
                        <h4>What This Does</h4>
                        <p>Creates a simple delay effect with adjustable delay time and feedback amount. The delayed signal is mixed with the original to create echo effects ranging from short slap-back delays to long ambient trails.</p>

                        <h4>Quick Reference</h4>
                        <p><strong>Parameters</strong>:</p>
                        <ul>
                            <li><strong>Knob 1 (params[0])</strong>: Delay time (1-1000 samples, timing varies with sample rate)</li>
                            <li><strong>Knob 2 (params[1])</strong>: Feedback amount (0-90% to prevent runaway)</li>
                            <li><strong>Knob 3 (params[5])</strong>: [Available for expansion]</li>
                            <li><strong>Knob 4 (params[6])</strong>: [Available for expansion]</li>
                        </ul>

                        <p><strong>Key Concepts</strong>: Memory read/write operations, feedback loops, circular buffering</p>

                        <h4>Complete Code</h4>
                        <div class="code-block">
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2

// Required native function declarations
extern native yield             // Return control to Permut8 audio engine
extern native read              // Read from delay line memory
extern native write             // Write to delay line memory

// Standard global variables
global array signal[2]          // Left/Right audio samples
global array params[8]          // Parameter values (0-255)
global array displayLEDs[4]     // LED displays

// Delay processing variables
global array delayBuffer[2]     // Temporary buffer for memory operations
global int delayIndex = 0       // Current position in delay buffer
global int maxDelayTime = 1000  // Maximum delay in samples

// Utility function for audio clipping
function clipAudio(int sample) returns int clipped {
    if (sample > 2047) clipped = 2047
    else if (sample < -2047) clipped = -2047
    else clipped = sample
}

function process() {
    loop {
        operate1()  // Process left channel
        operate2()  // Process right channel
    }
}

function operate1() {
    // === PARAMETER READING ===
    int delayTime = ((int)params[0] * maxDelayTime / 255) + 1  // 1-1000 samples
    int feedbackAmount = (int)params[1] * 90 / 255             // 0-90% feedback
    
    // === DELAY PROCESSING ===
    // Read delayed sample from memory (fixed offset from write position)
    int readPos = (delayIndex - delayTime + maxDelayTime) % maxDelayTime
    read(readPos, 1, delayBuffer)
    int delayedSample = delayBuffer[0]
    
    // Mix input with delayed signal for output
    int input = signal[0]
    int output = input + (delayedSample * feedbackAmount / 100)
    output = clipAudio(output)
    
    // Store new sample (input + feedback) for next delay iteration
    delayBuffer[0] = input + (delayedSample * feedbackAmount / 100)
    delayBuffer[0] = clipAudio(delayBuffer[0])
    
    write(delayIndex, 1, delayBuffer)
    
    // Update delay buffer position (fixed circular buffer)
    delayIndex = (delayIndex + 1) % maxDelayTime
    
    // === OUTPUT AND VISUALIZATION ===
    // Show delay activity on LEDs (lights when delayed signal is audible)
    int ledPattern = 0
    if (delayedSample > 100 || delayedSample < -100) {
        ledPattern = (1 << (delayIndex % 8))
    }
    displayLEDs[0] = ledPattern
    
    signal[0] = output
    yield()
}

function operate2() {
    // === RIGHT CHANNEL PROCESSING ===
    // Identical delay processing for right channel using offset memory location
    int delayTime = ((int)params[0] * maxDelayTime / 255) + 1
    int feedbackAmount = (int)params[1] * 90 / 255
    
    // Use offset memory location to avoid interference with left channel
    int readPos = ((delayIndex - delayTime + maxDelayTime) % maxDelayTime) + maxDelayTime
    read(readPos, 1, delayBuffer)
    int delayedSample = delayBuffer[0]
    
    int input = signal[1]
    int output = input + (delayedSample * feedbackAmount / 100)
    output = clipAudio(output)
    
    // Store sample with feedback
    delayBuffer[0] = input + (delayedSample * feedbackAmount / 100)
    delayBuffer[0] = clipAudio(delayBuffer[0])
    
    write(delayIndex + maxDelayTime, 1, delayBuffer)
    
    signal[1] = output
    yield()
}
                        </div>

                        <h4>How It Works</h4>
                        <p>The delay effect stores incoming audio samples in memory using the <span class="inline-code">read()</span> and <span class="inline-code">write()</span> functions, then plays them back after a specified time interval. The core algorithm uses a fixed-size circular buffer approach where <span class="inline-code">delayIndex</span> tracks the current write position, wrapping at <span class="inline-code">maxDelayTime</span> to maintain consistent memory management.</p>
                    </div>
                </section>

                <!-- Architecture Section -->
                <section id="architecture" class="section">
                    <h2>Architecture Reference</h2>

                    <div id="mod-vs-full">
                        <h3>Mod vs Full Patch Architecture Decision Guide</h3>
                        
                        <p><strong>Choose the right firmware architecture for your project</strong></p>

                        <p>One of the most important decisions in Permut8 firmware development is choosing between <strong>Mod patches</strong> and <strong>Full patches</strong>. This choice affects everything from development complexity to performance characteristics.</p>

                        <h4>Understanding the Two Architectures</h4>

                        <h5>Full Patches: Complete Audio Processing Chain</h5>
                        <p><strong>Full patches</strong> replace Permut8's entire audio processing chain with your custom code.</p>

                        <div class="code-block">
// === FULL PATCH EXAMPLE ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2

// Required globals for Full patches
global array signal[2]          // Direct audio I/O
global array params[PARAM_COUNT]
global array displayLEDs[4]

function process()
{
    loop {
        // YOU control the entire audio path
        int inputLeft = global signal[0]    // Raw input
        int inputRight = global signal[1]
        
        // Your complete effect processing
        int outputLeft = processMyEffect(inputLeft)
        int outputRight = processMyEffect(inputRight)
        
        // Direct output to hardware
        global signal[0] = outputLeft
        global signal[1] = outputRight
        
        yield()
    }
}
                        </div>

                        <p><strong>Key Characteristics</strong>:</p>
                        <ul>
                            <li><strong>Complete control</strong> over audio processing</li>
                            <li><strong>Direct hardware access</strong> to audio inputs/outputs</li>
                            <li><strong>No Permut8 built-in effects</strong> - you implement everything</li>
                            <li><strong>Higher complexity</strong> but maximum flexibility</li>
                        </ul>

                        <h5>Mod Patches: Operator Replacement</h5>
                        <p><strong>Mod patches</strong> replace one or both of Permut8's built-in operators while keeping the rest of the processing chain intact.</p>

                        <div class="code-block">
// === MOD PATCH EXAMPLE ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2

// Required globals for Mod patches  
global array positions[2]       // Memory position I/O
global array params[PARAM_COUNT]
global array displayLEDs[4]

// Replace Operator 1 with custom processing
function operate1()
returns int processed
locals array inputSamples[2], array outputSamples[2]
{
    // Read from memory positions
    read(global positions[0], 1, inputSamples)
    
    // Your operator processing
    outputSamples[0] = processMyOperator(inputSamples[0])
    outputSamples[1] = inputSamples[1]  // Pass through right channel
    
    // Write back to memory
    write(global positions[0], 1, outputSamples)
    
    return 1  // Indicate we processed the audio
}
                        </div>

                        <p><strong>Key Characteristics</strong>:</p>
                        <ul>
                            <li><strong>Integrates with Permut8's chain</strong> - delay, feedback, etc. still work</li>
                            <li><strong>Memory-based I/O</strong> instead of direct audio</li>
                            <li><strong>Lower complexity</strong> - focus on your specific operator</li>
                            <li><strong>Limited scope</strong> but easier development</li>
                        </ul>

                        <h4>Decision Matrix</h4>

                        <h5>Choose Full Patch When:</h5>
                        <div class="alert alert-success">
                            <strong>✅ Complete Effect Replacement</strong>
                            <ul>
                                <li>Reverbs, delays, and time-based effects</li>
                                <li>Multi-band processors (EQ, compressor)</li>
                                <li>Synthesizers and tone generators</li>
                                <li>Complex routing and mixing</li>
                                <li>Spectral processing (FFT-based effects)</li>
                            </ul>
                        </div>

                        <h5>Choose Mod Patch When:</h5>
                        <div class="alert alert-info">
                            <strong>✅ Operator-Style Effects</strong>
                            <ul>
                                <li>Distortion and waveshaping</li>
                                <li>Bit manipulation effects</li>
                                <li>Simple filters and EQ</li>
                                <li>Amplitude modulation</li>
                                <li>Ring modulation</li>
                            </ul>
                        </div>

                        <h4>Development Complexity Comparison</h4>
                        
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Full Patch</th>
                                    <th>Mod Patch</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Boilerplate Code</strong></td>
                                    <td>Moderate</td>
                                    <td>Minimal</td>
                                </tr>
                                <tr>
                                    <td><strong>Audio I/O</strong></td>
                                    <td>Direct <span class="inline-code">signal[]</span> access</td>
                                    <td>Memory <span class="inline-code">read()</span>/<span class="inline-code">write()</span></td>
                                </tr>
                                <tr>
                                    <td><strong>Parameter Handling</strong></td>
                                    <td>Manual mapping</td>
                                    <td>Automatic integration</td>
                                </tr>
                                <tr>
                                    <td><strong>LED Control</strong></td>
                                    <td>Manual implementation</td>
                                    <td>Automatic integration</td>
                                </tr>
                                <tr>
                                    <td><strong>Clock/Timing</strong></td>
                                    <td>Manual management</td>
                                    <td>Automatic synchronization</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div id="memory-model">
                        <h3>Memory Model</h3>
                        
                        <p>Impala's memory model is specifically designed for real-time audio processing on resource-constrained hardware. Understanding how Impala manages memory is crucial for developing efficient, reliable, and performant firmware for the Permut8 platform.</p>

                        <p><strong>Core Philosophy</strong>: Predictable, deterministic memory behavior with zero-overhead abstractions for real-time audio requirements.</p>

                        <h4>Memory Architecture Overview</h4>

                        <div class="code-block">
┌─────────────────────────────────────┐
│          Program Memory             │ ← Code, constants, string literals
│        (Read-Only Flash)            │
├─────────────────────────────────────┤
│        Global Data Region           │ ← Global variables, static arrays
│      (Static Allocation)            │
├─────────────────────────────────────┤
│         Stack Region                │ ← Function parameters, local variables
│     (Automatic Management)          │
├─────────────────────────────────────┤
│        Audio Buffer Region          │ ← signal[], delay memory
│    (Hardware-Mapped Memory)         │
├─────────────────────────────────────┤
│      Parameter Region               │ ← params[] array, control values
│   (Live Hardware Interface)         │
├─────────────────────────────────────┤
│       Display Region                │ ← displayLEDs[] array
│    (Output Hardware Interface)      │
└─────────────────────────────────────┘
                        </div>

                        <h4>Memory Region Characteristics</h4>
                        
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Region</th>
                                    <th>Allocation Type</th>
                                    <th>Access Speed</th>
                                    <th>Typical Use</th>
                                    <th>Size Limit</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Program</strong></td>
                                    <td>Compile-time</td>
                                    <td>Fast</td>
                                    <td>Code, constants</td>
                                    <td>32KB</td>
                                </tr>
                                <tr>
                                    <td><strong>Global</strong></td>
                                    <td>Compile-time</td>
                                    <td>Fast</td>
                                    <td>Static data, lookup tables</td>
                                    <td>8KB</td>
                                </tr>
                                <tr>
                                    <td><strong>Stack</strong></td>
                                    <td>Runtime (automatic)</td>
                                    <td>Very Fast</td>
                                    <td>Local variables, parameters</td>
                                    <td>4KB</td>
                                </tr>
                                <tr>
                                    <td><strong>Audio Buffer</strong></td>
                                    <td>Hardware-mapped</td>
                                    <td>Ultra Fast</td>
                                    <td>Real-time audio processing</td>
                                    <td>2KB</td>
                                </tr>
                                <tr>
                                    <td><strong>Parameter</strong></td>
                                    <td>Hardware-mapped</td>
                                    <td>Medium</td>
                                    <td>Control interface</td>
                                    <td>512B</td>
                                </tr>
                                <tr>
                                    <td><strong>Display</strong></td>
                                    <td>Hardware-mapped</td>
                                    <td>Slow</td>
                                    <td>Visual feedback</td>
                                    <td>256B</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>Static Memory Management</h4>

                        <h5>Global Variable Allocation</h5>
                        <p>Impala allocates global variables in the Global Data Region at compile time, ensuring predictable memory layout:</p>

                        <div class="code-block">
// Global arrays - allocated at compile time in Global Data Region
global array delayBuffer[1024];
global array filterCoefficients[128];
global array lookupTable[256];

// Global state variables
global int sampleRate = 48000;
global int bufferIndex = 0;
global int currentGain = 128;
                        </div>
                    </div>
                </section>

                <!-- API Reference Section -->
                <section id="reference" class="section">
                    <h2>API Reference</h2>

                    <h3>Parameters Reference</h3>
                    
                    <p>The <span class="inline-code">params[]</span> array gives your firmware access to all knob positions, switch states, and system settings. Updated automatically by Permut8 when users turn knobs or flip switches.</p>

                    <h4>Core Concepts</h4>
                    
                    <h5>Array Structure</h5>
                    <div class="code-block">
global array params[8]  // 8-bit values (0-255)
                    </div>
                    <p><strong>All parameters are integers from 0 to 255</strong>, representing the full range of each physical control.</p>

                    <h5>Parameter Indices</h5>
                    <div class="code-block">
params[0] = CLOCK_FREQ_PARAM_INDEX      // Sample rate in Hz
params[1] = SWITCHES_PARAM_INDEX        // Bit mask of switch states  
params[2] = OPERATOR_1_PARAM_INDEX      // Operator 1 selection (0-4)
params[3] = OPERAND_1_HIGH_PARAM_INDEX  // Knob 1 (top-left)
params[4] = OPERAND_1_LOW_PARAM_INDEX   // Knob 2 (bottom-left) 
params[5] = OPERATOR_2_PARAM_INDEX      // Operator 2 selection (0-4)
params[6] = OPERAND_2_HIGH_PARAM_INDEX  // Knob 3 (top-right)
params[7] = OPERAND_2_LOW_PARAM_INDEX   // Knob 4 (bottom-right)
                    </div>

                    <h4>Reading Parameters</h4>

                    <h5>Basic Access</h5>
                    <div class="code-block">
function update() {
    int knob1 = (int)params[OPERAND_1_HIGH_PARAM_INDEX];
    int switches = (int)params[SWITCHES_PARAM_INDEX];
    
    // Always cast to int for calculations
    if (knob1 > 127) {
        // Do something when knob is past halfway
    }
}
                    </div>

                    <h5>Switch State Testing</h5>
                    <div class="code-block">
// Test individual switches using bit masks
if ((int)params[SWITCHES_PARAM_INDEX] & SWITCHES_SYNC_MASK) {
    // Sync switch is ON
}

if ((int)params[SWITCHES_PARAM_INDEX] & SWITCHES_REVERSE_MASK) {
    // Reverse switch is ON
}
                    </div>

                    <p><strong>Available switch masks:</strong></p>
                    <ul>
                        <li><span class="inline-code">SWITCHES_SYNC_MASK</span> - Tempo sync enable</li>
                        <li><span class="inline-code">SWITCHES_TRIPLET_MASK</span> - Triplet timing</li>
                        <li><span class="inline-code">SWITCHES_DOTTED_MASK</span> - Dotted timing</li>
                        <li><span class="inline-code">SWITCHES_WRITE_PROTECT_MASK</span> - Memory write protection</li>
                        <li><span class="inline-code">SWITCHES_REVERSE_MASK</span> - Reverse playback</li>
                    </ul>

                    <h4>Common Conversions</h4>

                    <h5>Knob to Percentage</h5>
                    <div class="code-block">
int percent = (int)params[OPERAND_1_HIGH_PARAM_INDEX] * 100 / 255;
// Result: 0% to 100%
                    </div>

                    <h5>Knob to Float Range</h5>
                    <div class="code-block">
float mix = itof((int)params[OPERAND_1_HIGH_PARAM_INDEX]) / 255.0;
// Result: 0.0 to 1.0
                    </div>

                    <h5>Knob to Bit Depth</h5>
                    <div class="code-block">
int bits = ((int)params[OPERAND_1_HIGH_PARAM_INDEX] >> 5) + 1;
// Result: 1 to 8 bits
                    </div>

                    <h3>Audio Processing Reference</h3>

                    <p>Core DSP concepts and audio processing techniques for Permut8 firmware. Covers signal flow, filtering, effects algorithms, and optimization patterns for real-time audio.</p>

                    <h4>Signal Flow Fundamentals</h4>

                    <h5>Constants and Definitions</h5>
                    <div class="code-block">
// Essential mathematical constants
const int TWO_PI_SCALED = 6283  // TWO_PI * 1000 for fixed-point math

// Permut8 audio sample range
const int AUDIO_MIN = -2047
const int AUDIO_MAX = 2047
const int AUDIO_ZERO = 0
                    </div>

                    <h5>Audio Signal Range</h5>
                    <div class="code-block">
// 12-bit signed samples
// Full scale ≈ ±2048 (12-bit range)
// Quiet signals: ±10 to ±100
// Moderate signals: ±500 to ±1500  
// Loud signals: ±1500 to ±2047
                    </div>

                    <h4>Basic Filters</h4>

                    <h5>Simple Low-Pass Filter</h5>
                    <div class="code-block">
global int lastOutputLeft = 0;
global int lastOutputRight = 0;

function lowPassFilter(int input, int lastOutput) 
returns int filtered {
    // Simple RC-style low-pass: Y[n] = Y[n-1] + (X[n] - Y[n-1]) * cutoff
    int cutoffAmount = (int)params[OPERAND_1_HIGH_PARAM_INDEX];  // 0-255
    
    // Scale cutoff (0-255 → 0-32 for stability)
    int scaledCutoff = cutoffAmount >> 3;  // Divide by 8
    
    // Filter calculation
    int difference = input - lastOutput;
    filtered = lastOutput + ((difference * scaledCutoff) >> 8);
}
                    </div>

                    <h4>Distortion and Waveshaping</h4>

                    <h5>Hard Clipping</h5>
                    <div class="code-block">
function hardClip(int input, int threshold) 
returns int clipped {
    if (input > threshold) clipped = threshold;
    else if (input < -threshold) clipped = -threshold;
    else clipped = input;
}
                    </div>

                    <h5>Soft Clipping (Tanh Approximation)</h5>
                    <div class="code-block">
function softClip(int input) 
returns int clipped {
    // Approximate tanh using polynomial
    // tanh(x) ≈ x - x³/3 for small x
    
    if (input > 1500 || input < -1500) {
        // Hard limit for extreme values
        if (input > 0) {
            return 1500;
        } else {
            return -1500;
        }
    }
    
    // Soft clipping calculation
    int x = input >> 2;           // Scale down to prevent overflow
    int x_cubed = ((x * x) >> 8) * x >> 8;  // x³ approximation
    int soft = x - (x_cubed / 3);
    
    return soft << 2;  // Scale back up
}
                    </div>
                </section>

                <!-- Tutorials Section -->
                <section id="tutorials" class="section">
                    <h2>Tutorials</h2>

                    <div id="audio-io" class="card">
                        <div class="card-header">Getting Audio In and Out - Your First Working Plugin</div>
                        
                        <h4>What This Tutorial Does</h4>
                        <p>Create the simplest possible working plugin that proves your Permut8 setup is working. In just 10 minutes, you'll have audio passing through your own custom firmware and understand the basic structure every plugin needs.</p>

                        <h4>What You'll Learn</h4>
                        <ul>
                            <li>Essential plugin structure that every firmware needs</li>
                            <li>How audio flows into and out of your plugin</li>
                            <li>The minimal code required for a working plugin</li>
                            <li>How to verify your development environment is working</li>
                            <li>Foundation concepts for all future plugin development</li>
                        </ul>

                        <p><strong>Prerequisites</strong>: None - this is your starting point!<br>
                        <strong>Time Required</strong>: 10 minutes<br>
                        <strong>Difficulty</strong>: Absolute Beginner</p>

                        <h4>Step 1: Understanding the Goal</h4>
                        
                        <h5>What We're Building</h5>
                        <p>A plugin that:</p>
                        <ul>
                            <li>✅ Loads successfully into Permut8</li>
                            <li>✅ Passes audio through unchanged</li>
                            <li>✅ Proves your development environment works</li>
                            <li>✅ Gives you the foundation for all future plugins</li>
                        </ul>

                        <h4>Step 2: Create Your First Plugin</h4>

                        <h5>The Absolute Minimum Code</h5>
                        <p>Create a new text file called <span class="inline-code">audio_passthrough.impala</span>:</p>

                        <div class="code-block">
// My First Plugin - Audio Passthrough
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2

global array signal[2]
global array params[8]
global array displayLEDs[4]

function process()
{
    loop {
        // Audio automatically passes through - we don't need to do anything!
        yield()
    }
}
                        </div>

                        <h5>Understanding Each Line</h5>

                        <p><strong>Line 1: Comment</strong></p>
                        <div class="code-block">
// My First Plugin - Audio Passthrough
                        </div>
                        <ul>
                            <li>Comments start with <span class="inline-code">//</span> and help you remember what your code does</li>
                            <li>Always document your plugins for future reference</li>
                        </ul>

                        <p><strong>Line 2: Format Declaration</strong></p>
                        <div class="code-block">
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
                        </div>
                        <ul>
                            <li><strong>REQUIRED</strong> - tells Permut8 this is a valid plugin</li>
                            <li>Must be exactly this line in every plugin you create</li>
                            <li>Version 2 is for Permut8 v1.1 and later</li>
                        </ul>

                        <p><strong>Lines 4-6: Global Variables</strong></p>
                        <div class="code-block">
global array signal[2]      // Audio input and output
global array params[8]      // Knob values from hardware
global array displayLEDs[4] // LED display control
                        </div>
                        <ul>
                            <li><strong>REQUIRED</strong> - these connect your plugin to Permut8 hardware</li>
                            <li><span class="inline-code">signal[2]</span> = left and right audio channels</li>
                            <li><span class="inline-code">params[8]</span> = values from 8 knobs (we'll use these later)</li>
                            <li><span class="inline-code">displayLEDs[4]</span> = control for LED displays (we'll use these later)</li>
                        </ul>

                        <div class="alert alert-success">
                            <strong>🎉 Congratulations!</strong> You just created and loaded your first custom Permut8 plugin!
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">Complete Development Workflow Tutorial</div>
                        
                        <p><strong>Master the end-to-end firmware development process</strong></p>

                        <p>This comprehensive tutorial walks you through the complete development workflow for Permut8 firmware, from initial concept to working plugin. You'll learn professional development practices, compilation processes, testing strategies, and debugging techniques that ensure reliable, high-quality firmware.</p>

                        <h4>What You'll Learn</h4>
                        <p>By the end of this tutorial, you'll master:</p>
                        <ul>
                            <li>Complete development workflow from concept to deployment</li>
                            <li>Professional project organization and planning</li>
                            <li>Compilation process and build tools</li>
                            <li>Testing and validation strategies</li>
                            <li>Debugging techniques and troubleshooting</li>
                            <li>Performance optimization workflow</li>
                            <li>Version management and documentation</li>
                        </ul>

                        <h4>The Complete Development Cycle</h4>
                        <p>Professional Development Phases:</p>
                        <ol>
                            <li><strong>Concept & Planning</strong> (10-20% of time)
                                <ul>
                                    <li>Define requirements and specifications</li>
                                    <li>Research algorithms and techniques</li>
                                    <li>Plan project structure and milestones</li>
                                </ul>
                            </li>
                            <li><strong>Architecture Decision</strong> (5-10% of time)
                                <ul>
                                    <li>Choose Mod vs Full patch architecture</li>
                                    <li>Design data flow and memory usage</li>
                                    <li>Plan parameter mapping and UI</li>
                                </ul>
                            </li>
                            <li><strong>Implementation</strong> (40-50% of time)
                                <ul>
                                    <li>Write core algorithms</li>
                                    <li>Implement parameter handling</li>
                                    <li>Add LED feedback and UI elements</li>
                                </ul>
                            </li>
                            <li><strong>Testing & Debugging</strong> (20-30% of time)
                                <ul>
                                    <li>Validate functionality</li>
                                    <li>Test edge cases and error conditions</li>
                                    <li>Debug issues and optimize performance</li>
                                </ul>
                            </li>
                            <li><strong>Documentation & Deployment</strong> (10-15% of time)
                                <ul>
                                    <li>Document usage and parameters</li>
                                    <li>Create deployment packages</li>
                                    <li>Plan updates and maintenance</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                </section>

                <!-- Glossary Section -->
                <section id="glossary" class="section">
                    <h2>Permut8 Firmware Development Glossary</h2>
                    
                    <p><em>Complete terminology reference for embedded audio programming with Impala</em></p>

                    <h3>Foundation Concepts</h3>

                    <h4>DSP and Audio Fundamentals</h4>

                    <p><strong>Digital Signal Processing (DSP)</strong><br>
                    Real-time manipulation of audio using mathematical algorithms. In Permut8, DSP means changing numbers that represent audio samples to create effects.</p>

                    <p><strong>Audio samples</strong><br>
                    Individual numbers representing speaker position at one moment in time. In Permut8: integers from -2047 to +2047 representing 12-bit audio precision.</p>

                    <p><strong>Real-time audio processing</strong><br>
                    Processing audio samples immediately as they arrive, 44,100 times per second, with predictable timing constraints requiring yield() calls.</p>

                    <p><strong>Code-to-sound relationship</strong><br>
                    Fundamental DSP concept: changing numbers in code immediately changes what listeners hear through speakers.</p>

                    <h4>Language Foundation</h4>

                    <p><strong>Impala</strong><br>
                    Real-time audio programming language for embedded systems, specifically designed for Permut8 hardware. Optimized for predictable execution with static memory allocation and cooperative multitasking.</p>

                    <p><strong>yield()</strong><br>
                    Native function that returns control to the audio engine every sample, essential for real-time processing. Must be called once per processing cycle.</p>
                    <div class="code-block">
yield(); // Return control to host
                    </div>

                    <p><strong>extern native</strong><br>
                    Declaration keyword for system-provided functions available from Permut8 hardware.</p>
                    <div class="code-block">
extern native yield
                    </div>

                    <h4>Hardware Interface</h4>

                    <p><strong>signal[2]</strong><br>
                    Global audio I/O array for stereo processing (left/right channels). Audio samples range from -2047 to 2047.</p>
                    <div class="code-block">
global array signal[2]  // [left, right] audio samples
                    </div>

                    <p><strong>params[8]</strong><br>
                    Global parameter array for hardware knob values (0-255 range).</p>
                    <div class="code-block">
global array params[8]  // Knob values (0-255)
                    </div>

                    <p><strong>displayLEDs[4]</strong><br>
                    Global LED control array for visual feedback (8-bit brightness masks).</p>
                    <div class="code-block">
global array displayLEDs[4]  // LED control arrays
                    </div>

                    <h3>Audio Processing</h3>

                    <h4>Waveform Types</h4>

                    <p><strong>Triangle wave</strong><br>
                    Linear waveform creating smooth, warm sound character.</p>
                    <div class="code-block">
if (phase < 32768) {
    amplitude = phase - 16384;
} else {
    amplitude = 49152 - phase;
}
                    </div>

                    <p><strong>Square wave</strong><br>
                    Binary waveform creating harsh, buzzy sound character.</p>
                    <div class="code-block">
if (phase < 32768) {
    amplitude = 16384;
} else {
    amplitude = -16384;
}
                    </div>

                    <p><strong>Sawtooth wave</strong><br>
                    Linear ramp waveform creating bright, buzzy sound with rich harmonic content.</p>
                    <div class="code-block">
amplitude = (phase / 2) - 16384;  // Linear ramp
                    </div>

                    <h4>Parameter Control</h4>

                    <p><strong>Parameter scaling</strong><br>
                    Converting 0-255 knob values to usable parameter ranges through mathematical transformation.</p>
                    <div class="code-block">
int scaledValue = minValue + ((knobValue * (maxValue - minValue)) / 255);
                    </div>

                    <p><strong>Parameter smoothing</strong><br>
                    Gradual transition between parameter values to prevent audio artifacts and clicking.</p>
                    <div class="code-block">
smoothedValue = smoothedValue + ((targetValue - smoothedValue) / 8);
                    </div>

                    <p><strong>Zipper noise</strong><br>
                    Audio artifacts from sudden parameter changes causing clicking or zipper sounds. Prevented by parameter smoothing.</p>

                    <h3>Development Workflow</h3>

                    <h4>Firmware Types</h4>

                    <p><strong>Full patches</strong><br>
                    Firmware replacing entire DSP engine with complete audio processing. Implements <span class="inline-code">process()</span> function for direct signal control.</p>

                    <p><strong>Mod patches</strong><br>
                    Firmware modifying built-in operators without replacing entire DSP chain. Implements <span class="inline-code">operate1()</span> and/or <span class="inline-code">operate2()</span> functions.</p>

                    <p><strong>PikaCmd.exe</strong><br>
                    Impala compiler executable that converts .impala source files to .gazl assembly.</p>
                    <div class="code-block">
PikaCmd.exe -compile ringmod_code.impala
                    </div>

                    <h4>Memory Management</h4>

                    <p><strong>Static memory</strong><br>
                    Fixed allocation using global arrays with predictable memory usage for real-time constraints.</p>
                    <div class="code-block">
global array buffer[1024];  // Static allocation
                    </div>

                    <p><strong>Circular buffer</strong><br>
                    Fixed-size array with wraparound indexing for continuous data storage.</p>
                    <div class="code-block">
buffer[pos % BUFFER_SIZE] = sample;
                    </div>
                </section>
            </main>
        </div>
    </div>

    <button class="back-to-top" id="backToTop">↑</button>

    <script>
        // Search functionality
        document.getElementById('searchInput').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const sections = document.querySelectorAll('.section');
            
            sections.forEach(section => {
                const text = section.textContent.toLowerCase();
                if (searchTerm === '' || text.includes(searchTerm)) {
                    section.style.display = 'block';
                } else {
                    section.style.display = 'none';
                }
            });
        });

        // Back to top functionality
        const backToTopButton = document.getElementById('backToTop');
        
        window.addEventListener('scroll', function() {
            if (window.pageYOffset > 300) {
                backToTopButton.style.display = 'block';
            } else {
                backToTopButton.style.display = 'none';
            }
        });

        backToTopButton.addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Highlight active section in navigation
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    document.querySelectorAll('.sidebar a').forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href') === `#${id}`) {
                            link.classList.add('active');
                        }
                    });
                }
            });
        }, {
            rootMargin: '-20% 0px -80% 0px'
        });

        document.querySelectorAll('.section[id]').forEach(section => {
            observer.observe(section);
        });

        // Print functionality
        function printPage() {
            window.print();
        }

        // Copy code functionality
        document.querySelectorAll('.code-block').forEach(block => {
            block.addEventListener('dblclick', function() {
                const text = this.textContent;
                navigator.clipboard.writeText(text).then(() => {
                    // Show temporary feedback
                    const originalBg = this.style.backgroundColor;
                    this.style.backgroundColor = '#e8f5e8';
                    setTimeout(() => {
                        this.style.backgroundColor = originalBg;
                    }, 500);
                });
            });
        });

        // Add tooltips to code blocks
        document.querySelectorAll('.code-block').forEach(block => {
            block.title = 'Double-click to copy code';
        });
    </script>
</body>
</html>