/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
const int FALSE = 0
const int TRUE = 1
const float LOG2 = 0.69314718055994530942
const float C3_FREQUENCY = 261.6255653005986346778499935233
const int NOP_MODE = 0
const int SAMPLE_MODE = 1
const int SQUARE_MODE = 2
const int GRAIN_MODE = 3
const int COMB_MODE = 4
const int KEY_LOW_MODE = 1
const int KEY_HIGH_MODE = 2
const int ARPEG_MODE = 3
const int RANDOM_MODE = 4
const int GRAIN_DRIFT = TRUE
const int PITCHED_REVERSED = TRUE
const int ALSO_SHIFT_NOTES = FALSE
const int CROSSFADE_INPUT = FALSE
const int CROSSFADE_SAMPLES = FALSE
const int SLOW_RELEASE = 0x40
const int FAST_RELEASE = 0x800
const int STANDARD_ATTACK = 0x2000
const int COMB_ATTACK = 0xA000

global int clock = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int clockFreqLimit = 132300
global array signal[2]
global int rndSeedX = 123456789
global int rndSeedY = 362436069
global array NOTE_RATES[64]
global array SQRT_TABLE[4097]
global int doReset = TRUE
global int updateBits = TRUE

function error()
{
    // PARA *1
    // MOVp %1 $s
    trace();
    abort();
    // RETU
}

function exp()
locals float a, float n, float m, float t
{
    // ABSf $m $x
    // MOVf $a #1.0
    // MOVf $n #1.0
    // MOVf $y #1.0
    // .l0: MOVf $t $y
    // MULf %0 $a $m
    // DIVf $a %0 $n
    // ADDf $y $y $a
    // ADDf $n $n #1.0
    // NEQf $y $t @.l0
    // GEQf $x #0.0 @.f1
    // DIVf $y #1.0 $y
    // .f1: RETU
}

function sqrt()
locals float t
{
    // GEQf $x #0.0 @.f0
    // MOVp %1 &.s_Domain4aa4a1ca
    error();
    // .f0: MOVf $y $x
    // MOVf $t #0.0
    // .l1: EQUf $y $t @.e2
    // MOVf $t $y
    // DIVf %0 $x $y
    // ADDf %0 $y %0
    // MULf $y #0.5 %0
    // continue loop
    // .e2: RETU
    // GLOB *1
    // rndSeedX: DATi #123456789
    // GLOB *1
    // rndSeedY: DATi #362436069
}

function seedRandom()
locals int x
{
    // PARA *1
    // ADDi $x $seed #1
    // SHLi %0 $x #11
    // XORi $x $x %0
    // MULi %0 $x #134775813
    // SHRu %0 %0 #13
    // MULi $x $x %0
    // SHRu %0 $x #17
    // XORi $x $x %0
    // Write to &rndSeedX
    // Write to &rndSeedY
    // RETU
}

function randomFloat()
locals int x, int y, int t
{
    // Read from &rndSeedX
    // Read from &rndSeedY
    // SHLi %0 $x #10
    // XORi $t $x %0
    x = y;
    // SHRu %0 $y #13
    // XORi %0 $y %0
    // XORi %0 %0 $t
    // SHRu %1 $t #10
    // XORi $y %0 %1
    // ABSi %0 $y
    // iTOf $f %0 #4.6566128730774e-10
    // Write to &rndSeedX
    // Write to &rndSeedY
    // RETU
}

function init()
locals int i
{
    // PARA *1
    // MOVp %1 &.s_init4aa4a1cb
    trace();
    // EQUi #CROSSFADE_SAMPLES #FALSE @.f0
    i = 0;
    if (condition) {
    // .l2: NOOP
    // ! DIVf <A> #1.0 #4096.0
    // iTOf %1 $i <A>
    sqrt();
    // fTOi %0 %0 #65536.0
    // Write to &SQRT_TABLE
    // FORi $i #4097 @.l2
    // .f0: MOVi $i #0
    if (condition) {
    // .l4: SUBi %1 $i #36
    // ! DIVf <A> #LOG2 #12.0
    // iTOf %1 %1 <A>
    exp();
    // Write to &NOTE_RATES
    // FORi $i #64 @.l4
    // .e3: RETU
}

function reset()
{
    // PARA *1
    // MOVp %1 &.s_reset4aa4a1cc
    trace();
    // Write to &doReset
    // RETU
}

function update()
{
    // PARA *1
    // MOVp %1 &.s_update4aa4a1cd
    trace();
    // Write to &updateBits
    // RETU
}

function process()
locals int i, int j, int l, int e, int m, int x, int y, float f, int trig, int key, float rate, int oscModeOp, int left, int right, int inL, int inR, int aL, int aR, int bL, int bR, int clock, float bSamples, float aSamples, int step, int nextStep, int subStep, int xpose, int noteBits, int euclideanBits, float semisList, int semisCount, float octsList, int octsCount, int op1LowBits, int op1HighBits, int shift, int noteIndex, int octaveIndex, float noteIndexFloat, float octaveIndexFloat, int fbL, int fbR, int noteModeOp, int midiMode, int lastMidiNote, int midiNote, float stepTrigs, float stepTies, float stepSemis, float stepOcts, int env, int gk, int g0, int g1, int period, int pos, int phase, int phaseInc, int inPos, int outPos, int pitchedRate, int fbDL, int fbDR
{
    // PARA *1
    // .l0: PEEK %0 &doReset
    // EQUi %0 #FALSE @.f1
    // Write to &doReset
    noteModeOp = 0;
    midiMode = FALSE;
    lastMidiNote = -1;
    midiNote = -1;
    env = 0;
    gk = 0;
    g0 = 0;
    g1 = 0;
    pos = 0;
    inPos = 0;
    outPos = 0;
    pitchedRate = 0;
    phase = 0;
    phaseInc = 0;
    fbDL = 0;
    fbDR = 0;
    i = 0;
    if (condition) {
    // .l3: SETL $stepTrigs $i #FALSE
    // SETL $stepTies $i #FALSE
    // SETL $stepSemis $i #0
    // SETL $stepOcts $i #0
    // FORi $i #16 @.l3
    // .e2: POKE &updateBits #TRUE
    // .f1: PEEK $clock &clock
    // SHRi $step $clock #12
    // ADDi %0 $step #1
    // ANDi $nextStep %0 #15
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi %0 %0 #SWITCHES_REVERSE_MASK
    if (condition == 0) {
    // XORi $clock $clock #0xFFFF
    // SUBi %0 $step #1
    // ANDi $nextStep %0 #15
    // .f4: ANDi $subStep $clock #0xFFF
    // Read from &params:OPERATOR_1_PARAM_INDEX
    // Read from &updateBits
    // EQUi %0 #FALSE @.f5
    // MOVp %1 &.s_bitsup4aa4a1ce
    trace();
    // Write to &updateBits
    i = 0;
    if (condition) {
    // .l7: SETL $stepTrigs $i #FALSE
    // SETL $stepTies $i #FALSE
    // SETL $stepSemis $i #0
    // SETL $stepOcts $i #0
    // FORi $i #16 @.l7
    // .e6: POKE &displayLEDs:2 #0
    // Write to &displayLEDs:3
    // Read from &params:OPERATOR_2_PARAM_INDEX
    // SWCH $noteModeOp *5 @.s8
    // .s8#KEY_HIGH_MODE: NOOP
    // .s8#KEY_LOW_MODE: MOVi $midiMode #TRUE
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // Read from &params:OPERAND_1_LOW_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_2_LOW_PARAM_INDEX
    // IORi %1 %1 %0
    // SHLi %2 %2 #16
    // Read from &params:OPERAND_2_HIGH_PARAM_INDEX
    // IORi %1 %1 %2
    // SHLi %0 %0 #24
    // IORi $m %1 %0
    midiNote = 8;
    midiNote = 8;
    if (condition) {
    // .l11: GEQi $m #0 @.f12
    // NEQi $noteModeOp #KEY_HIGH_MODE @.e9
    // ADDi $midiNote $midiNote #24
    // GOTO @.e9
    // .f12: SHLi $m $m #1
    // FORi $midiNote #40 @.l11
    // .e10: MOVi $midiNote #-1
    // foundNote: GOTO @.e9
    // .s8#RANDOM_MODE: NOOP
    // .s8#ARPEG_MODE: MOVi $midiMode #FALSE
    lastMidiNote = -1;
    midiNote = -1;
    semisCount = 0;
    octsCount = 0;
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // SHLi %1 %1 #8
    // Read from &params:OPERAND_1_LOW_PARAM_INDEX
    // IORi $noteBits %1 %0
    i = 0;
    if (condition) {
    // .l15: SHLi %1 $noteBits $i
    // ANDi %1 %1 #0x8000
    // EQUi %1 #0 @.f16
    // SETL $semisList $semisCount $i
    // ADDi $semisCount $semisCount #1
    // .f16: FORi $i #12 @.l15
    // .e14: MOVi $i #0
    if (condition) {
    // .l18: SHLi %1 $noteBits $i
    // ANDi %1 %1 #8
    // EQUi %1 #0 @.f19
    // SETL $octsList $octsCount $i
    // ADDi $octsCount $octsCount #1
    // .f19: FORi $i #4 @.l18
    // .e17: PEEK $op1LowBits &params:OPERAND_2_LOW_PARAM_INDEX
    // Read from &params:OPERAND_2_HIGH_PARAM_INDEX
    if (condition) {
    if (condition) {
    // ANDi $xpose $op1LowBits #0xF
    // NEQi $noteModeOp #RANDOM_MODE @.f22
    // ANDi $shift $op1HighBits #0xF
    i = 0;
    if (condition) {
    // .l24: ADDi %1 $i $shift
    // ANDi $j %1 #0xF
    // ANDi %1 $op1HighBits #0xF0
    // SHRi %1 %1 #4
    // Read from &EUCLIDEAN
    // SHLi %1 %1 $i
    // ANDi %1 %1 #0x8000
    // EQUi %1 #0 @.f25
    // SETL $stepTrigs $j #TRUE
    // .f25: FORi $i #16 @.l24
    // .e23: MOVi $euclideanBits #0
    // ANDi %1 $op1LowBits #0xF0
    // ADDi %1 %1 #192837463
    seedRandom();
    // MOVf $noteIndexFloat #0.0
    // MOVf $octaveIndexFloat #0.0
    i = 0;
    if (condition) {
    // .l27: EQUi #ALSO_SHIFT_NOTES #0 @.f28
    // ADDi %0 $i $shift
    // ANDi $j %0 #0xF
    // GOTO @.e29
    // .f28: MOVi $j $i
    // .e29: GETL %0 $stepTrigs $j
    // EQUi %0 #FALSE @.f31
    if (condition) {
    if (condition) {
    // FLOf %0 $noteIndexFloat
    // SUBf %0 $noteIndexFloat %0
    // iTOf %1 $semisCount #1.0
    // MULf %0 %0 %1
    // fTOi %0 %0 #1.0
    // GETL %0 $semisList %0
    // SETL $stepSemis $j %0
    // FLOf %0 $octaveIndexFloat
    // SUBf %0 $octaveIndexFloat %0
    // iTOf %1 $octsCount #1.0
    // MULf %0 %0 %1
    // fTOi %0 %0 #1.0
    // GETL %0 $octsList %0
    // SETL $stepOcts $j %0
    randomFloat();
    // MULf %0 %0 #2.0
    // SUBf %0 %0 #1.0
    // ADDf $noteIndexFloat $noteIndexFloat %0
    randomFloat();
    // MULf %0 %0 #2.0
    // SUBf %0 %0 #1.0
    // ADDf $octaveIndexFloat $octaveIndexFloat %0
    // SHRi %0 #0x8000 $j
    // IORi $euclideanBits $euclideanBits %0
    // .f31: FORi $i #16 @.l27
    // .e26: ADDi %1 $op1HighBits #6734261
    seedRandom();
    l = 0;
    i = 0;
    if (condition) {
    // .l33: EQUi $i #16 @.t34
    // GETL %0 $stepTrigs $i
    // EQUi %0 #FALSE @.f35
    // .t34: CALL &randomFloat %0 *1
    // SUBi %1 $i $l
    // iTOf %1 %1 #1.0
    // MULf %0 %0 %1
    // ADDf %0 %0 #0.5
    // fTOi %0 %0 #1.0
    // ADDi $e $l %0
    j = l;
    if (condition) {
    // .l37: SETL $stepTies $j #TRUE
    // FORi $j $e @.l37
    // .e36: MOVi $l $i
    // .f35: FORi $i #17 @.l33
    // GOTO @.e38
    // .f22: MOVi $i #0
    if (condition) {
    // .l40: ANDi %0 $i #7
    // SHLi %0 $op1HighBits %0
    // ANDi %0 %0 #0x80
    if (condition == 0) {
    // SETL $stepTrigs $i #TRUE
    // .f41: FORi $i #16 @.l40
    // .e39: ANDi %0 $op1LowBits #0x80
    if (condition == 0) {
    // SUBi $noteIndex $semisCount #1
    // SUBi $octaveIndex $octsCount #1
    // GOTO @.e43
    // .f42: MOVi $noteIndex #0
    octaveIndex = 0;
    // .e43: MOVi $i #0
    if (condition) {
    // .l45: GETL %0 $stepTrigs $i
    // EQUi %0 #FALSE @.f47
    if (condition) {
    if (condition) {
    // GETL %0 $semisList $noteIndex
    // SETL $stepSemis $i %0
    // GETL %0 $octsList $octaveIndex
    // SETL $stepOcts $i %0
    // ANDi %0 $i #15
    // SHRi %0 %0 #2
    // SHRi %0 #0x80 %0
    // ANDi %0 $op1LowBits %0
    if (condition == 0) {
    // SUBi $noteIndex $noteIndex #1
    if (condition) {
    // SUBi $noteIndex $semisCount #1
    // SUBi $octaveIndex $octaveIndex #1
    if (condition) {
    // SUBi $octaveIndex $octsCount #1
    // GOTO @.e51
    // .f48: ADDi $noteIndex $noteIndex #1
    // LSSi $noteIndex $semisCount @.f47
    noteIndex = 0;
    // ADDi $octaveIndex $octaveIndex #1
    // LSSi $octaveIndex $octsCount @.f47
    octaveIndex = 0;
    // .e51: NOOP
    // .f47: FORi $i #16 @.l45
    // .e44: MOVi $i #0
    if (condition) {
    // .l55: ADDi %0 $i #1
    // ANDi %0 %0 #15
    // GETL %0 $stepTrigs %0
    // XORi %0 %0 #TRUE
    // SETL $stepTies $i %0
    // FORi $i #16 @.l55
    // .e38: NOOP
    // .s8: NOOP
    // .e9: NOOP
    // .f5: MOVi $trig #FALSE
    // NEQi $midiMode #FALSE @.f56
    // NEQi $subStep #0 @.f57
    // GETL %0 $stepTrigs $step
    // EQUi %0 #FALSE @.f58
    // GETL %0 $stepOcts $step
    // MULi %0 %0 #12
    // ADDi %0 $xpose %0
    // GETL %1 $stepSemis $step
    // ADDi $key %0 %1
    // GETL %0 $stepSemis $step
    // SHRi %0 #0x80 %0
    // Write to &displayLEDs:0
    // GETL %0 $stepSemis $step
    // GETL %1 $stepOcts $step
    // SHRi %0 #0x8000 %0
    // SHRi %1 #8 %1
    // IORi %0 %0 %1
    // Write to &displayLEDs:1
    trig = TRUE;
    // .f58: NEQi $noteModeOp #ARPEG_MODE @.f59
    // ANDi %0 $step #7
    // SHRi %0 #0x80 %0
    // Write to &displayLEDs:2
    // SHRi %0 $step #2
    // SHRi %0 #0x80 %0
    // Write to &displayLEDs:3
    // GOTO @.e60
    // .f59: SHRi %0 #0x8000 $step
    // XORi %0 %0 #-1
    // ANDi $i $euclideanBits %0
    // SHRi %0 $i #8
    // Write to &displayLEDs:2
    // ANDi %0 $i #0xFF
    // Write to &displayLEDs:3
    // .e60: NOOP
    // .f57: NEQi $subStep #0x200 @.f62
    // GETL %0 $stepTies $step
    // NEQi %0 #FALSE @.f62
    env = 0;
    gk = SLOW_RELEASE;
    // .f62: NEQi $subStep #0xE00 @.e65
    // GETL %0 $stepTrigs $nextStep
    // EQUi %0 #FALSE @.e65
    env = 0;
    gk = FAST_RELEASE;
    // GOTO @.e65
    // .f56: EQUi $midiNote $lastMidiNote @.f66
    // LSSi $midiNote #0 @.f67
    key = midiNote;
    // Write to &displayLEDs:0
    // Write to &displayLEDs:1
    trig = TRUE;
    // GOTO @.e68
    // .f67: MOVi $env #0
    gk = SLOW_RELEASE;
    // .e68: NOOP
    // .f66: MOVi $lastMidiNote $midiNote
    // .e65: EQUi $trig #FALSE @.f69
    // Read from &NOTE_RATES
    // Read from &params:CLOCK_FREQ_PARAM_INDEX
    // ! MULf <A> #65536.0 #C3_FREQUENCY
    // iTOf %0 %0 #1.0
    // DIVf %0 <A> %0
    // MULf $f %0 $rate
    // ADDf %0 $f #0.5
    // FLOf %0 %0
    // fTOi $phaseInc %0 #1.0
    // DIVf %0 #4294967296.0 $f
    // ADDf %0 %0 #0.5
    // FLOf %0 %0
    // fTOi $period %0 #1.0
    pos = 0;
    phase = 0;
    // SHLi $pos $clock #16
    env = 0x1000;
    gk = STANDARD_ATTACK;
    // SWCH $oscModeOp *5 @.s70
    // .s70#GRAIN_MODE: MOVi $inPos $clock
    phase = 0x10000;
    // EQUi #GRAIN_DRIFT #FALSE @.e71
    // SHRi %0 $phaseInc #4
    // SUBi $phaseInc $phaseInc %0
    // GOTO @.e71
    // .s70#SAMPLE_MODE: NOOP
    // ! EQUi #DEBUG #0 @.a73
    // GRTi #0 $key @.f74
    // LSSi $key #64 @.a73
    // .f74: MOVp %1 &.a_0keyke4aa4a1c2
    assertFail();
    // .a73: fTOi $pitchedRate $rate #131072.0
    if (condition) {
    // EQUi #PITCHED_REVERSED #FALSE @.f76
    // SUBi $pitchedRate #0 $pitchedRate
    // GOTO @.e71
    // .f76: ADDi $pos $pos #0x10000
    // .e77: GOTO @.e71
    // .s70#COMB_MODE: MOVi $gk #COMB_ATTACK
    // .s70: NOOP
    // .e71: NOOP
    // .f69: MOVi %1 $clock
    %2 = 1;
    // MOVp %3 &signal
    write();
    %1 = clock;
    %2 = 1;
    // MOVp %3 &signal
    read();
    // Read from &signal:0
    // Read from &signal:1
    // SUBi %0 $env $g0
    // MULi %0 %0 $gk
    // SHRi %0 %0 #16
    // ADDi $g0 $g0 %0
    // SUBi %0 $g0 $g1
    // MULi %0 %0 $gk
    // SHRi %0 %0 #16
    // ADDi $g1 $g1 %0
    // SWCH $oscModeOp *5 @.s78
    // .s78#NOP_MODE: MOVi $left $inL
    right = inR;
    // GOTO @.e79
    // .s78#SQUARE_MODE: MOVi $left #0x200
    if (condition) {
    left = -0x200;
    // .f80: MOVi $right $left
    // ADDi %0 $phase $phaseInc
    // ANDi $phase %0 #0xFFFF
    // GOTO @.e79
    // .s78#GRAIN_MODE: LSSi $phase #0x10000 @.f81
    // SUBi $pos $pos $period
    // SUBi $phase $phase #0x10000
    outPos = inPos;
    // SHRi $inPos $pos #16
    // .f81: MOVi %1 $inPos
    %2 = 1;
    // ADRL %3 $bSamples *0
    read();
    // ADDi $inPos $inPos #1
    %1 = outPos;
    %2 = 1;
    // ADRL %3 $aSamples *0
    read();
    // ADDi $outPos $outPos #1
    // SUBi %0 $bSamples:0 $aSamples:0
    // MULi %0 %0 $phase
    // SHRi %0 %0 #16
    // ADDi $left $aSamples:0 %0
    // SUBi %0 $bSamples:1 $aSamples:1
    // MULi %0 %0 $phase
    // SHRi %0 %0 #16
    // ADDi $right $aSamples:1 %0
    // ADDi $pos $pos #0x10000
    // ADDi $phase $phase $phaseInc
    // GOTO @.e79
    // .s78#SAMPLE_MODE: SHRi $i $pos #16
    %1 = i;
    %2 = 2;
    // ADRL %3 $aSamples *0
    read();
    // ANDi $x $pos #0xFFFF
    // ADDi $pos $pos $pitchedRate
    // SUBi %0 $aSamples:2 $aSamples:0
    // MULi %0 %0 $x
    // SHRi %0 %0 #16
    // ADDi $left $aSamples:0 %0
    // SUBi %0 $aSamples:3 $aSamples:1
    // MULi %0 %0 $x
    // SHRi %0 %0 #16
    // ADDi $right $aSamples:1 %0
    // EQUi #CROSSFADE_SAMPLES #FALSE @.e79
    // SUBi %1 $i #0x8000
    %2 = 2;
    // ADRL %3 $bSamples *0
    read();
    // SUBi %0 $bSamples:2 $bSamples:0
    // MULi %0 %0 $x
    // SHRi %0 %0 #16
    // ADDi $bL $bSamples:0 %0
    // SUBi %0 $bSamples:3 $bSamples:1
    // MULi %0 %0 $x
    // SHRi %0 %0 #16
    // ADDi $bR $bSamples:1 %0
    // SUBi %0 $clock $i
    // ANDi $x %0 #0xFFFF
    // LSSi $x #0x8000 @.f83
    // SUBi $x #0x10000 $x
    // .f83: SHRi $x $x #3
    // SUBi %0 #4096 $x
    // Read from &SQRT_TABLE
    // Read from &SQRT_TABLE
    // MULi %0 $bL $y
    // MULi %1 $left $x
    // ADDi %0 %0 %1
    // SHRi $left %0 #16
    // MULi %0 $bR $y
    // MULi %1 $right $x
    // ADDi %0 %0 %1
    // SHRi $right %0 #16
    // GOTO @.e79
    // .s78#COMB_MODE: SUBi %1 $clock #1
    // SHRi %2 $period #16
    // SUBi %1 %1 %2
    %2 = 2;
    // ADRL %3 $aSamples *0
    read();
    // ANDi $x $period #0xFFFF
    // SUBi %0 $aSamples:0 $aSamples:2
    // MULi %0 %0 $x
    // SHRi %0 %0 #16
    // ADDi $fbL $aSamples:2 %0
    // SUBi %0 $aSamples:1 $aSamples:3
    // MULi %0 %0 $x
    // SHRi %0 %0 #16
    // ADDi $fbR $aSamples:3 %0
    // SUBi %0 $fbL $fbDL
    // SHRi %0 %0 #8
    // ADDi $fbDL $fbDL %0
    // SUBi %0 $fbR $fbDR
    // SHRi %0 %0 #8
    // ADDi $fbDR $fbDR %0
    // SUBi $fbL $fbL $fbDL
    // SUBi $fbR $fbR $fbDR
    if (condition) {
    // ADDi $fbL $fbL $inL
    // ADDi $fbR $fbR $inR
    // ADDi $phase $phase $phaseInc
    // .f84: MOVi $left $fbL
    right = fbR;
    // MULi %0 $left $g1
    // SHRi $bSamples:0 %0 #12
    // MULi %0 $right $g1
    // SHRi $bSamples:1 %0 #12
    %1 = clock;
    %2 = 1;
    // ADRL %3 $bSamples *0
    write();
    // .s78: NOOP
    // .e79: EQUi #CROSSFADE_INPUT #FALSE @.f85
    // SUBi %0 $left $inL
    // MULi %0 %0 $g1
    // SHRi %0 %0 #12
    // ADDi $left $inL %0
    // SUBi %0 $right $inR
    // MULi %0 %0 $g1
    // SHRi %0 %0 #12
    // ADDi $right $inR %0
    // GOTO @.e86
    // .f85: MULi %0 $left $g1
    // SHRi $left %0 #12
    // MULi %0 $right $g1
    // SHRi $right %0 #12
    // .e86: POKE &signal:0 $left
    // Write to &signal:1
    yield();
    // continue loop
    // RETU
}
