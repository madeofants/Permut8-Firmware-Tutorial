/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 3
const int FALSE = 0
const int TRUE = 1
const float LOG2 = 0.69314718055994530942
const float LG2R = 1.44269504088896340736
const int HSR = 44100
const int HVC = 3
const int MSR = 4096
const int HWAV = 24
const int HVOL = 16
const int HCP = 8
const int HFP = 0
const int HTR = 1
const int HSW = 2
const int HSQ = 4
const int HNO = 8
const int HRS = 128
const int VMB = 4
const int VEB = 4
const int PFB = 8
const int PIB = 8
const int PFI = 6
const float C3F = 261.62558
const int HBS = 32
const int IMTR = 1
const int IMSW = 2
const int IMSQ = 4
const int IMDC = 8
const int IWAV = 28
const int IPTC = 27
const int IOCT = 24
const int IATK = 20
const int IDCY = 16
const int IMTY = 12
const int IMAM = 8
const int IMRT = 4
const int IVOL = 0
const int HINC = 8
const int HPCT = 15
const int HPST = 16
const int HTIE = 7
const int HPFB = 8
const int HPIB = 8
const int HVMB = 4
const int HVEB = 4
const int MSSC = 8
const int O1OFF = 0
const int O1SNG = 1
const int O1MSK = 2
const int O1PTN = 3
const int O1RND = 4
const int O2OFF = 0
const int O2SMU = 1
const int O2IMU = 2
const int O2XIH = 3
const int O2XIL = 4
const int VSCI = 0
const int VSID = 1
const int VSCP = 2
const int VSSU = 3
const int VSEN = 4
const int VSMP = 5
const int VSSZ = 6
const int SST = 0
const int SSV = 1

global int clock = 0
global int hostPosition = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int clockFreqLimit = 176400
global array config[1024]
global array signal[2]
global int xsrsx = 495493531
global int xsrsy = 145834296
global array ptbl[PTS]
global array hmra[16]
global array hatr[16]
global array hdcr[16]
global int rst = TRUE
global int sln = 1
global int sbp = 0
global array sdat[SDS]
global array pdat[PDS]
global array inst[HINC]
global array rndt[256]
global array b64dt[128]

function err()
{
    // PARA *1
    // MOVp %1 $s
    trace();
    abort();
    // RETU
}

function strl()
locals pointer a
{
    // MOVp $a $s
    // .l0: PEEK %0 $a
    if (condition == 0) {
    // ADDp $a $a #1
    // continue loop
    // .e1: DIFp $l $a $s
    // RETU
}

function xsr()
locals int x, int t
{
    // Read from &xsrsx
    // Read from &xsrsy
    // SHLi %0 $x #10
    // XORi $t $x %0
    x = y;
    // SHRu %0 $y #13
    // XORi %0 $y %0
    // XORi %0 %0 $t
    // SHRu %1 $t #10
    // XORi $y %0 %1
    // Write to &xsrsx
    // Write to &xsrsy
    // RETU
}

function log()
locals float a, float b, float m, float n, float t
{
    // LEQf $x #0.0 @.t0
    // LSSf $x #1.0e38 @.f1
    // .t0: MOVp %1 &.s_Domainfebb0028
    err();
    // GOTO @.e2
    // .f1: MOVf $b #0.0
    // MOVf $m $x
    // .l3: GEQf $m #0.5 @.e4
    // MULf $m $m #2.0
    // SUBf $b $b #LOG2
    // continue loop
    // .e4: NOOP
    // .l5: LEQf $m #1.5 @.e6
    // MULf $m $m #0.5
    // ADDf $b $b #LOG2
    // continue loop
    // .e6: SUBf $m #1.0 $m
    // MOVf $a #-1.0
    // MOVf $n #1.0
    // MOVf $y #0.0
    // .l7: MOVf $t $y
    // MULf $a $a $m
    // DIVf %0 $a $n
    // ADDf $y $y %0
    // ADDf $n $n #1.0
    // NEQf $y $t @.l7
    // ADDf $y $y $b
    // .e2: RETU
}

function log2()
{
    // MOVf %1 $x
    log();
    // MULf $y %0 #LG2R
    // RETU
}

function rund()
{
    // ADDf %0 $x #0.5
    // FLOf $y %0
    // RETU
}

function exp()
locals float a, float n, float m, float t
{
    // ABSf $m $x
    // MOVf $a #1.0
    // MOVf $n #1.0
    // MOVf $y #1.0
    // .l0: MOVf $t $y
    // MULf %0 $a $m
    // DIVf $a %0 $n
    // ADDf $y $y $a
    // ADDf $n $n #1.0
    // NEQf $y $t @.l0
    // GEQf $x #0.0 @.f1
    // DIVf $y #1.0 $y
    // .f1: RETU
}

function pow()
locals float a
{
    // MOVf $z #0.0
    // MOVf $a $x
    // GEQf $a #0.0 @.f1
    // FLOf %0 $y
    // NEQf $y %0 @.f1
    // SUBf $a #0.0 $a
    // .f1: LEQf $a #0.0 @.f2
    // MOVf %2 $a
    log();
    // MULf %1 %1 $y
    exp();
    // MOVf $z %0
    // GOTO @.e3
    // .f2: LSSf $a #0.0 @.t4
    // GRTf $y #0.0 @.f5
    // .t4: MOVp %1 &.s_Domainfebb0028
    err();
    // .f5: NOOP
    // .e3: EQUf $a $x @.f7
    // MULf %0 $y #0.5
    // MULf %1 $y #0.5
    // FLOf %0 %0
    // EQUf %1 %0 @.f7
    // SUBf $z #0.0 $z
    // .f7: RETU
    // HSR: ! DEFi #44100
    // HVC: ! DEFi #3
    // MSR: ! DEFi #4096
    // HWAV: ! DEFi #24
    // HVOL: ! DEFi #16
    // HCP: ! DEFi #8
    // HFP: ! DEFi #0
    // HTR: ! DEFi #1
    // HSW: ! DEFi #2
    // HSQ: ! DEFi #4
    // HNO: ! DEFi #8
    // HRS: ! DEFi #128
    // VMB: ! DEFi #4
    // VEB: ! DEFi #4
    // PFB: ! DEFi #8
    // PIB: ! DEFi #8
    // PFI: ! DEFi #6
    // C3F: ! DEFf #261.62558
    // HBS: ! DEFi #32
    // IMTR: ! DEFi #1
    // IMSW: ! DEFi #2
    // IMSQ: ! DEFi #4
    // IMDC: ! DEFi #8
    // IWAV: ! DEFi #28
    // IPTC: ! DEFi #27
    // IOCT: ! DEFi #24
    // IATK: ! DEFi #20
    // IDCY: ! DEFi #16
    // IMTY: ! DEFi #12
    // ! SHLi <A> #1 #11
    // INMM: ! DEFi <A>
    // IMAM: ! DEFi #8
    // IMRT: ! DEFi #4
    // IVOL: ! DEFi #0
    // HINC: ! DEFi #8
    // HPCT: ! DEFi #15
    // HPST: ! DEFi #16
    // HTIE: ! DEFi #7
    // HMAM: CNST *8
    // DATA #0x0040 #0x0080 #0x0180 #0x0200 #0x0380 #0x0600
    // DATA #0x0C00 #0x1200
    // HPFB: ! DEFi #8
    // HPIB: ! DEFi #8
    // HVMB: ! DEFi #4
    // HVEB: ! DEFi #4
    // MSSC: ! DEFi #8
    // O1OFF: ! DEFi #0
    // O1SNG: ! DEFi #1
    // O1MSK: ! DEFi #2
    // O1PTN: ! DEFi #3
    // O1RND: ! DEFi #4
    // O2OFF: ! DEFi #0
    // O2SMU: ! DEFi #1
    // O2IMU: ! DEFi #2
    // O2XIH: ! DEFi #3
    // O2XIL: ! DEFi #4
    // VSCI: ! DEFi #0
    // VSID: ! DEFi #1
    // VSCP: ! DEFi #2
    // VSSU: ! DEFi #3
    // VSEN: ! DEFi #4
    // VSMP: ! DEFi #5
    // VSSZ: ! DEFi #6
    // SST: ! DEFi #0
    // SSV: ! DEFi #1
    // ! ADDi <A> #SSV #HVC
    // SSS: ! DEFi <A>
    // ! SHLi <A> #12 #PFI
    // PTS: ! DEFi <A>
    // ! MULi <A> #SSS #MSSC
    // SDS: ! DEFi <A>
    // ! MULi <A> #HPCT #HPST
    // PDS: ! DEFi <A>
    // ptbl: GLOB *PTS
    // hmra: GLOB *16
    // hatr: GLOB *16
    // hdcr: GLOB *16
    // GLOB *1
    // rst: DATi #TRUE
    // GLOB *1
    // sln: DATi #1
    // GLOB *1
    // sbp: DATi #0
    // sdat: GLOB *SDS
    // pdat: GLOB *PDS
    // inst: GLOB *HINC
    // rndt: GLOB *256
    // CNST *1
    // B64CH: DATp &.s_ABCDEFfebb0029
    // b64dt: GLOB *128
}

function ib64()
locals int i
{
    // PARA *1
    i = 0;
    if (condition) {
    // .l1: PEEK %1 &B64CH
    // Read from %1
    // Write to &b64dt
    // FORi $i #64 @.l1
    // .e0: PEEK %1 &b64dt:'+'
    // Write to &b64dt:'-'
    // Read from &b64dt:'/'
    // Write to &b64dt:'_'
    // RETU
}

function db64()
locals int ii, int oi, int ich, int dch, int i, int bts, int uos
{
    // ADDi %1 $isz #3
    // DIVi %1 %1 #4
    // MULi $osz %1 #3
    // SUBi %1 $isz #1
    // Read from $inp
    // EQUi $ich #'=' @.t0
    // NEQi $ich #',' @.f1
    // .t0: SUBi $osz $osz #1
    // SUBi %1 $isz #2
    // Read from $inp
    // EQUi $ich #'=' @.t2
    // NEQi $ich #',' @.f1
    // .t2: SUBi $osz $osz #1
    // .f1: MOVi $uos $oms
    if (condition) {
    uos = osz;
    // .f4: MOVi $ii #0
    oi = 0;
    // .l5: GEQi $oi $uos @.e6
    bts = 0;
    i = 0;
    if (condition) {
    // .l8: MOVi $dch #0
    if (condition) {
    // Read from $inp
    // LSSi $ich #0 @.f10
    if (condition) {
    // Read from &b64dt
    // .f10: SHLi %1 $bts #6
    // IORi $bts %1 $dch
    // ADDi $ii $ii #1
    // FORi $i #4 @.l8
    // .e7: MOVi $i #0
    if (condition) {
    // .l12: GEQi $oi $oms @.f13
    // SHRu %1 $bts #16
    // ANDi %1 %1 #0xFF
    // Write to $out
    // ADDi $oi $oi #1
    // .f13: SHLi $bts $bts #8
    // FORi $i #3 @.l12
    // continue loop
    // .e6: RETU
}

function unss()
locals int ino, int ver, int inc, int ptc, int i, int b, int ins, int si, pointer pp, int stp, int sst, int xps, pointer sp, int sln, int sbp
{
    // PARA *1
    // Read from $idat
    // EQUi $ver #1 @.f1
    // EQUi $ver #2 @.f1
    // EQUi $ver #3 @.f1
    // MOVp %1 &.s_Invalifebb002a
    trace();
    // GOTO @.e2
    // .f1: MOVi $inc #8
    ptc = HPCT;
    // NEQi $ver #1 @.f3
    // Read from $idat
    ino = 2;
    // GOTO @.e4
    // .f3: NEQi $ver #2 @.f5
    // Read from $idat
    ino = 3;
    // GOTO @.e6
    // .f5: LSSi $ver #3 @.f7
    // Read from $idat
    // SHLi %0 %0 #8
    // Read from $idat
    // IORi %0 %0 %1
    // SHRi $sbp %0 #4
    // Read from $idat
    // SHRu %0 $b #4
    // ANDi %0 %0 #7
    // ADDi $inc %0 #1
    // ANDi %0 $b #0x0F
    // ADDi $ptc %0 #1
    ino = 4;
    // .f7: NOOP
    // .e6: NOOP
    // .e4: LEQi $sbp #999 @.f8
    sbp = 999;
    // GOTO @.e9
    // .f8: GEQi $sbp #1 @.f10
    sbp = 1;
    // .f10: NOOP
    // .e9: POKE &sbp $sbp
    i = 0;
    if (condition) {
    // .l12: PEEK %0 $idat $ino
    // ADDi %1 $ino #1
    // Read from $idat
    // SHLi %0 %0 #24
    // SHLi %1 %1 #16
    // ADDi %2 $ino #2
    // Read from $idat
    // IORi %0 %0 %1
    // SHLi %2 %2 #8
    // ADDi %1 $ino #3
    // IORi %0 %0 %2
    // Read from $idat
    // IORi %0 %0 %1
    // Write to &inst
    // ADDi $ino $ino #4
    // FORi $i $inc @.l12
    // .e11: NEQi $ver #1 @.f13
    i = 0;
    if (condition) {
    // .l15: PEEK $ins &inst $i
    // XORi $ins $ins #INMM
    // ANDi %0 $ins #INMM
    if (condition == 0) {
    // ! SHLi <A> #0x7 #IMAM
    ins = <A>;
    // .f16: POKE &inst $i $ins
    // FORi $i $inc @.l15
    // .f13: MOVi $i $inc
    if (condition) {
    // .l18: POKE &inst $i #0
    // FORi $i #HINC @.l18
    // .e17: MOVi $i #0
    if (condition) {
    // .l20: POKE &pdat $i #0
    // FORi $i #PDS @.l20
    // .e19: MOVp $pp &pdat
    i = 0;
    if (condition) {
    // .l22: GEQi $i $ptc @.f23
    si = 0;
    if (condition) {
    // .l25: PEEK $stp $idat $ino
    // ADDi $ino $ino #1
    // NEQi $stp #0x80 @.f26
    // GOTO @endOfPattern
    // .f26: POKE $pp $si $stp
    // FORi $si #HPST @.l25
    // .e24: NOOP
    // endOfPattern: ADDp $pp $pp #HPST
    // .f23: FORi $i #HPCT @.l22
    // .e21: MOVi $i #0
    if (condition) {
    // .l28: POKE &sdat $i #0
    // FORi $i #SDS @.l28
    // .e27: MOVi $sln #0
    // MOVp $sp &sdat:0
    sst = 0;
    if (condition) {
    // .l30: LSSi $ino $isz @.f31
    // GOTO @endOfSong
    // .f31: PEEK $b $idat $ino
    // ADDi $ino $ino #1
    // NEQi $b #0x80 @.f32
    // GOTO @endOfSong
    // .f32: SHRi $xps $b #4
    // LSSi $xps #8 @.f33
    // SUBi $xps $xps #16
    // .f33: POKE $sp #SST $xps
    // ! ADDi <A> #SSV #0
    // ANDi %0 $b #0xF
    // Write to $sp
    // Read from $idat
    // ADDi $ino $ino #1
    // ! ADDi <A> #SSV #1
    // SHRi %0 $b #4
    // Write to $sp
    // ! ADDi <A> #SSV #2
    // ANDi %0 $b #0xF
    // Write to $sp
    // ADDp $sp $sp #4
    // ADDi $sln $sln #1
    // FORi $sst #MSSC @.l30
    // .e29: NOOP
    // endOfSong: POKE &sln $sln
    // .e2: RETU
}

function logScale()
{
    // DIVf %1 $oto $ofr
    // SUBf %2 $x $ifr
    // SUBf %3 $ito $ifr
    // DIVf %2 %2 %3
    pow();
    // MULf $y $ofr %0
    // RETU
}

function reset()
{
    // PARA *1
    // MOVp %1 &.s_resetfebb002b
    trace();
    // Write to &rst
    // RETU
}

function init()
locals int i, float x, float m, float e, float tsc, pointer s, float buf
{
    // PARA *1
    // MOVp %1 &.s_initfebb002c
    trace();
    ib64();
    i = 0;
    if (condition) {
    // .l1: NOOP
    // ! ADDi <A> #8 #PIB
    // ! ADDi <A> <A> #PFB
    // ! SHLi <A> #1 <A>
    // ! iTOf <A> <A> #1.0
    // MOVf $m <A>
    // MOVf %1 #2.0
    // iTOf %2 $i #1.0
    // SUBf %2 %2 #1.0
    // ! iTOf <A> #PTS #1.0
    // DIVf %2 %2 <A>
    pow();
    // MOVf $e %0
    // MULf %1 $m $e
    rund();
    // fTOi %0 %0 #1.0
    // Write to &ptbl
    // FORi $i #PTS @.l1
    // .e0: NOOP
    // ! iTOf <A> #HBS #22050.0
    // ! iTOf <B> #HSR #32.0
    // ! DIVf <A> <A> <B>
    // MOVf $tsc <A>
    // Write to &hmra:0
    i = 1;
    if (condition) {
    // .l3: iTOf $x $i #1.0
    // MOVf %2 $x
    // MOVf %3 #1.0
    // MOVf %4 #15.0
    // MOVf %5 #16.0
    // MOVf %6 #16384.0
    logScale();
    // MULf %1 $tsc %1
    rund();
    // fTOi %0 %0 #1.0
    // Write to &hmra
    // FORi $i #16 @.l3
    // .e2: MOVi $i #0
    if (condition) {
    // .l5: iTOf $x $i #1.0
    // MOVf %2 $x
    // MOVf %3 #0.0
    // MOVf %4 #15.0
    // MOVf %5 #600.0
    // MOVf %6 #8.0
    logScale();
    // MULf %1 $tsc %1
    rund();
    // fTOi %0 %0 #1.0
    // Write to &hatr
    // MOVf %2 $x
    // MOVf %3 #0.0
    // MOVf %4 #15.0
    // MOVf %5 #2000.0
    // MOVf %6 #8.0
    logScale();
    // MULf %1 $tsc %1
    rund();
    // fTOi %0 %0 #1.0
    // Write to &hdcr
    // FORi $i #16 @.l5
    // .e4: POKE &hatr:0 #0xFFFF
    i = 0;
    if (condition) {
    // .l7: CALL &xsr %0 *1
    // FORi $i #32 @.l7
    // .e6: MOVi $i #0
    if (condition) {
    // .l9: CALL &xsr %0 *1
    // Write to &rndt
    // FORi $i #256 @.l9
    // .e8: MOVi $i #0
    // .l10: PEEK %0 &rndt $i
    // ANDi %0 %0 #0xF0F0F0F0
    // Write to &rndt
    // ADDi $i $i #16
    // LSSi $i #256 @.l10
    // MOVp $s &config
    // .l11: PEEK %0 $s
    if (condition == 0) {
    // Read from $s
    // EQUi %0 #'=' @.e13
    // ADDp $s $s #1
    // continue loop
    // .e13: PEEK %0 $s
    // NEQi %0 #0 @.f14
    // MOVp $s &config
    // GOTO @.e15
    // .f14: ADDp $s $s #1
    // .e15: MOVp %2 $s
    strl();
    // MOVp %2 $s
    %3 = 1024;
    // ADRL %4 $buf *0
    db64();
    i = %0;
    %1 = i;
    // ADRL %2 $buf *0
    unss();
    // RETU
}

function process()
locals int vi, int reg, int wav, int vol, int sem, int fin, int phs, int rnd, int ptc, int oct, int i, int ort, int vsh, int vmu, int p, int s, int mix, int tun, int bi, pointer vp, int env, int ins, int mrt, int mtp, int mph, int mva, int x, int y, int mod, int mpt, int atr, int dcr, int cpt, int sus, int xps, int oxp, pointer sp, int pti, int note, int sdt, int nin, int spo, int nps, int pst, int tsc, int mst, int swi, int o1m, int o1b, int o2m, int o2b, int o2l, int sr, int dly, int ups, int chp, int rsd, int clk, float rma, float vre, float vph, float vrn, float vst, int lid
{
    // PARA *1
    // ! MULi <A> #HVC #VSSZ
    // .l0: PEEK $sr &params:CLOCK_FREQ_PARAM_INDEX
    if (condition) {
    sr = MSR;
    // .f1: NOOP
    // ! SHLi <A> #12 #PFI
    // ! SHLi <B> #1 #15
    // ! iTOf <B> <B> #C3F
    // iTOf %2 $sr #1.0
    // DIVf %2 <B> %2
    log2();
    // ! iTOf <A> <A> #1.0
    // MULf %1 <A> %1
    rund();
    // fTOi $tun %0 #1.0
    // ! SHLi <A> #HSR #9
    // DIVi $tsc <A> $sr
    // ! EQUi #DEBUG #0 @.a2
    // LSSi $tsc #0 @.f3
    // LSSi $tsc #32768 @.a2
    // .f3: MOVp %1 &.a_tsc0tsfebb001f
    assertFail();
    // .a2: PEEK $swi &params:SWITCHES_PARAM_INDEX
    // Read from &params:OPERATOR_1_PARAM_INDEX
    // ANDi %0 $swi #SWITCHES_SYNC_MASK
    if (condition == 0) {
    // Read from &hostPosition
    if (condition) {
    o1m = O1OFF;
    // .f5: PEEK %0 &params:OPERAND_1_HIGH_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_1_LOW_PARAM_INDEX
    // IORi $o1b %0 %1
    // Read from &params:OPERATOR_2_PARAM_INDEX
    // Read from &params:OPERAND_2_HIGH_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_2_LOW_PARAM_INDEX
    // IORi $o2b %0 %1
    // Read from &rst
    // EQUi %0 #FALSE @.f6
    // Write to &rst
    pst = -1;
    spo = 0;
    i = 0;
    // ! MULi <A> #HVC #VSSZ
    if (condition) {
    // .l8: SETL $vst $i #0
    // FORi $i <A> @.l8
    // .e7: MOVi $i #0
    if (condition) {
    // .l10: MULi %0 $i #VSSZ
    // ADDi %0 %0 #VSCI
    // SETL $vst %0 #-1
    // SETL $vph $i #0
    // SETL $vrn $i #0
    // FORi $i #HVC @.l10
    // .e9: MOVi $lid #0
    mst = TRUE;
    // .f6: MOVi $vi #0
    if (condition) {
    // .l12: SETL $rma $vi #0
    // FORi $vi #HVC @.l12
    // .e11: PEEK $clk &clock
    // SHRi $nps $clk #12
    // SUBi %0 $clk #HBS
    // SHRi %0 %0 #12
    // EQUi $nps %0 @.f13
    // ANDi %0 $swi #SWITCHES_SYNC_MASK
    if (condition == 0) {
    // Read from &hostPosition
    // ! DIVi <A> #HOST_POSITION_PPQ #8
    // ADDi %0 %0 <A>
    // ! MULi <A> #HOST_POSITION_PPQ #4
    // DIVi %0 %0 <A>
    // Read from &sln
    // MODi $spo %0 %1
    // GOTO @.e15
    // .f14: NEQi $pst #15 @.f16
    pst = 0;
    // ADDi $spo $spo #1
    // Read from &sln
    // LSSi $spo %0 @.f16
    spo = 0;
    // .f16: NOOP
    // .e15: MOVi $pst $nps
    mst = FALSE;
    // NEQi $o2m #O2SMU @.f19
    // SHLi %0 $o2b $pst
    // ANDi %0 %0 #0x8000
    if (condition == 0) {
    mst = TRUE;
    // .f19: MULi %0 $spo #SSS
    // ADDp $sp &sdat %0
    // SWCH $o1m *OPERATOR_1_COUNT @.s20
    // .s20#O1OFF: NOOP
    // .s20#O1SNG: SHLi %0 $o1b #28
    // SHRi $oxp %0 #28
    // Read from $sp
    // GOTO @.e21
    // .s20#O1PTN: NOOP
    // .s20#O1RND: MOVi $oxp #0
    // SHLi %0 $o1b #28
    // SHRi $xps %0 #28
    // GOTO @.e21
    // .s20#O1MSK: MOVi $oxp #0
    // ANDi %0 $o1b #15
    // Read from $sp
    // XORi %0 %0 #-1
    // ANDi $xps %1 %0
    // SHLi %1 $xps #28
    // SHRi $xps %1 #28
    // .s20: NOOP
    // .e21: MOVi $vi #0
    if (condition) {
    // .l23: SHRu %1 $o1b #12
    // ANDi $chp %1 #15
    // SHLi $o1b $o1b #4
    ups = pst;
    // SWCH $o1m *OPERATOR_1_COUNT @.s24
    // .s24#O1OFF: MOVi $pti #0
    // GOTO @.e25
    // .s24#O1SNG: ADDi %1 #SSV $vi
    // Read from $sp
    // SUBi %1 #16 $chp
    // MODi $ups $ups %1
    // GOTO @.e25
    // .s24#O1PTN: MOVi $pti $chp
    // GOTO @.e25
    // .s24#O1MSK: ADDi %1 #SSV $vi
    // Read from $sp
    // XORi %1 $chp #-1
    // ANDi $ups $ups %1
    // GOTO @.e25
    // .s24#O1RND: NEQi $chp #0 @.f26
    pti = 0;
    // GOTO @.e27
    // .f26: MULi %1 $chp #16
    // ADDi %1 %1 $pst
    // Read from &rndt
    // MULi %0 #8 $vi
    // SHRu %1 %1 %0
    // ANDi $rsd %1 #0x3F
    // SUBi %1 $chp #1
    // SHRu %0 $rsd #4
    // ADDi %1 %1 %0
    // Read from &sln
    // MODi %1 %1 %0
    // MULi %1 %1 #SSS
    // ADDp $sp &sdat %1
    // ADDi %1 #SSV $vi
    // Read from $sp
    // ANDi $ups $rsd #15
    // .e27: NOOP
    // .s24: NOOP
    // .e25: MULi %1 $vi #VSSZ
    // ADRL %0 $vst *0
    // ADDp $vp %0 %1
    // SUBi $pti $pti #1
    sus = FALSE;
    // LSSi $pti #0 @.f29
    // NEQi $mst #FALSE @.f29
    // MULi %0 $pti #HPST
    // ADDi %0 %0 $ups
    // Read from &pdat
    // ANDi %0 $sdt #0x0F
    // SUBi $note %0 #1
    // LSSi $note #0 @.f29
    // SHRi %0 $sdt #4
    // ANDi $nin %0 #7
    // NEQi $o2m #O2IMU @.t31
    // SHLi %0 $o2b $nin
    // ANDi %0 %0 #0x8000
    // NEQi %0 #0 @.f29
    // .t31: PEEK $env $vp #VSEN
    // Read from $vp
    // Read from &inst
    // NEQi $o2m #O2XIL @.f33
    // XORi $ins $ins $o2b
    // GOTO @.e34
    // .f33: NEQi $o2m #O2XIH @.f35
    // SHLi %0 $o2b #16
    // XORi $ins $ins %0
    // .f35: NOOP
    // .e34: POKE $vp #VSID $ins
    // Read from $vp
    // EQUi %0 $nin @.f36
    lid = ins;
    // Write to $vp
    env = 0;
    sus = FALSE;
    // SETL $rma $vi #HRS
    // GOTO @.e37
    // .f36: NEQi $env #0 @.f38
    // SETL $rma $vi #HRS
    // .f38: NOOP
    // .e37: NEQi $sus #FALSE @.f39
    // Write to $vp
    // SHRu %0 $ins #IATK
    // ANDi %0 %0 #0x0F
    // NEQi %0 #0 @.f40
    // SETL $rma $vi #HRS
    // .f40: IORi $env $env #0x10000
    // .f39: SHRi %0 $sdt #HTIE
    // ANDi $sus %0 #1
    // SHRi %0 $ins #IPTC
    // ANDi %0 %0 #1
    // MULi %0 $xps %0
    // ADDi $cpt %0 $oxp
    // ADDi %0 $cpt $note
    // SUBi %0 %0 #2
    // SHLi $cpt %0 #8
    // Write to $vp
    // Write to $vp
    // .f29: POKE $vp #VSSU $sus
    // FORi $vi #HVC @.l23
    // .f13: MOVi $vi #0
    if (condition) {
    // .l42: MULi %0 $vi #VSSZ
    // ADRL %1 $vst *0
    // ADDp $vp %1 %0
    // Read from $vp
    // ! EQUi #DEBUG #0 @.a43
    // GRTi #0 $env @.f44
    if (condition) {
    // .f44: MOVp %1 &.a_0envenfebb0020
    assertFail();
    // .a43: LEQi $env #0 @.f45
    // Read from $vp
    // SHRu %0 $ins #IMRT
    // ANDi %0 %0 #0x0F
    // Read from &hmra
    // MULi %0 $tsc %0
    // SHRi $mrt %0 #9
    // SHRu %0 $ins #IMTY
    // ANDi $mtp %0 #0x0F
    // Read from $vp
    // ADDi $mph %0 $mrt
    // Write to $vp
    // ! SHLi <A> #1 #HPIB
    // SHRi %0 $mph #HPFB
    // ! SUBi <A> <A> #1
    // ANDi $x %0 <A>
    mva = 0;
    // ANDi %0 $mtp #IMTR
    if (condition == 0) {
    // SUBi $y #64 $x
    // SHLi %0 $y #24
    // SHLi %1 $y #1
    // SHRi %0 %0 #31
    // XORi $y %1 %0
    // ANDi %1 $y #0xFF
    // SUBi %1 %1 #0x80
    // ADDi $mva $mva %1
    // .f46: ANDi %1 $mtp #IMSW
    // EQUi %1 #0 @.f47
    // ANDi %1 $x #0xFF
    // SUBi %1 %1 #0x80
    // ADDi $mva $mva %1
    // .f47: ANDi %1 $mtp #IMSQ
    // EQUi %1 #0 @.f48
    // XORi %1 $x #0x80
    // ANDi %1 %1 #0x80
    // SHLi %1 %1 #1
    // ADDi $mva $mva %1
    // .f48: ANDi %1 $mtp #IMDC
    // EQUi %1 #0 @.f49
    // ! ADDi <A> #HPFB #1
    // ! SHLi <A> #0x100 <A>
    // SUBi $y <A> $mph
    if (condition) {
    y = 0;
    // .f50: SHRu %1 $y #HPFB
    // ADDi $mva $mva %1
    // .f49: SHRu %1 $ins #IMAM
    // ANDi %1 %1 #7
    // Read from &HMAM
    // MULi %1 $mva %1
    // SHRi $mod %1 #7
    // Read from $vp
    // SHRu %1 $ins #IOCT
    // ANDi %1 %1 #7
    // ADDi %1 %1 #5
    // ! SHLi <A> #12 #8
    // MULi %1 %1 <A>
    // ADDi $mpt $cpt %1
    // ANDi %1 $ins #INMM
    // NEQi %1 #0 @.f51
    // ADDi $mpt $mpt $mod
    // GOTO @.e52
    // .f51: SUBi $mpt $mpt $mod
    // .e52: GEQi $mpt #0 @.f53
    mpt = 0;
    // GOTO @.e54
    // .f53: LEQi $mpt #0xFFFF @.f55
    mpt = 0xFFFF;
    // .f55: NOOP
    // .e54: LSSi $env #0x10000 @.f56
    // SHRu %1 $ins #IATK
    // ANDi %1 %1 #0x0F
    // Read from &hatr
    // MULi %1 $tsc %1
    // SHRi $atr %1 #9
    // ! EQUi #DEBUG #0 @.a57
    if (condition) {
    // MOVp %1 &.a_atr0febb0021
    assertFail();
    // .a57: NOOP
    // ! SHLi <A> #1 #HVEB
    // ANDi %0 $env #0xFFFF
    // ! ADDi <B> #9 #HVMB
    // ! SUBi <A> <A> #1
    // SHRu %0 %0 <B>
    // SUBi %0 <A> %0
    // SUBi $y %0 #8
    if (condition) {
    y = 0;
    // .f58: SHLi %0 $atr $y
    // ADDi $env $env %0
    // LSSi $env #0x20000 @.e61
    env = 0xFFFF;
    // Read from $vp
    // EQUi %0 #FALSE @.e61
    env = 0x1FFFF;
    // GOTO @.e61
    // .f56: SHRu %0 $ins #IDCY
    // ANDi %0 %0 #0x0F
    // Read from &hdcr
    // MULi %0 $tsc %0
    // SHRi $dcr %0 #9
    // SUBi $env $env $dcr
    if (condition) {
    env = 0;
    // .f62: NOOP
    // .e61: POKE $vp #VSEN $env
    // SHRu %0 $ins #IVOL
    // ANDi %0 %0 #0x0F
    // ANDi %1 $env #0xFFFF
    // SHLi %0 %0 #3
    // SHRi %1 %1 #9
    // ADDi $vol %0 %1
    if (condition) {
    vol = 0;
    // GOTO @.e64
    // .f63: LEQi $vol #255 @.f65
    vol = 255;
    // .f65: NOOP
    // .e64: SHRu %0 $ins #IWAV
    // ANDi %0 %0 #0x0F
    // GETL %1 $rma $vi
    // IORi %0 %0 %1
    // SHLi %0 %0 #HWAV
    // SHLi %1 $vol #HVOL
    // IORi %0 %0 %1
    // SHLi %1 $mpt #HFP
    // IORi %0 %0 %1
    // SETL $vre $vi %0
    // GOTO @.e66
    // .f45: SETL $vre $vi #0
    // .e66: FORi $vi #HVC @.l42
    // .e41: NOOP
    // ! MULi <A> #0 #VSSZ
    // ! ADDi <A> <A> #VSEN
    // ANDi %0 $vst:<A> #0xFFFF
    // ADDi %0 %0 #8192
    // SHRi %0 %0 #14
    // SHRi %0 #0xF00 %0
    // ! MULi <A> #1 #VSSZ
    // ! ADDi <A> <A> #VSEN
    // ANDi %1 $vst:<A> #0xFFFF
    // ADDi %1 %1 #8192
    // SHRi %1 %1 #14
    // SHRi %1 #0x0F0 %1
    // ANDi %0 %0 #0xF0
    // ANDi %1 %1 #0x0F
    // IORi %0 %0 %1
    // Write to &displayLEDs:0
    // ! MULi <A> #2 #VSSZ
    // ! ADDi <A> <A> #VSEN
    // ANDi %0 $vst:<A> #0xFFFF
    // ADDi %0 %0 #8192
    // SHRi %0 %0 #14
    // SHRi %0 #0xF00 %0
    // ANDi %0 %0 #0xF0
    // ANDi %1 $xps #15
    // IORi %0 %0 %1
    // Write to &displayLEDs:1
    // SWCH $o2m *OPERATOR_2_COUNT @.s67
    // .s67#O2SMU: SHRi $o2l #0x8000 $pst
    dly = 0;
    // GOTO @.e68
    // .s67#O2IMU: MOVi $o2l #0
    i = 0;
    if (condition) {
    // .l70: MULi %0 $i #VSSZ
    // ADDi %0 %0 #VSEN
    // GETL %0 $vst %0
    if (condition) {
    // MULi %0 $i #VSSZ
    // ADDi %0 %0 #VSCI
    // GETL %0 $vst %0
    // SHRi %0 #0x8000 %0
    // IORi $o2l $o2l %0
    // .f71: FORi $i #HVC @.l70
    // .e69: PEEK %0 &params:OPERAND_2_LOW_PARAM_INDEX
    // SHLi $dly %0 #8
    // GOTO @.e68
    // .s67#O2XIH: SHRu $o2l $lid #16
    dly = 0x3000;
    // GOTO @.e68
    // .s67#O2XIL: MOVi $o2l $lid
    dly = 0x3000;
    // GOTO @.e68
    // .s67#O2OFF: MOVi $o2l #0
    dly = 0x3000;
    // .s67: NOOP
    // .e68: SHRu %0 $o2l #8
    // Write to &displayLEDs:2
    // ANDi %0 $o2l #0xFF
    // Write to &displayLEDs:3
    bi = 0;
    if (condition) {
    // .l73: MOVi $mix #0
    vi = 0;
    if (condition) {
    // .l75: GETL $reg $vre $vi
    // SHRu %0 $reg #HWAV
    // ANDi $wav %0 #255
    // EQUi $wav #0 @.f76
    // SHRu %0 $reg #HVOL
    // ANDi $vol %0 #255
    // SHRu %0 $reg #HCP
    // ANDi $sem %0 #255
    // SHRu %0 $reg #HFP
    // ANDi $fin %0 #255
    // GETL $phs $vph $vi
    // GETL $rnd $vrn $vi
    // ANDi %0 $wav #HRS
    if (condition == 0) {
    phs = 0;
    rnd = 0;
    // .f77: NOOP
    // ! SUBi <A> #8 #PFI
    // SHLi %0 $sem #PFI
    // SHRi %1 $fin <A>
    // IORi %0 %0 %1
    // ADDi $ptc $tun %0
    // ! SHLi <A> #12 #PFI
    // DIVi %0 $ptc <A>
    // XORi %0 %0 #-1
    // XORi $oct %0 #-1
    // ! SHLi <A> #12 #PFI
    // MULi %0 $oct <A>
    // SUBi $i $ptc %0
    // Read from &ptbl
    // SUBi %1 #32 $oct
    // SHRi $ort %0 %1
    // ! SUBi <A> #VMB #4
    // ! SHLi <B> #1 #VEB
    // ! ADDi <A> <A> <B>
    // SHRi %0 $vol #VMB
    // SUBi $vsh <A> %0
    // ! SHLi <A> #1 #VMB
    // ! SUBi <A> <A> #1
    // ! SHLi <B> #1 #VMB
    // ANDi %0 $vol <A>
    // ADDi $vmu <B> %0
    // ADDi $phs $phs $ort
    // ! SHLi <B> #1 #PIB
    // SHRi %0 $phs #PFB
    // ! SUBi <B> <B> #1
    // ANDi $p %0 <B>
    s = 0;
    // ANDi %0 $wav #HTR
    if (condition == 0) {
    // SHLi %0 $p #24
    // SHLi %1 $p #1
    // SHRi %0 %0 #31
    // XORi %1 %1 %0
    // ANDi %1 %1 #255
    // SUBi %1 %1 #128
    // IORi $s $s %1
    // .f78: ANDi %1 $wav #HSW
    // EQUi %1 #0 @.f79
    // SUBi %1 $p #128
    // IORi $s $s %1
    // .f79: ANDi %1 $wav #HSQ
    // EQUi %1 #0 @.f80
    // SHRi %1 $phs #PFB
    // ANDi %1 %1 #128
    // SHLi %1 %1 #1
    // SUBi %1 %1 #128
    // IORi $s $s %1
    // .f80: ANDi %1 $wav #HNO
    // EQUi %1 #0 @.f81
    // SUBi %1 $phs $ort
    // XORi %1 $phs %1
    // ! ADDi <B> #2 #PFB
    // SHRu %1 %1 <B>
    // EQUi %1 #0 @.f82
    // SHRi %1 $rnd #23
    // SHRi %0 $rnd #7
    // XORi %1 %1 %0
    // XORi %1 %1 #-1
    // SHRu %0 $rnd #8
    // SHLi %1 %1 #24
    // IORi $rnd %0 %1
    // .f82: SHRi %0 $rnd #24
    // IORi $s $s %0
    // .f81: MULi %0 $s $vmu
    // SHRi $s %0 $vsh
    if (condition) {
    s = -128;
    // GOTO @.e84
    // .f83: LEQi $s #127 @.f85
    s = 127;
    // .f85: NOOP
    // .e84: ADDi $mix $mix $s
    // SETL $vph $vi $phs
    // SETL $vrn $vi $rnd
    // .f76: FORi $vi #HVC @.l75
    // .e74: ADDi %1 $clk $dly
    %2 = 1;
    // MOVp %3 &signal
    write();
    %1 = clk;
    %2 = 1;
    // MOVp %3 &signal
    read();
    // NEQi $o2m #O2SMU @.f87
    // NEQi $mst #FALSE @.f87
    // SHLi %0 $mix #2
    // Write to &signal:0
    // SHLi %0 $mix #2
    // Write to &signal:1
    // GOTO @.e88
    // .f87: PEEK %0 &signal:0
    // SHLi %1 $mix #2
    // ADDi %0 %0 %1
    // Write to &signal:0
    // Read from &signal:1
    // SHLi %1 $mix #2
    // ADDi %0 %0 %1
    // Write to &signal:1
    // .e88: CALL ^yield %0 *1
    // Read from &clock
    // FORi $bi #HBS @.l73
    // continue loop
    // RETU
}
