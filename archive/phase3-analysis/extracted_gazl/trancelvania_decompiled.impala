/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
const int FALSE = 0
const int TRUE = 1
const float E = 2.71828182845904523536
const float HALF_PI = 1.57079632679489661923
const float PI = 3.14159265358979323846
const float COS_EPSILON = 1.0e-6
const int BATCH_SIZE = 64
const int FILTER_PARAM_TABLE_SIZE = 256
const float LNRQ = 0.346574
const float EPSILON = 0.000000001
const float LOG1000 = 6.9077552789821
const float LOG0_001 = -6.9077552789821

global int clock = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int instance = 0
global int clockFreqLimit = 176400
global array signal[2]
global int doReset = TRUE
global array filterParamTable[<A>]
global array rateTable[256]

function error()
{
    // PARA *1
    // MOVp %1 $s
    trace();
    abort();
    // RETU
}

function trunc()
{
    // GEQf $x #0.0 @.f0
    // SUBf %0 #0.0 $x
    // FLOf %0 %0
    // SUBf $y #0.0 %0
    // GOTO @.e1
    // .f0: FLOf $y $x
    // .e1: RETU
}

function fmod()
{
    // NEQf $y #0.0 @.f0
    // MOVp %1 &.s_Divisie14fb4c0
    error();
    // GOTO @.e1
    // .f0: DIVf %1 $x $y
    trunc();
    // MULf %0 %0 $y
    // SUBf $z $x %0
    // .e1: RETU
}

function exp()
locals float a, float n, float m, float t
{
    // ABSf $m $x
    // MOVf $a #1.0
    // MOVf $n #1.0
    // MOVf $y #1.0
    // .l0: MOVf $t $y
    // MULf %0 $a $m
    // DIVf $a %0 $n
    // ADDf $y $y $a
    // ADDf $n $n #1.0
    // NEQf $y $t @.l0
    // GEQf $x #0.0 @.f1
    // DIVf $y #1.0 $y
    // .f1: RETU
}

function cos()
locals float a, float n, float m, float t
{
    // MOVf %1 $x
    // MOVf %2 #TWICE_PI
    fmod();
    // MOVf $m %0
    // SUBf %0 #0.0 $m
    // MULf $m %0 $m
    // MOVf $y #1.0
    // MOVf $n #1.0
    // MOVf $a #1.0
    // .l0: MOVf $t $y
    // MULf %0 $n $n
    // MULf %1 $a $m
    // ADDf %0 %0 $n
    // DIVf $a %1 %0
    // ADDf $y $y $a
    // ADDf $n $n #2.0
    // NEQf $y $t @.l0
    // ABSf %1 $y
    // GEQf %1 #COS_EPSILON @.f1
    // MOVf $y #0.0
    // .f1: RETU
}

function sin()
{
    // SUBf %1 $x #HALF_PI
    cos();
    // MOVf $y %0
    // RETU
}

function init()
locals float f, float k, float m, int i, float x
{
    // PARA *1
    // MOVp %1 &.s_inite14fb4c1
    trace();
    i = 0;
    if (condition) {
    // .l1: NOOP
    // ! DIVf <A> #1.0 #FILTER_PARAM_MAX
    // iTOf %1 $i <A>
    // MULf %1 #LOG1000 %1
    exp();
    // DIVf $f %0 #2205.0
    // MULf %1 #4.0 $f
    // MULf %1 %1 $f
    // SUBf %1 #1.0 %1
    // MULf %1 %1 #LNRQ
    exp();
    // MOVf $m %0
    // MULf %1 #PI $f
    sin();
    // ! MULf <A> #2.0 #PI
    // MULf %2 <A> $f
    cos();
    // MULf %2 $m #0.5
    // SUBf %1 #1.0 %1
    // MULf %0 #2.0 %0
    // MULf %2 %2 %1
    // SUBf $k %0 %2
    // MULi %0 $i #2
    // Write to &filterParamTable
    // MULi %0 $i #2
    // ADDi %0 %0 #1
    // Write to &filterParamTable
    // FORi $i #FILTER_PARAM_TABLE_SIZE @.l1
    // .e0: MOVi $i #0
    if (condition) {
    // .l3: NOOP
    // ! DIVf <A> #1.0 #255.0
    // iTOf %1 $i <A>
    // MULf %1 #LOG0_001 %1
    exp();
    // Write to &rateTable
    // FORi $i #256 @.l3
    // .e2: RETU
}

function reset()
{
    // PARA *1
    // MOVp %1 &.s_resete14fb4c2
    trace();
    // Write to &doReset
    // RETU
}

function process()
locals int i, int clock, int clockDir, int step, float l, float r, float gateL, float gateR, float valueL, float valueR, float attackRate, float decayRate, float rateL, float rateR, int meter, float lpL, float lpR, float bpL, float bpR, float hpL, float hpR, float kL, float kR, float mL, float mR, float maxi, int idxL, int idxR, int outputChoice, float inputSignal, float nyquist, float gainL, float gainR, float gainLD, float gainRD
{
    // PARA *1
    // .l0: PEEK %0 &doReset
    // EQUi %0 #FALSE @.f1
    // MOVf $valueL #0.0
    // MOVf $valueR #0.0
    // MOVf $lpL #0.0
    // MOVf $lpR #0.0
    // MOVf $bpL #0.0
    // MOVf $bpR #0.0
    // MOVf $gainL #0.0
    // MOVf $gainR #0.0
    // Write to &doReset
    // .f1: PEEK $clock &clock
    clockDir = 1;
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi %0 %0 #SWITCHES_REVERSE_MASK
    if (condition == 0) {
    clockDir = -1;
    // .f2: MOVf $gateR #EPSILON
    // MOVf $gateL #EPSILON
    // Read from &params:OPERATOR_1_PARAM_INDEX
    // SWCH %0 *5 @.s3
    // .s3#0: POKE &displayLEDs:1 #0
    // Write to &displayLEDs:0
    // ANDi %0 $clock #65535
    // LSSi %0 #32768 @.e4
    // MOVf $gateR #1.0
    // MOVf $gateL #1.0
    // GOTO @.e4
    // .s3#1: SHRi %0 $clock #12
    // ANDi $step %0 #15
    // SHRi %0 #128 $step
    // Write to &displayLEDs:0
    // SHRi %0 #0x8000 $step
    // Write to &displayLEDs:1
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_1_LOW_PARAM_INDEX
    // IORi %0 %0 %1
    // SHRu %1 #0x8000 $step
    // ANDi %0 %0 %1
    if (condition == 0) {
    // MOVf $gateR #1.0
    // MOVf $gateL #1.0
    // GOTO @.e4
    // .s3#2: SHRi %0 $clock #11
    // ANDi $step %0 #15
    // SHRi %0 #128 $step
    // Write to &displayLEDs:0
    // SHRi %0 #0x8000 $step
    // Write to &displayLEDs:1
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_1_LOW_PARAM_INDEX
    // IORi %0 %0 %1
    // SHRu %1 #0x8000 $step
    // ANDi %0 %0 %1
    if (condition == 0) {
    // MOVf $gateR #1.0
    // MOVf $gateL #1.0
    // GOTO @.e4
    // .s3#3: SHRi %0 $clock #12
    // ANDi $step %0 #7
    // SHRi %0 #128 $step
    // Write to &displayLEDs:0
    // SHRi %0 #128 $step
    // Write to &displayLEDs:1
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // SHRu %1 #0x80 $step
    // ANDi %0 %0 %1
    if (condition == 0) {
    // MOVf $gateL #0.666666666666
    // .f8: PEEK %0 &params:OPERAND_1_LOW_PARAM_INDEX
    // SHRu %1 #0x80 $step
    // ANDi %0 %0 %1
    if (condition == 0) {
    // ADDf $gateL $gateL #0.333333333333
    // .f9: MOVf $gateR $gateL
    // GOTO @.e4
    // .s3#4: SHRi %0 $clock #12
    // ANDi $step %0 #7
    // SHRi %0 #128 $step
    // Write to &displayLEDs:0
    // SHRi %0 #128 $step
    // Write to &displayLEDs:1
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // SHRu %1 #0x80 $step
    // ANDi %0 %0 %1
    if (condition == 0) {
    // MOVf $gateL #1.0
    // .f10: PEEK %0 &params:OPERAND_1_LOW_PARAM_INDEX
    // SHRu %1 #0x80 $step
    // ANDi %0 %0 %1
    if (condition == 0) {
    // MOVf $gateR #1.0
    // .f11: NOOP
    // .s3: NOOP
    // .e4: PEEK $outputChoice &params:OPERATOR_2_PARAM_INDEX
    // Read from &params:OPERAND_2_HIGH_PARAM_INDEX
    // Read from &rateTable
    // Read from &params:OPERAND_2_LOW_PARAM_INDEX
    // Read from &rateTable
    // MOVf $rateL $attackRate
    // MOVf $rateR $attackRate
    // GEQf $gateL $valueL @.f12
    // MOVf $rateL $decayRate
    // .f12: GEQf $gateR $valueR @.f13
    // MOVf $rateR $decayRate
    // .f13: SUBf %0 $gateL $valueL
    // MULf %0 %0 $rateL
    // ADDf $valueL $valueL %0
    // SUBf %0 $gateR $valueR
    // MULf %0 %0 $rateR
    // ADDf $valueR $valueR %0
    // MOVf $maxi $valueL
    // LEQf $valueR $maxi @.f14
    // MOVf $maxi $valueR
    // .f14: NOOP
    // ! DIVf <A> #0.5 #16.0
    // ADDf %0 $maxi <A>
    // fTOi %0 %0 #16.0
    // SUBi %0 #16 %0
    // SHLi $meter #0xFFFF %0
    // SHRu %0 $meter #8
    // Write to &displayLEDs:2
    // ANDi %0 $meter #0xFF
    // Write to &displayLEDs:3
    // ! DIVf <A> #0.5 #FILTER_PARAM_MAX
    // ADDf %0 $valueL <A>
    // fTOi $idxL %0 #FILTER_PARAM_MAX
    // ! DIVf <A> #0.5 #FILTER_PARAM_MAX
    // ADDf %0 $valueR <A>
    // fTOi $idxR %0 #FILTER_PARAM_MAX
    // MULi %0 $idxL #2
    // Read from &filterParamTable
    // MULi %0 $idxR #2
    // Read from &filterParamTable
    // MULi %0 $idxL #2
    // ADDi %0 %0 #1
    // Read from &filterParamTable
    // MULi %0 $idxR #2
    // ADDi %0 %0 #1
    // Read from &filterParamTable
    // LSSf $rateL #1.0 @.f15
    // MOVf $gainL $valueL
    // .f15: LSSf $rateR #1.0 @.f16
    // MOVf $gainR $valueR
    // .f16: NOOP
    // ! iTOf <A> #BATCH_SIZE #1.0
    // SUBf %0 $valueL $gainL
    // ! DIVf <A> #1.0 <A>
    // MULf $gainLD %0 <A>
    // ! iTOf <A> #BATCH_SIZE #1.0
    // SUBf %0 $valueR $gainR
    // ! DIVf <A> #1.0 <A>
    // MULf $gainRD %0 <A>
    // MOVf $nyquist #EPSILON
    i = 0;
    if (condition) {
    // .l18: MOVi %1 $clock
    %2 = 1;
    // MOVp %3 &signal
    write();
    %1 = clock;
    %2 = 1;
    // ADRL %3 $inputSignal *0
    read();
    // ! DIVf <A> #1.0 #2048.0
    // iTOf %0 $inputSignal:0 <A>
    // ADDf $l %0 $nyquist
    // ! DIVf <A> #1.0 #2048.0
    // iTOf %0 $inputSignal:1 <A>
    // ADDf $r %0 $nyquist
    // MULf %0 $kL $bpL
    // ADDf $lpL $lpL %0
    // MULf %0 $kR $bpR
    // ADDf $lpR $lpR %0
    // MULf %0 $mL $bpL
    // ADDf %0 $lpL %0
    // SUBf $hpL %0 $l
    // MULf %0 $mR $bpR
    // ADDf %0 $lpR %0
    // SUBf $hpR %0 $r
    // MULf %0 $kL $hpL
    // SUBf $bpL $bpL %0
    // MULf %0 $kR $hpR
    // SUBf $bpR $bpR %0
    // SUBi %0 $outputChoice #1
    // SWCH %0 *4 @.s19
    // .s19#0: MULf $l $l $gainL
    // MULf $r $r $gainR
    // ADDf $gainL $gainL $gainLD
    // ADDf $gainR $gainR $gainRD
    // GOTO @.e20
    // .s19#1: MOVf $l $lpL
    // MOVf $r $lpR
    // GOTO @.e20
    // .s19#2: MOVf $l $bpL
    // MOVf $r $bpR
    // GOTO @.e20
    // .s19#3: MOVf $l $hpL
    // MOVf $r $hpR
    // .s19: NOOP
    // .e20: fTOi %0 $l #2048.0
    // Write to &signal:0
    // fTOi %0 $r #2048.0
    // Write to &signal:1
    yield();
    // ADDi $clock $clock $clockDir
    // SUBf $nyquist #0.0 $nyquist
    // FORi $i #BATCH_SIZE @.l18
    // .e17: MOVf $gainL $valueL
    // MOVf $gainR $valueR
    // continue loop
    // RETU
}
