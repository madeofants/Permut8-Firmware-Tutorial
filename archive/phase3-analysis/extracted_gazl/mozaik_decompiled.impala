/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
const int FALSE = 0
const int TRUE = 1
const float LOG2 = 0.69314718055994530942
const float HP_EPSILON = 1.0e-011
const float HP_K = 0.0056828256022101

global int clock = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int clockFreqLimit = 132300
global array signal[2]
global int wantsReset = FALSE
global int breakLoop = FALSE
global array readRates[256]
global array blockLens[256]
global array minCycles[256]
global array thresDKs[256]

function error()
{
    // PARA *1
    // MOVp %1 $s
    trace();
    abort();
    // RETU
}

function exp()
locals float a, float n, float m, float t
{
    // ABSf $m $x
    // MOVf $a #1.0
    // MOVf $n #1.0
    // MOVf $y #1.0
    // .l0: MOVf $t $y
    // MULf %0 $a $m
    // DIVf $a %0 $n
    // ADDf $y $y $a
    // ADDf $n $n #1.0
    // NEQf $y $t @.l0
    // GEQf $x #0.0 @.f1
    // DIVf $y #1.0 $y
    // .f1: RETU
    // 
    // 
}

function log()
locals float a, float b, float m, float n, float t
{
    // LEQf $x #0.0 @.t0
    // LSSf $x #1.0e38 @.f1
    // .t0: MOVp %1 &.s_Domainb1e34dd0
    error();
    // GOTO @.e2
    // .f1: MOVf $b #0.0
    // MOVf $m $x
    // .l3: GEQf $m #0.5 @.e4
    // MULf $m $m #2.0
    // SUBf $b $b #LOG2
    // continue loop
    // .e4: NOOP
    // .l5: LEQf $m #1.5 @.e6
    // MULf $m $m #0.5
    // ADDf $b $b #LOG2
    // continue loop
    // .e6: SUBf $m #1.0 $m
    // MOVf $a #-1.0
    // MOVf $n #1.0
    // MOVf $y #0.0
    // .l7: MOVf $t $y
    // MULf $a $a $m
    // DIVf %0 $a $n
    // ADDf $y $y %0
    // ADDf $n $n #1.0
    // NEQf $y $t @.l7
    // ADDf $y $y $b
    // .e2: RETU
    // 
    // 
}

function pow()
locals float a
{
    // MOVf $z #0.0
    // MOVf $a $x
    // GEQf $a #0.0 @.f1
    // FLOf %0 $y
    // NEQf $y %0 @.f1
    // SUBf $a #0.0 $a
    // .f1: LEQf $a #0.0 @.f2
    // MOVf %2 $a
    log();
    // MULf %1 %1 $y
    exp();
    // MOVf $z %0
    // GOTO @.e3
    // .f2: LSSf $a #0.0 @.t4
    // GRTf $y #0.0 @.f5
    // .t4: MOVp %1 &.s_Domainb1e34dd0
    error();
    // .f5: NOOP
    // .e3: EQUf $a $x @.f7
    // MULf %0 $y #0.5
    // MULf %1 $y #0.5
    // FLOf %0 %0
    // EQUf %1 %0 @.f7
    // SUBf $z #0.0 $z
    // .f7: RETU
    // 
    // 
}

function logScale()
{
    // DIVf %1 $outTo $outFrom
    // MOVf %2 $x
    pow();
    // MULf $y $outFrom %0
    // RETU
}

function decayConstant()
{
    // DIVf %2 #1.0 $reach
    log();
    // DIVf %2 #-1.0 $time
    // MULf %1 %2 %1
    exp();
    // MOVf $factor %0
    // RETU
}

function init()
locals int i, float x, int minCycle
{
    // PARA *1
    // Write to &wantsReset
    // Write to &breakLoop
    i = 0;
    if (condition) {
    // .l1: NOOP
    // ! DIVf <A> #1.0 #256.0
    // iTOf $x $i <A>
    // MOVf %1 $x
    // MOVf %2 #32768.0
    // MOVf %3 #131072.0
    logScale();
    // ADDf %0 %0 #0.5
    // fTOi %0 %0 #1.0
    // Write to &readRates
    // MOVf %1 $x
    // MOVf %2 #128.0
    // MOVf %3 #32768.0
    logScale();
    // ADDf %0 %0 #0.5
    // fTOi %0 %0 #1.0
    // Write to &blockLens
    // MOVf %1 $x
    // MOVf %2 #10.0
    // MOVf %3 #2000.0
    logScale();
    // ADDf %0 %0 #0.5
    // fTOi $minCycle %0 #1.0
    // Write to &minCycles
    // iTOf %1 $minCycle #1.0
    // MOVf %2 #0.6666666
    decayConstant();
    // Write to &thresDKs
    // FORi $i #256 @.l1
    // .e0: POKE &blockLens:0 #0
    // RETU
}

function update()
{
    // PARA *1
    // Write to &breakLoop
    // RETU
}

function process()
locals float inL, float inR, float yL, float yR, float y2, int clock, int wcLenL, int wcLenR, int blockCounter, int newRCL, int newRCR, float hdL, float hdR, float lastYL, float lastYR, int cycleParam, int minCycle, int maxCycle, int blockLen, int readRate, int rateCrushMask, int bitCrushMask, int wcStartL, int ccStartL, int ccLenL, int rcStartL, int rcLenL, int playPosL, int wcStartR, int ccStartR, int ccLenR, int rcStartR, int rcLenR, int playPosR, float thresPosL, float thresNegL, float thresPosR, float thresNegR, float thresDK, int stageL, int stageR, int writeProtect, int sync, int reverseMask
{
    // PARA *1
    // .l0: PEEK %0 &wantsReset
    // EQUi %0 #FALSE @.f1
    playPosL = 0;
    rcLenL = 0;
    rcStartL = 0;
    ccLenL = 0;
    ccStartL = 0;
    wcStartL = 0;
    playPosR = 0;
    rcLenR = 0;
    rcStartR = 0;
    ccLenR = 0;
    ccStartR = 0;
    wcStartR = 0;
    // MOVf $lastYR #0.0
    // MOVf $lastYL #0.0
    // MOVf $thresNegR #0.0
    // MOVf $thresPosR #0.0
    // MOVf $thresNegL #0.0
    // MOVf $thresPosL #0.0
    stageR = 0;
    stageL = 0;
    blockCounter = 0;
    newRCR = FALSE;
    newRCL = FALSE;
    // Write to &wantsReset
    // .f1: PEEK $cycleParam &params:OPERAND_2_HIGH_PARAM_INDEX
    // Read from &minCycles
    // MULi $maxCycle $minCycle #4
    // Read from &thresDKs
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // Read from &blockLens
    // Read from &params:OPERAND_2_LOW_PARAM_INDEX
    // Read from &readRates
    // Read from &params:OPERAND_1_LOW_PARAM_INDEX
    // ANDi %0 %0 #0xF
    // XORi $rateCrushMask %0 #-1
    // Read from &params:OPERAND_1_LOW_PARAM_INDEX
    // ANDi %0 %0 #0xF0
    // XORi $bitCrushMask %0 #-1
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi $writeProtect %0 #SWITCHES_WRITE_PROTECT_MASK
    reverseMask = 0;
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi %0 %0 #SWITCHES_REVERSE_MASK
    if (condition == 0) {
    reverseMask = 0xFFFF;
    // .f2: PEEK %0 &params:SWITCHES_PARAM_INDEX
    // ANDi $sync %0 #SWITCHES_SYNC_MASK
    // Write to &breakLoop
    // .l3: PEEK %0 &breakLoop
    // NEQi %0 #FALSE @.l0
    // Read from &clock
    // XORi $clock %0 $reverseMask
    // NEQi $clock #0 @.f6
    // EQUi $sync #FALSE @.f6
    blockCounter = 0;
    // .f6: PEEK %0 &signal:0
    // ! DIVf <A> #1.0 #2048.0
    // iTOf $inL %0 <A>
    // SUBf %0 $inL $hdL
    // ABSf %0 %0
    // GEQf %0 #HP_EPSILON @.f7
    // MOVf $hdL $inL
    // GOTO @.e8
    // .f7: SUBf %0 $inL $hdL
    // MULf %0 %0 #HP_K
    // ADDf $hdL $hdL %0
    // .e8: SUBf $yL $inL $hdL
    // Read from &signal:1
    // ! DIVf <A> #1.0 #2048.0
    // iTOf $inR %0 <A>
    // SUBf %0 $inR $hdR
    // ABSf %0 %0
    // GEQf %0 #HP_EPSILON @.f9
    // MOVf $hdR $inR
    // GOTO @.e10
    // .f9: SUBf %0 $inR $hdR
    // MULf %0 %0 #HP_K
    // ADDf $hdR $hdR %0
    // .e10: SUBf $yR $inR $hdR
    // fTOi $y2:0 $yL #2048.0
    // fTOi $y2:1 $yR #2048.0
    %1 = clock;
    %2 = 1;
    // ADRL %3 $y2 *0
    write();
    // MULf $thresPosL $thresPosL $thresDK
    // MULf $thresNegL $thresNegL $thresDK
    // MULf $thresPosR $thresPosR $thresDK
    // MULf $thresNegR $thresNegR $thresDK
    // LSSf $yL $thresPosL @.f11
    // MOVf $thresPosL $yL
    // NEQi $stageL #0 @.f11
    stageL = 1;
    // .f11: GRTf $yL $thresNegL @.f13
    // MOVf $thresNegL $yL
    // NEQi $stageL #1 @.f13
    stageL = 2;
    // .f13: SUBi %0 $clock $wcStartL
    // ANDi $wcLenL %0 #0xFFFF
    // LSSi $wcLenL $maxCycle @.f15
    stageL = 2;
    // .f15: GRTf $lastYL #0.0 @.f17
    // LSSf $yL #0.0 @.f17
    // NEQi $stageL #2 @.f17
    // LSSi $wcLenL $minCycle @.f17
    stageL = 0;
    ccStartL = wcStartL;
    ccLenL = wcLenL;
    wcStartL = clock;
    // .f17: LSSf $yR $thresPosR @.f18
    // MOVf $thresPosR $yR
    // NEQi $stageR #0 @.f18
    stageR = 1;
    // .f18: GRTf $yR $thresNegR @.f20
    // MOVf $thresNegR $yR
    // NEQi $stageR #1 @.f20
    stageR = 2;
    // .f20: SUBi %0 $clock $wcStartR
    // ANDi $wcLenR %0 #0xFFFF
    // LSSi $wcLenR $maxCycle @.f22
    stageR = 2;
    // .f22: GRTf $lastYR #0.0 @.f24
    // LSSf $yR #0.0 @.f24
    // NEQi $stageR #2 @.f24
    // LSSi $wcLenR $minCycle @.f24
    stageR = 0;
    ccStartR = wcStartR;
    ccLenR = wcLenR;
    wcStartR = clock;
    // .f24: MOVf $lastYL $yL
    // MOVf $lastYR $yR
    // GRTi $blockCounter #0 @.f25
    blockCounter = blockLen;
    newRCL = TRUE;
    newRCR = TRUE;
    // .f25: SUBi $blockCounter $blockCounter #1
    // SHRi %1 $playPosL #16
    // ANDi %1 %1 $rateCrushMask
    // XORi %1 %1 $reverseMask
    // ADDi %1 $rcStartL %1
    %2 = 1;
    // ADRL %3 $y2 *0
    read();
    // ANDi %0 $y2:0 $bitCrushMask
    // Write to &signal:0
    // SHRi %1 $playPosR #16
    // ANDi %1 %1 $rateCrushMask
    // XORi %1 %1 $reverseMask
    // ADDi %1 $rcStartR %1
    %2 = 1;
    // ADRL %3 $y2 *0
    read();
    // ANDi %0 $y2:1 $bitCrushMask
    // Write to &signal:1
    // ADDi $playPosL $playPosL $readRate
    // LSSi $playPosL $rcLenL @.f26
    // EQUi $newRCL #FALSE @.f28
    // NEQi $writeProtect #0 @.f28
    // ANDi %0 $rcLenL $reverseMask
    // ADDi $rcStartL $ccStartL %0
    // SHLi $rcLenL $ccLenL #16
    newRCL = FALSE;
    // .f28: MOVi $playPosL #0
    // .f26: ADDi $playPosR $playPosR $readRate
    // LSSi $playPosR $rcLenR @.f29
    // EQUi $newRCR #FALSE @.f31
    // NEQi $writeProtect #0 @.f31
    // ANDi %0 $rcLenR $reverseMask
    // ADDi $rcStartR $ccStartR %0
    // SHLi $rcLenR $ccLenR #16
    newRCR = FALSE;
    // .f31: MOVi $playPosR #0
    // .f29: CALL ^yield %0 *1
    // continue loop
    // continue loop
    // RETU
}
