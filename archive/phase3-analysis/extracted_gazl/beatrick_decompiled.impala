/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
const int FALSE = 0
const int TRUE = 1
const int NOP = 0
const int MUTE = 1
const int REPEAT = 2
const int SKIP = 3
const int HOLD = 4
const int ACCENT = 1
const int STUTTER = 2
const int REVERSE = 3
const int TAPE_STOP = 4
const int LOOKAHEAD = 0x80

global int clock = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int clockFreqLimit = 132300
global array signal[2]
global int bottomOperator = 0
global array steps[16]
global array gains[16]
global array holds[16]
global array sfxs[16]
global int lastInStep = -1
global int currentOutStep = 0
global int stopIndex = 0
global int stopRate = 0
global int currentGain = 0

function reset()
{
    // PARA *1
    // Write to &lastInStep
    // Write to &currentGain
    // RETU
}

function update()
locals int topOperator, int bottomOperator, int topBits, int bottomBits, int i, int j, int g
{
    // PARA *1
    // Read from &params:OPERATOR_1_PARAM_INDEX
    // Read from &params:OPERATOR_2_PARAM_INDEX
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_1_LOW_PARAM_INDEX
    // IORi $topBits %0 %1
    // Read from &params:OPERAND_2_HIGH_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_2_LOW_PARAM_INDEX
    // IORi $bottomBits %0 %1
    // Write to &bottomOperator
    i = 0;
    if (condition) {
    // .l1: POKE &gains $i #0x10000
    // Write to &steps
    // Write to &holds
    // Write to &sfxs
    // FORi $i #16 @.l1
    // .e0: SWCH $topOperator *5 @.s2
    // .s2#MUTE: MOVi $i #0
    if (condition) {
    // .l5: POKE &gains $i #0xFFFF
    // SHRi %0 #0x8000 $i
    // ANDi %0 $topBits %0
    // NEQi %0 #0 @.f6
    // Write to &gains
    // .f6: FORi $i #16 @.l5
    // GOTO @.e3
    // .s2#REPEAT: MOVi $j #0
    i = 1;
    if (condition) {
    // .l8: SHRi %0 #0x8000 $i
    // ANDi %0 $topBits %0
    if (condition == 0) {
    j = i;
    // .f9: FORi $i #16 @.l8
    // .e7: MOVi $i #0
    if (condition) {
    // .l11: SHRi %0 #0x8000 $i
    // ANDi %0 $topBits %0
    if (condition == 0) {
    j = i;
    // .f12: POKE &steps $i $j
    // FORi $i #16 @.l11
    // GOTO @.e3
    // .s2#SKIP: EQUi $topBits #0 @.e3
    i = 0;
    j = 0;
    // .l14: SHRi %0 #0x8000 $j
    // ANDi %0 $topBits %0
    if (condition == 0) {
    // Write to &steps
    // ADDi $i $i #1
    // .f15: ADDi %0 $j #1
    // ANDi $j %0 #15
    // LSSi $i #16 @.l14
    // GOTO @.e3
    // .s2#HOLD: MOVi $i #0
    if (condition) {
    // .l17: SHRi %0 #0x8000 $i
    // ANDi %0 $topBits %0
    // Write to &holds
    // FORi $i #16 @.l17
    // .e16: NOOP
    // .s2: NOOP
    // .e3: PEEK %0 &bottomOperator
    // SWCH %0 *5 @.s18
    // .s18#ACCENT: MOVi $i #0
    if (condition) {
    // .l21: PEEK $g &gains $i
    // SHRi %0 #0x8000 $i
    // ANDi %0 $bottomBits %0
    // NEQi %0 #0 @.f22
    // SHRi $g $g #1
    // GOTO @.e23
    // .f22: SHLi $g $g #1
    // .e23: POKE &gains $i $g
    // FORi $i #16 @.l21
    // GOTO @.e19
    // .s18#REVERSE: NOOP
    // .s18#STUTTER: NOOP
    // .s18#TAPE_STOP: MOVi $i #0
    if (condition) {
    // .l25: SHRi %0 #0x8000 $i
    // ANDi %0 $bottomBits %0
    // Write to &sfxs
    // FORi $i #16 @.l25
    // .e24: NOOP
    // .s18: NOOP
    // .e19: RETU
}

function process()
locals int localClock, int inStep, int outStep, int i, int gc, int si, int sr, int f, int gain, float localSignal
{
    // PARA *1
    // Read from &clock
    // SHRi $inStep $localClock #12
    // SHRi %0 #0x80 $inStep
    // Write to &displayLEDs:2
    // SHRi %0 #0x8000 $inStep
    // Write to &displayLEDs:3
    // Read from &holds
    // NEQi %0 #0 @.f0
    // ADRL %0 $localSignal *0
    // COPY %0 &signal *2
    %1 = localClock;
    %2 = 1;
    // ADRL %3 $localSignal *0
    write();
    // .f0: PEEK %0 &lastInStep
    // EQUi %0 $inStep @.f1
    // Read from &steps
    // Write to &currentOutStep
    // .f1: PEEK $outStep &currentOutStep
    // SHRi %0 #0x80 $outStep
    // Write to &displayLEDs:0
    // SHRi %0 #0x8000 $outStep
    // Write to &displayLEDs:1
    // SHLi $i $outStep #12
    // Read from &sfxs
    // NEQi %0 #0 @.f2
    // ANDi %1 $localClock #0xFFF
    // IORi %1 $i %1
    %2 = 1;
    // ADRL %3 $localSignal *0
    read();
    // GOTO @.e3
    // .f2: PEEK %0 &bottomOperator
    // SWCH %0 *5 @.s4
    // .s4#REVERSE: ANDi %1 $localClock #0xFFF
    // XORi %1 %1 #0xFFFFFFFFF
    // ADDi %1 $i %1
    %2 = 1;
    // ADRL %3 $localSignal *0
    read();
    // GOTO @.e5
    // .s4#STUTTER: ANDi %1 $localClock #0x3FF
    // IORi %1 $i %1
    %2 = 1;
    // ADRL %3 $localSignal *0
    read();
    // GOTO @.e5
    // .s4#TAPE_STOP: MOVi $si #0x0
    sr = 0x10000;
    // Read from &lastInStep
    // NEQi %0 $inStep @.f6
    // Read from &stopIndex
    // Read from &stopRate
    // .f6: SHRi %1 $si #16
    // IORi %1 $i %1
    %2 = 2;
    // ADRL %3 $localSignal *0
    read();
    // ANDi $f $si #0xFFFF
    // SUBi %0 $localSignal:2 $localSignal:0
    // MULi %0 %0 $f
    // SHRi %0 %0 #16
    // ADDi $localSignal:0 $localSignal:0 %0
    // SUBi %0 $localSignal:3 $localSignal:1
    // MULi %0 %0 $f
    // SHRi %0 %0 #16
    // ADDi $localSignal:1 $localSignal:1 %0
    // ADDi %0 $si $sr
    // Write to &stopIndex
    // SUBi %0 $sr #0x10
    // Write to &stopRate
    // .s4: NOOP
    // .e5: NOOP
    // .e3: MOVi $gc #0x10000
    // ADDi %0 $localClock #LOOKAHEAD
    // ANDi %0 %0 #0xFFFF
    // SHRi %0 %0 #12
    // Read from &gains
    // EQUi $gain #0x10000 @.f7
    // Read from &currentGain
    // MULi %0 $localSignal:0 $gc
    // SHRi $localSignal:0 %0 #16
    // MULi %0 $localSignal:1 $gc
    // SHRi $localSignal:1 %0 #16
    // SUBi %0 $gain $gc
    // SHRi %0 %0 #5
    // ADDi $gc $gc %0
    // .f7: POKE &lastInStep $inStep
    // Write to &currentGain
    // ADRL %0 $localSignal *0
    // COPY &signal %0 *2
    // RETU
}
