/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 3
const int FALSE = 0
const int TRUE = 1
const int STEP_COUNT = 32
const int REVERSE_FX = 0
const int BIT_CRUSH_EFFECT = 1
const int TRANCE_GATE_EFFECT = 2
const int REPEAT_EFFECT = 3
const int STRETCH_EFFECT = 4
const int PITCH_SHIFT_EFFECT = 5
const int HALF_SPEED_EFFECT = 6
const int TAPE_STOP_FX = 7
const int FX_PARAM_TAPE_STOP_RATE = 0
const int FX_PARAM_TRANCE_GATE_RATE = 1
const int FX_PARAM_BIT_CRUSH_MASK = 2
const int FX_PARAM_REPEAT_MASK = 3
const int FX_PARAM_REPEAT_OFF_3 = 4
const int FX_PARAM_SHIFT_9 = 5
const int FX_PARAM_SHIFT_10 = 6
const int FX_PARAM_1_LSHIFT_9 = 7
const int FX_PARAM_1_LSHIFT_10 = 8
const int FX_PARAM_MASK_10 = 9
const int FX_PARAM_COUNT = 10

global int clock = 0
global int hostPosition = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int clockFreqLimit = 132300
global array signal[2]
global int rndSeedX = 1
global int rndSeedY = 1
global array FX_PARAMS[<A>]
global array stepFXs[STEP_COUNT]
global array stepFXParams[STEP_COUNT]
global int doReset = TRUE
global int updateBits = TRUE
global int clockMask = 0x1FFFF
global int clockShift = 13
global int fxQuantize = 0xFFF
global int dirXor = 0x0

function seedRandom()
locals int x
{
    // PARA *1
    // ADDi $x $seed #1
    // SHLi %0 $x #11
    // XORi $x $x %0
    // MULi %0 $x #134775813
    // SHRu %0 %0 #13
    // MULi $x $x %0
    // SHRu %0 $x #17
    // XORi $x $x %0
    // Write to &rndSeedX
    // Write to &rndSeedY
    // RETU
}

function randomFloat()
locals int x, int y, int t
{
    // Read from &rndSeedX
    // Read from &rndSeedY
    // SHLi %0 $x #10
    // XORi $t $x %0
    x = y;
    // SHRu %0 $y #13
    // XORi %0 $y %0
    // XORi %0 %0 $t
    // SHRu %1 $t #10
    // XORi $y %0 %1
    // ADDi %0 $x $y
    // ABSi %0 %0
    // iTOf $f %0 #4.6566128730774e-10
    // Write to &rndSeedX
    // Write to &rndSeedY
    // RETU
}

function reset()
{
    // PARA *1
    // MOVp %1 &.s_resetf5ba0663
    trace();
    // Write to &doReset
    // RETU
}

function update()
locals int i, int fx, int fxRnd, int fxBits, int fxCount, int stepRate, int fxParams, int stepBits, float fxs, float fxCountFloat
{
    // PARA *1
    // MOVp %1 &.s_updatef5ba0664
    trace();
    // Write to &dirXor
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi %0 %0 #SWITCHES_REVERSE_MASK
    if (condition == 0) {
    // Write to &dirXor
    // .f0: PEEK $fxBits &params:OPERAND_1_HIGH_PARAM_INDEX
    fxCount = 0;
    // Read from &params:OPERATOR_1_PARAM_INDEX
    if (condition) {
    i = 0;
    if (condition) {
    // .l3: SHRi %0 #0x80 $i
    // ANDi %0 $fxBits %0
    if (condition == 0) {
    // SETL $fxs $fxCount $i
    // ADDi $fxCount $fxCount #1
    // .f4: FORi $i #8 @.l3
    // .f1: PEEK %1 &params:OPERAND_1_LOW_PARAM_INDEX
    // ADDi %1 %1 #1
    seedRandom();
    // Read from &params:OPERATOR_2_PARAM_INDEX
    // SUBi $stepRate %0 #1
    if (condition) {
    // Write to &clockMask
    // Write to &clockShift
    // Write to &fxQuantize
    // Write to &stepFXs:0
    if (condition) {
    // Write to &stepFXs:0
    // GOTO @.e7
    // .f5: ANDi %0 $stepRate #1
    // SHLi %0 %0 #16
    // IORi %0 #0xFFFF %0
    // Write to &clockMask
    // SHRi %0 $stepRate #1
    // IORi %0 #12 %0
    // Write to &clockShift
    // Write to &fxQuantize
    // NEQi $fxCount #0 @.f8
    i = 0;
    if (condition) {
    // .l10: POKE &stepFXs $i #-1
    // FORi $i #STEP_COUNT @.l10
    // GOTO @.e11
    // .f8: PEEK %0 &params:OPERAND_2_HIGH_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_2_LOW_PARAM_INDEX
    // IORi $stepBits %0 %1
    // iTOf $fxCountFloat $fxCount #1.0
    // SUBi $fxCount $fxCount #1
    fx = -1;
    i = 0;
    if (condition) {
    // .l13: CALL &randomFloat %0 *1
    // MULf %0 %0 $fxCountFloat
    // fTOi $fxRnd %0 #1.0
    if (condition) {
    fxRnd = fxCount;
    // .f14: ANDi %0 $i #15
    // SHLi %0 $stepBits %0
    // ANDi %0 %0 #0x8000
    if (condition == 0) {
    if (condition) {
    // GETL $fx $fxs $fxRnd
    // GOTO @.e17
    // .f15: MOVi $fx #-1
    // .e17: POKE &stepFXs $i $fx
    // FORi $i #STEP_COUNT @.l13
    // .e12: NOOP
    // .e11: NOOP
    // .e7: MOVi $i #0
    if (condition) {
    // .l19: SWCH $fxParams *5 @.s20
    // .s20#0: MOVi $fx #1
    // GOTO @.e21
    // .s20#1: MOVi $fx #1
    // GOTO @.e21
    // .s20#2: MOVi $fx #2
    // GOTO @.e21
    // .s20#3: MOVi $fx #0
    // GOTO @.e21
    // .s20#4: CALL &randomFloat %0 *1
    // fTOi $fx %0 #2.9999
    // .s20: NOOP
    // .e21: POKE &stepFXParams $i $fx
    // FORi $i #STEP_COUNT @.l19
    // .e18: RETU
}

function init()
locals int i, pointer p, int fxRate, int s, int t
{
    // PARA *1
    // MOVp %1 &.s_initf5ba0665
    trace();
    update();
    // MOVp $p &FX_PARAMS
    i = 0;
    if (condition) {
    // .l1: SUBi $fxRate $i #1
    // ADDi %0 #1 $fxRate
    // SHLi %0 #4 %0
    // Write to $p
    // SUBi %0 #1 $fxRate
    // Write to $p
    // ! XORi <A> #0 #-1
    // SUBi %0 #2 $fxRate
    // SHLi %0 <A> %0
    // Write to $p
    // SUBi $s #10 $fxRate
    // Write to $p
    // SHLi $t #3 $s
    // Write to $p
    // XORi %0 $t #-1
    // Write to $p
    // SHLi $t #1 $s
    // Write to $p
    // SUBi %0 $t #1
    // Write to $p
    // SUBi $s #9 $fxRate
    // Write to $p
    // SHLi %0 #1 $s
    // Write to $p
    // ADDp $p $p #FX_PARAM_COUNT
    // FORi $i #3 @.l1
    // .e0: RETU
}

function process()
locals int i, int x, int mask, int stepBits, int trig, int step, int globalClock, int measure, int twoBarClock, int hostPos, float inp, float outp, float samples, float fxParams, int clock, int fx, int held, int mix, int pos, int posInc
{
    // PARA *1
    // .l0: PEEK %0 &doReset
    // EQUi %0 #FALSE @.f1
    // Write to &doReset
    clock = 0;
    fx = -1;
    held = 0;
    mix = 0;
    pos = 0;
    posInc = 0;
    // ADRL %0 $fxParams *0
    // COPY %0 &FX_PARAMS *FX_PARAM_COUNT
    // .f1: MOVi $trig #FALSE
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi %0 %0 #SWITCHES_SYNC_MASK
    if (condition == 0) {
    // Read from &hostPosition
    // LSSi $hostPos #0 @.f2
    // Read from &clock
    // SHLi %0 $globalClock #16
    // ! MULi <A> #HOST_POSITION_PPQ #2
    // SHRi %0 %0 #31
    // ADDi %1 $hostPos #HOST_POSITION_PPQ
    // MULi %0 <A> %0
    // ADDi %1 %1 %0
    // ! MULi <A> #HOST_POSITION_PPQ #4
    // DIVi $measure %1 <A>
    // Read from &clock
    // Read from &dirXor
    // ANDi %2 $measure #1
    // XORi %1 %1 %0
    // SHLi %2 %2 #16
    // ADDi $twoBarClock %1 %2
    // ANDi %1 $clock #0x1FFFF
    // EQUi $twoBarClock %1 @.f2
    clock = twoBarClock;
    trig = TRUE;
    // .f2: PEEK %1 &fxQuantize
    // ANDi %1 $clock %1
    // NEQi %1 #0 @.f5
    // Read from &dirXor
    // XORi %1 $clock %1
    // Read from &clockMask
    // ANDi %1 %1 %2
    // Read from &clockShift
    // SHRi $step %1 %2
    // ANDi %1 $step #15
    // SHRi %1 #0x80 %1
    // Write to &displayLEDs:2
    // ANDi %1 $step #15
    // SHRi %1 #0x8000 %1
    // Write to &displayLEDs:3
    // Read from &stepFXs
    // EQUi $x $fx @.f5
    fx = x;
    // LSSi $fx #0 @.f7
    trig = TRUE;
    held = fx;
    // SHRi %1 #0x80 $fx
    // Write to &displayLEDs:0
    // Read from &stepFXParams
    // MULi %1 %1 #FX_PARAM_COUNT
    // ADRL %2 $fxParams *0
    // ADDp %1 &FX_PARAMS %1
    // COPY %2 %1 *FX_PARAM_COUNT
    // GOTO @.e8
    // .f7: POKE &displayLEDs:0 #0
    // .e8: NOOP
    // .f5: MOVi %1 $clock
    %2 = 1;
    // MOVp %3 &signal
    write();
    %1 = clock;
    %2 = 1;
    // ADRL %3 $inp *0
    read();
    // SWCH $held *8 @.s9
    // .s9#REVERSE_FX: EQUi $trig #FALSE @.f11
    pos = clock;
    // .f11: SUBi $pos $pos #1
    %1 = pos;
    %2 = 1;
    // ADRL %3 $outp *0
    read();
    // GOTO @.e10
    // .s9#TAPE_STOP_FX: EQUi $trig #FALSE @.f12
    // SHLi $pos $clock #16
    posInc = 0x10000;
    // .f12: ANDi $x $pos #0xFFFF
    // SHRi %1 $pos #16
    %2 = 2;
    // ADRL %3 $samples *0
    read();
    // SUBi %0 $samples:2 $samples:0
    // MULi %0 %0 $x
    // SHRi %0 %0 #16
    // ADDi $outp:0 $samples:0 %0
    // SUBi %0 $samples:3 $samples:1
    // MULi %0 %0 $x
    // SHRi %0 %0 #16
    // ADDi $outp:1 $samples:1 %0
    // ADDi $pos $pos $posInc
    // SUBi $posInc $posInc $fxParams:FX_PARAM_TAPE_STOP_RATE
    if (condition) {
    posInc = 0;
    // GOTO @.e10
    // .s9#HALF_SPEED_EFFECT: EQUi $trig #FALSE @.f14
    // SHLi $pos $clock #1
    // .f14: SHRi %1 $pos #1
    %2 = 1;
    // ADRL %3 $outp *0
    read();
    // ADDi $pos $pos #1
    // GOTO @.e10
    // .s9#TRANCE_GATE_EFFECT: SHRi %0 $clock $fxParams:FX_PARAM_TRANCE_GATE_RATE
    // ANDi $x %0 #0x7FF
    if (condition) {
    x = 0x1800;
    // GOTO @.e16
    // .f15: GEQi $x #0x400 @.f17
    // SUBi %0 $x #0x280
    // SHLi %0 %0 #4
    // SUBi $x #0x1800 %0
    // GOTO @.e18
    // .f17: GEQi $x #0x7A0 @.f19
    x = 0x0;
    // GOTO @.e20
    // .f19: SUBi %0 $x #0x7A0
    // SHLi $x %0 #6
    // .e20: NOOP
    // .e18: NOOP
    // .e16: MULi %0 $inp:0 $x
    // SHRi $outp:0 %0 #12
    // MULi %0 $inp:1 $x
    // SHRi $outp:1 %0 #12
    // GOTO @.e10
    // .s9#BIT_CRUSH_EFFECT: ANDi %1 $clock $fxParams:FX_PARAM_BIT_CRUSH_MASK
    %2 = 1;
    // ADRL %3 $outp *0
    read();
    // ! XORi <A> #0x7F #-1
    // ANDi $outp:0 $outp:0 <A>
    // ! XORi <A> #0x7F #-1
    // ANDi $outp:1 $outp:1 <A>
    // SHRi %0 $outp:0 #1
    // ADDi $outp:0 $outp:0 %0
    // SHRi %0 $outp:1 #1
    // ADDi $outp:1 $outp:1 %0
    // GOTO @.e10
    // .s9#REPEAT_EFFECT: ANDi $pos $clock $fxParams:FX_PARAM_REPEAT_MASK
    %1 = pos;
    %2 = 1;
    // ADRL %3 $samples *0
    read();
    // ANDi %0 $clock $fxParams:FX_PARAM_REPEAT_OFF_3
    // NEQi %0 $fxParams:FX_PARAM_REPEAT_OFF_3 @.f21
    // ADDi $pos $pos $fxParams:FX_PARAM_REPEAT_OFF_3
    // GOTO @.e22
    // .f21: SUBi $pos $pos $fxParams:FX_PARAM_1_LSHIFT_10
    // .e22: ANDi %0 $clock $fxParams:FX_PARAM_MASK_10
    // MULi %0 %0 #2
    // SUBi $x %0 $fxParams:FX_PARAM_1_LSHIFT_10
    if (condition) {
    x = 0;
    // GOTO @.e24
    // .f23: LEQi $x $fxParams:FX_PARAM_MASK_10 @.f25
    x = fxParams:FX_PARAM_MASK_10;
    // .f25: NOOP
    // .e24: MOVi %1 $pos
    %2 = 1;
    // ADRL %3 $samples:2 *0
    read();
    // SUBi %0 $samples:2 $samples:0
    // MULi %0 %0 $x
    // SHRi %0 %0 $fxParams:FX_PARAM_SHIFT_10
    // ADDi $outp:0 $samples:0 %0
    // SUBi %0 $samples:3 $samples:1
    // MULi %0 %0 $x
    // SHRi %0 %0 $fxParams:FX_PARAM_SHIFT_10
    // ADDi $outp:1 $samples:1 %0
    // GOTO @.e10
    // .s9#STRETCH_EFFECT: EQUi $trig #FALSE @.f26
    pos = clock;
    // .f26: MOVi %1 $pos
    %2 = 1;
    // ADRL %3 $samples *0
    read();
    // SUBi %1 $pos $fxParams:FX_PARAM_1_LSHIFT_9
    %2 = 1;
    // ADRL %3 $samples:2 *0
    read();
    // ANDi $x $clock $fxParams:FX_PARAM_MASK_10
    // SUBi %0 $samples:2 $samples:0
    // MULi %0 %0 $x
    // SHRi %0 %0 $fxParams:FX_PARAM_SHIFT_10
    // ADDi $outp:0 $samples:0 %0
    // SUBi %0 $samples:3 $samples:1
    // MULi %0 %0 $x
    // SHRi %0 %0 $fxParams:FX_PARAM_SHIFT_10
    // ADDi $outp:1 $samples:1 %0
    // ADDi $pos $pos #1
    // NEQi $x $fxParams:FX_PARAM_MASK_10 @.e10
    // SUBi $pos $pos $fxParams:FX_PARAM_1_LSHIFT_9
    // GOTO @.e10
    // .s9#PITCH_SHIFT_EFFECT: SUBi %0 $fxParams:FX_PARAM_1_LSHIFT_9 #1
    // ANDi $x $clock %0
    // SUBi %0 $fxParams:FX_PARAM_1_LSHIFT_9 #1
    // XORi %0 %0 #-1
    // ANDi %0 $clock %0
    // MULi %1 $x #2
    // ADDi $pos %0 %1
    // SUBi %1 $pos $fxParams:FX_PARAM_1_LSHIFT_9
    %2 = 1;
    // ADRL %3 $samples *0
    read();
    // SUBi %1 $pos $fxParams:FX_PARAM_1_LSHIFT_10
    %2 = 1;
    // ADRL %3 $samples:2 *0
    read();
    // SUBi %0 $samples:2 $samples:0
    // MULi %0 %0 $x
    // SHRi %0 %0 $fxParams:FX_PARAM_SHIFT_9
    // ADDi $outp:0 $samples:0 %0
    // SUBi %0 $samples:3 $samples:1
    // MULi %0 %0 $x
    // SHRi %0 %0 $fxParams:FX_PARAM_SHIFT_9
    // ADDi $outp:1 $samples:1 %0
    // .s9: NOOP
    // .e10: LSSi $fx #0 @.f28
    // ADDi $mix $mix #0x800
    if (condition) {
    mix = 0x8000;
    // GOTO @.e30
    // .f28: SUBi $mix $mix #0x100
    if (condition) {
    mix = 0;
    // .f31: NOOP
    // .e30: SUBi %0 $outp:0 $inp:0
    // MULi %0 %0 $mix
    // SHRi %0 %0 #15
    // ADDi %0 $inp:0 %0
    // Write to &signal:0
    // SUBi %0 $outp:1 $inp:1
    // MULi %0 %0 $mix
    // SHRi %0 %0 #15
    // ADDi %0 $inp:1 %0
    // Write to &signal:1
    yield();
    // ADDi $clock $clock #1
    // continue loop
    // RETU
}
