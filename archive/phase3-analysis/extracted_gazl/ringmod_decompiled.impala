/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
const int FALSE = 0
const int TRUE = 1
const float LOG2 = 0.69314718055994530942
const float LOG2R = 1.44269504088896340736
const float LOG10R = 0.43429448190325182765
const float E = 2.71828182845904523536
const float HALF_PI = 1.57079632679489661923
const float PI = 3.14159265358979323846
const float COS_EPSILON = 1.0e-6
const int COS_TABLE_BITS = 12
const int BATCH_SIZE = 77

global int clock = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int instance = 0
global int clockFreqLimit = 132300
global array signal[2]
global array cosTable[<A>]
global int doReset = FALSE
global int rate = 0
global int diff = 0
global int delayL = 0
global int delayR = 0
global int syncBit = 0

function stpcpy()
locals pointer b
{
    // MOVp $a $d
    // MOVp $b $s
    // .l0: PEEK %0 $b
    // Write to $a
    if (condition == 0) {
    // ADDp $a $a #1
    // ADDp $b $b #1
    // continue loop
    // .e1: RETU
}

function intToString()
locals pointer e, int x
{
    // ! EQUi #DEBUG #0 @.a0
    // GRTi #2 $radix @.f1
    if (condition) {
    // .f1: MOVp %1 &.a_2radix8971220a
    assertFail();
    // .a0: NOOP
    // ! EQUi #DEBUG #0 @.a2
    // GRTi #0 $minLength @.f3
    if (condition) {
    // .f3: MOVp %1 &.a_0minLe8971220b
    assertFail();
    // .a2: ADDp %0 $buffer #GAZL_WORD_SIZE
    // ADDp $p %0 #1
    // Write to $p
    // SUBp $e $p $minLength
    x = i;
    // .l4: GRTp $p $e @.t5
    // EQUi $x #0 @.e6
    // .t5: NOOP
    // ! EQUi #DEBUG #0 @.a7
    // ADDp %0 $buffer #2
    // GEQp $p %0 @.a7
    // MOVp %1 &.a_pbuffe8971220c
    assertFail();
    // .a7: SUBp $p $p #1
    // MODi %0 $x $radix
    // ADDi %0 #15 %0
    // Read from &.s_fedcba8971220d
    // Write to $p
    // DIVi $x $x $radix
    // continue loop
    // .e6: GEQi $i #0 @.f8
    // SUBp $p $p #1
    // Write to $p
    // .f8: RETU
}

function traceInts()
locals float buffer, float line, int i, pointer p
{
    // PARA *1
    // ! ADDi <A> #GAZL_WORD_SIZE #2
    // ADRL $p $line:0 *0
    // EQUp $text &NULL @.f0
    // MOVp %1 $p
    // MOVp %2 $text
    stpcpy();
    // MOVp $p %0
    // .f0: POKE $p #0
    i = 0;
    if (condition) {
    // .l2: EQUi $i #0 @.f3
    // Write to $p
    // ADDp $p $p #1
    // .f3: MOVp %1 $p
    // Read from $ints
    %4 = 10;
    %5 = 1;
    // ADRL %6 $buffer *0
    intToString();
    stpcpy();
    // MOVp $p %0
    // FORi $i $n @.l2
    // .e1: ADRL %1 $line *0
    trace();
    // RETU
}

function traceInt()
locals float ints
{
    // PARA *1
    ints:0 = i;
    // MOVp %1 $text
    %2 = 1;
    // ADRL %3 $ints *0
    traceInts();
    // RETU
}

function error()
{
    // PARA *1
    // MOVp %1 $s
    trace();
    abort();
    // RETU
}

function trunc()
{
    // GEQf $x #0.0 @.f0
    // SUBf %0 #0.0 $x
    // FLOf %0 %0
    // SUBf $y #0.0 %0
    // GOTO @.e1
    // .f0: FLOf $y $x
    // .e1: RETU
}

function fmod()
{
    // NEQf $y #0.0 @.f0
    // MOVp %1 &.s_Divisi8971220e
    error();
    // GOTO @.e1
    // .f0: DIVf %1 $x $y
    trunc();
    // MULf %0 %0 $y
    // SUBf $z $x %0
    // .e1: RETU
}

function cos()
locals float a, float n, float m, float t
{
    // MOVf %1 $x
    // MOVf %2 #TWICE_PI
    fmod();
    // MOVf $m %0
    // SUBf %0 #0.0 $m
    // MULf $m %0 $m
    // MOVf $y #1.0
    // MOVf $n #1.0
    // MOVf $a #1.0
    // .l0: MOVf $t $y
    // MULf %0 $n $n
    // MULf %1 $a $m
    // ADDf %0 %0 $n
    // DIVf $a %1 %0
    // ADDf $y $y $a
    // ADDf $n $n #2.0
    // NEQf $y $t @.l0
    // ABSf %1 $y
    // GEQf %1 #COS_EPSILON @.f1
    // MOVf $y #0.0
    // .f1: RETU
    // COS_TABLE_BITS: ! DEFi #12
    // ! SHLi <A> #1 #COS_TABLE_BITS
    // COS_TABLE_SIZE: ! DEFi <A>
    // BATCH_SIZE: ! DEFi #77
    // ! ADDi <A> #COS_TABLE_SIZE #1
    // cosTable: GLOB *<A>
    // GLOB *1
    // doReset: DATi #FALSE
    // GLOB *1
    // rate: DATi #0
    // GLOB *1
    // diff: DATi #0
    // GLOB *1
    // delayL: DATi #0
    // GLOB *1
    // delayR: DATi #0
    // GLOB *1
    // syncBit: DATi #0
}

function init()
locals int i, float buf
{
    // PARA *1
    // MOVp %1 &.s_init8971220f
    trace();
    // Read from &instance
    %3 = 10;
    %4 = 1;
    // ADRL %5 $buf *0
    intToString();
    trace();
    i = 0;
    if (condition) {
    // .l1: NOOP
    // ! iTOf <A> #COS_TABLE_SIZE #1.0
    // ! DIVf <A> #TWICE_PI <A>
    // iTOf %1 $i <A>
    cos();
    // fTOi %0 %0 #2048.0
    // Write to &cosTable
    // FORi $i #COS_TABLE_SIZE @.l1
    // .e0: PEEK %0 &cosTable:0
    // Write to &cosTable:COS_TABLE_SIZE
    // RETU
}

function reset()
{
    // PARA *1
    // MOVp %1 &.s_reset89712210
    trace();
    // MOVp %1 &.s_params89712211
    %2 = PARAM_COUNT;
    // MOVp %3 &params
    traceInts();
    // Write to &doReset
    // RETU
}

function displayDelayValue()
locals int x
{
    // ! SUBi <A> #8 #3
    // SHRi %0 $x <A>
    // SHLi $y #0x1 %0
    // RETU
}

function update()
locals float buf, float params
{
    // PARA *1
    // MOVp %1 &.s_update89712212
    trace();
    // MOVp %1 &.s_params89712211
    %2 = PARAM_COUNT;
    // MOVp %3 &params
    traceInts();
    // ADRL %0 $params *0
    // COPY %0 &params *PARAM_COUNT
    // Read from &EIGHT_BIT_EXP_TABLE
    // Write to &delayL
    %1 = params:OPERAND_1_HIGH_PARAM_INDEX;
    displayDelayValue();
    // Write to &displayLEDs:0
    // Read from &EIGHT_BIT_EXP_TABLE
    // Write to &delayR
    %1 = params:OPERAND_1_LOW_PARAM_INDEX;
    displayDelayValue();
    // Write to &displayLEDs:1
    // Read from &EIGHT_BIT_EXP_TABLE
    // Write to &rate
    // SHLi %0 $params:OPERAND_2_LOW_PARAM_INDEX #8
    // Write to &diff
    %1 = params:OPERAND_2_LOW_PARAM_INDEX;
    displayDelayValue();
    // Write to &displayLEDs:3
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi %0 %0 #SWITCHES_SYNC_MASK
    // Write to &syncBit
    // RETU
}

function process()
locals int i, int c0, int c1, int cosL, int cosR, pointer p, int f, int idx, int idxr, int rate, int diff, int delayL, int delayR, int clock, float leftPair, float rightPair
{
    // PARA *1
    idx = 0;
    // .l0: PEEK %0 &doReset
    // EQUi %0 #FALSE @.f1
    idx = 0;
    // Write to &doReset
    // .f1: PEEK $rate &rate
    // Read from &diff
    // Read from &delayL
    // Read from &delayR
    // ADDi %0 $cosL #0x8000
    // ! SUBi <A> #16 #3
    // SHRi %0 %0 <A>
    // SHLi %0 #0x01 %0
    // Write to &displayLEDs:2
    // Read from &syncBit
    if (condition == 0) {
    // Read from &clock
    // MULi $idx %0 $rate
    // .f2: MOVi $i #0
    if (condition) {
    // .l4: PEEK $clock &clock
    %1 = clock;
    %2 = 1;
    // MOVp %3 &signal
    write();
    // ANDi $idx $idx #0xFFFF
    // ! SUBi <A> #16 #COS_TABLE_BITS
    // SHRi %0 $idx <A>
    // ADDp $p &cosTable %0
    // Read from $p
    // Read from $p
    // ! SUBi <A> #16 #COS_TABLE_BITS
    // ! SHLi <A> #1 <A>
    // ! SUBi <A> <A> #1
    // ANDi $f $idx <A>
    // ! SUBi <A> #16 #COS_TABLE_BITS
    // SUBi %0 $c1 $c0
    // SHLi %1 $c0 <A>
    // MULi %0 %0 $f
    // ADDi $cosL %1 %0
    // ADDi %1 $idx $diff
    // ANDi $idxr %1 #0xFFFF
    // ! SUBi <A> #16 #COS_TABLE_BITS
    // SHRi %1 $idxr <A>
    // ADDp $p &cosTable %1
    // Read from $p
    // Read from $p
    // ! SUBi <A> #16 #COS_TABLE_BITS
    // ! SHLi <A> #1 <A>
    // ! SUBi <A> <A> #1
    // ANDi $f $idxr <A>
    // ! SUBi <A> #16 #COS_TABLE_BITS
    // SUBi %1 $c1 $c0
    // SHLi %0 $c0 <A>
    // MULi %1 %1 $f
    // ADDi $cosR %0 %1
    // SUBi %1 $clock $delayL
    %2 = 1;
    // ADRL %3 $leftPair *0
    read();
    // SUBi %1 $clock $delayR
    %2 = 1;
    // ADRL %3 $rightPair *0
    read();
    // MULi %0 $leftPair:0 $cosL
    // SHRi %0 %0 #15
    // Write to &signal:0
    // MULi %0 $rightPair:1 $cosR
    // SHRi %0 %0 #15
    // Write to &signal:1
    // ADDi $idx $idx $rate
    yield();
    // FORi $i #BATCH_SIZE @.l4
    // continue loop
    // RETU
}
