/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
const int FALSE = 0
const int TRUE = 1
const float LOG2 = 0.69314718055994530942
const float LOG2R = 1.44269504088896340736
const float LOG10R = 0.43429448190325182765
const float E = 2.71828182845904523536
const float HALF_PI = 1.57079632679489661923
const float PI = 3.14159265358979323846
const float COS_EPSILON = 1.0e-6
const int VOICE_STATE_SIZE = 31
const int VOICE_COUNT = 8
const int OFF_MODE = 0
const int UNALIGNED_MODE = 1
const int ALIGNED_MODE = 2
const int CYCLING_MODE = 3
const int UNIFORM_MODE = 4
const float SR = 44100.0
const float MUTE_RATE = 0.015625
const int VERB_STATE_SIZE = 12
const float ALMOST_SILENT = 0.0039810715243220329
const int SIN_TABLE_SIZE = 2048
const int VERB_DL_SIZE = 16384
const float SINGLE_POLE_K_APPROX_C1 = 3.017202252562013
const float SINGLE_POLE_K_APPROX_C2 = 2.9654982727404704

global int clock = 0
global int hostPosition = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int instance = 0
global int clockFreqLimit = 132300
global array signal[2]
global int rndSeedX = 1
global int rndSeedY = 1
global array voiceData[<A>]
global array sinTable[SIN_TABLE_SIZE]
global array verbLine[VERB_DL_SIZE]
global array verbState[VERB_STATE_SIZE]
global int songPos = 0
global int lastSeed = 0
global int spaceLeds = 0
global int lengthLeds = 0
global int pitchLeds = 0
global int modulationLeds = 0
global int reverbLeds = 0
global int isChasing = 0

function trunc()
{
    // GEQf $x #0.0 @.f0
    // SUBf %0 #0.0 $x
    // FLOf %0 %0
    // SUBf $y #0.0 %0
    // GOTO @.e1
    // .f0: FLOf $y $x
    // .e1: RETU
}

function fmod()
{
    // DIVf %1 $x $y
    trunc();
    // MULf %0 %0 $y
    // SUBf $z $x %0
    // RETU
}

function cos()
locals float a, float n, float m, float t
{
    // MOVf %1 $x
    // MOVf %2 #TWICE_PI
    fmod();
    // MOVf $m %0
    // SUBf %0 #0.0 $m
    // MULf $m %0 $m
    // MOVf $a #1.0
    // MOVf $n #1.0
    // MOVf $y #1.0
    // .l0: MOVf $t $y
    // MULf %0 $n $n
    // MULf %1 $a $m
    // ADDf %0 %0 $n
    // DIVf $a %1 %0
    // ADDf $y $y $a
    // ADDf $n $n #2.0
    // NEQf $y $t @.l0
    // ABSf %1 $y
    // GEQf %1 #COS_EPSILON @.f1
    // MOVf $y #0.0
    // .f1: RETU
}

function sin()
{
    // SUBf %1 $x #HALF_PI
    cos();
    // MOVf $y %0
    // RETU
}

function sqrtApprox()
locals float t
{
    // MULf %0 #3.6986 $x
    // SUBf %0 %0 #9.24928
    // MULf %0 %0 $x
    // ADDf %0 %0 #8.8951
    // MULf %0 %0 $x
    // ADDf $y %0 #0.0362258
    // DIVf %0 $x $y
    // ADDf %0 $y %0
    // MULf $y #0.5 %0
    // DIVf %0 $x $y
    // ADDf %0 $y %0
    // MULf $y #0.5 %0
    // DIVf %0 $x $y
    // ADDf %0 $y %0
    // MULf $y #0.5 %0
    // DIVf %0 $x $y
    // ADDf %0 $y %0
    // MULf $y #0.5 %0
    // RETU
}

function ceil()
{
    // SUBf %0 #0.0 $x
    // FLOf %0 %0
    // SUBf $y #0.0 %0
    // RETU
}

function exp()
locals float a, float n, float m, float t
{
    // ABSf $m $x
    // MOVf $a #1.0
    // MOVf $n #1.0
    // MOVf $y #1.0
    // .l0: MOVf $t $y
    // MULf %0 $a $m
    // DIVf $a %0 $n
    // ADDf $y $y $a
    // ADDf $n $n #1.0
    // NEQf $y $t @.l0
    // GEQf $x #0.0 @.f1
    // DIVf $y #1.0 $y
    // .f1: RETU
}

function log()
locals float a, float b, float m, float n, float t
{
    // MOVf $b #0.0
    // MOVf $m $x
    // .l0: GEQf $m #0.5 @.e1
    // MULf $m $m #2.0
    // SUBf $b $b #LOG2
    // continue loop
    // .e1: NOOP
    // .l2: LEQf $m #1.5 @.e3
    // MULf $m $m #0.5
    // ADDf $b $b #LOG2
    // continue loop
    // .e3: SUBf $m #1.0 $m
    // MOVf $a #-1.0
    // MOVf $n #1.0
    // MOVf $y #0.0
    // .l4: MOVf $t $y
    // MULf $a $a $m
    // DIVf %0 $a $n
    // ADDf $y $y %0
    // ADDf $n $n #1.0
    // NEQf $y $t @.l4
    // ADDf $y $y $b
    // RETU
}

function pow()
locals float a
{
    // MOVf $z #0.0
    // MOVf $a $x
    // GEQf $a #0.0 @.f1
    // FLOf %0 $y
    // NEQf $y %0 @.f1
    // SUBf $a #0.0 $a
    // .f1: LEQf $a #0.0 @.f2
    // MOVf %2 $a
    log();
    // MULf %1 %1 $y
    exp();
    // MOVf $z %0
    // .f2: EQUf $a $x @.f4
    // MULf %0 $y #0.5
    // MULf %1 $y #0.5
    // FLOf %0 %0
    // EQUf %1 %0 @.f4
    // SUBf $z #0.0 $z
    // .f4: RETU
    // GLOB *1
    // rndSeedX: DATi #1
    // GLOB *1
    // rndSeedY: DATi #1
}

function seedRandom()
locals int x
{
    // PARA *1
    // ADDi $x $seed #1
    // SHLi %1 $x #11
    // XORi $x $x %1
    // MULi %1 $x #134775813
    // SHRu %1 %1 #13
    // MULi $x $x %1
    // SHRu %1 $x #17
    // XORi $x $x %1
    // Write to &rndSeedX
    // Write to &rndSeedY
    // RETU
}

function randomInt()
locals int x, int y, int t
{
    // Read from &rndSeedX
    // Read from &rndSeedY
    // SHLi %1 $x #10
    // XORi $t $x %1
    x = y;
    // SHRu %1 $y #13
    // XORi %1 $y %1
    // XORi %1 %1 $t
    // SHRu %0 $t #10
    // XORi $y %1 %0
    // ADDi $i $x $y
    // Write to &rndSeedX
    // Write to &rndSeedY
    // RETU
}

function randomFloat()
{
    randomInt();
    // ANDi %0 %0 #0x7FFFFFFF
    // iTOf $f %0 #4.6566128730774e-10
    // RETU
}

function pow2()
{
    // MULf $y $x $x
    // RETU
}

function pow3()
{
    // MULf %0 $x $x
    // MULf $y %0 $x
    // RETU
}

function pow5()
{
    // MULf $y $x $x
    // MULf %0 $y $y
    // MULf $y %0 $x
    // RETU
}

function pow9()
{
    // MULf $y $x $x
    // MULf $y $y $y
    // MULf %0 $y $y
    // MULf $y %0 $x
    // RETU
}

function minFloat()
{
    // MOVf $y $a
    // GEQf $b $y @.f0
    // MOVf $y $b
    // .f0: RETU
}

function maxFloat()
{
    // MOVf $y $a
    // LEQf $b $y @.f0
    // MOVf $y $b
    // .f0: RETU
}

function clampFloat()
{
    // MOVf $y $x
    // LEQf $y $maxi @.f0
    // MOVf $y $maxi
    // GOTO @.e1
    // .f0: GEQf $y $mini @.f2
    // MOVf $y $mini
    // .f2: NOOP
    // .e1: RETU
    // VOICE_STATE_SIZE: ! DEFi #31
    // VOICE_COUNT: ! DEFi #8
    // OFF_MODE: ! DEFi #0
    // UNALIGNED_MODE: ! DEFi #1
    // ALIGNED_MODE: ! DEFi #2
    // CYCLING_MODE: ! DEFi #3
    // UNIFORM_MODE: ! DEFi #4
    // SR: ! DEFf #44100.0
    // ! DIVf <A> #1.0 #SR
    // RSR: ! DEFf <A>
    // ! DIVf <A> #4096.0 #SR
    // SIXTEENTH: ! DEFf <A>
    // MUTE_RATE: ! DEFf #0.015625
    // VERB_STATE_SIZE: ! DEFi #12
    // ALMOST_SILENT: ! DEFf #0.0039810715243220329
    // FLOAT_BIT_COUNTS: CNST *16
    // DATA #0.0 #1.0 #1.0 #2.0 #1.0 #2.0 #2.0 #3.0 #1.0 #2.0
    // DATA #2.0 #3.0 #2.0 #3.0 #3.0 #4.0
    // BIT_COUNTS: CNST *16
    // DATA #0 #1 #1 #2 #1 #2 #2 #3 #1 #2 #2 #3 #2 #3 #3 #4
    // UNIFORM_RATES: CNST *16
    // DATA #1.0 #9.0 #5.0 #13.0 #3.0 #11.0 #7.0 #15.0 #2.0 #10.0
    // DATA #6.0 #14.0 #4.0 #12.0 #8.0 #16.0
    // SIN_TABLE_SIZE: ! DEFi #2048
    // ! SUBi <A> #SIN_TABLE_SIZE #1
    // SIN_TABLE_MASK: ! DEFi <A>
    // ! iTOf <A> #SIN_TABLE_SIZE #1.0
    // SIN_TABLE_SIZE_FLOAT: ! DEFf <A>
    // ! MULi <A> #VOICE_COUNT #VOICE_STATE_SIZE
    // voiceData: GLOB *<A>
    // sinTable: GLOB *SIN_TABLE_SIZE
    // VERB_DL_SIZE: ! DEFi #16384
    // ! SUBi <A> #VERB_DL_SIZE #1
    // VERB_DL_MASK: ! DEFi <A>
    // verbLine: GLOB *VERB_DL_SIZE
    // verbState: GLOB *VERB_STATE_SIZE
    // GLOB *1
    // songPos: DATi #0
    // GLOB *1
    // lastSeed: DATi #0
    // GLOB *1
    // spaceLeds: DATi #0
    // GLOB *1
    // lengthLeds: DATi #0
    // GLOB *1
    // pitchLeds: DATi #0
    // GLOB *1
    // modulationLeds: DATi #0
    // GLOB *1
    // reverbLeds: DATi #0
    // GLOB *1
    // isChasing: DATi #0
}

function setupVerb()
locals int size, int delay, int o13, int o3, int o11, int o5, int o7, int oL1, int oL2, int oR, int l, float dI
{
    // PARA *1
    // ADRL %0 $size *0
    // COPY %0 &verbState *VERB_STATE_SIZE
    size = roomSize;
    delay = preDelay;
    // ADDi %0 $size #6
    // DIVi $o13 %0 #13
    // ADDi %0 $size #1
    // DIVi $o3 %0 #3
    // ADDi %0 $size #5
    // DIVi %0 %0 #11
    // ADDi $o11 $o3 %0
    // ADDi %0 $size #2
    // DIVi %0 %0 #5
    // ADDi $o5 $o3 %0
    // ADDi %0 $size #3
    // DIVi %0 %0 #7
    // ADDi $o7 $o5 %0
    // ADDi $oL1 $o7 $delay
    // ADDi $oR $oL1 #1057
    // ADDi $oL2 $oL1 #2311
    // ADRL %0 $size *0
    // COPY &verbState %0 *VERB_STATE_SIZE
    // RETU
}

function processVerb()
locals int i, float d0, int i3, float d3, int i13, int i5, float d5, int i11, int i7, pointer line, int size, int delay, int o13, int o3, int o11, int o5, int o7, int oL1, int oL2, int oR, int l, float dI
{
    // PARA *1
    // ADRL %0 $size *0
    // COPY %0 &verbState *VERB_STATE_SIZE
    // MOVp $line &verbLine
    i = 0;
    if (condition) {
    // .l1: SUBi %0 $l $size
    // ANDi %0 %0 #VERB_DL_MASK
    // Read from $line
    // Read from $in64
    // MULf %0 %0 $feedback
    // ADDf %1 %1 %0
    // SUBf %1 %1 $dI
    // MULf %1 %1 $damping
    // ADDf $dI $dI %1
    // MOVf $d0 $dI
    // SUBi %1 $l $o3
    // ANDi $i3 %1 #VERB_DL_MASK
    // Read from $line
    // MULf %1 $d3 #0.5
    // ADDf $d0 $d0 %1
    // MULf %1 $d0 #0.5
    // SUBf $d3 $d3 %1
    // SUBi %1 $l $o13
    // ANDi $i13 %1 #VERB_DL_MASK
    // Read from $line
    // MULf %1 %1 #0.5
    // ADDf $d0 $d0 %1
    // Read from $line
    // MULf %0 $d0 #0.5
    // SUBf %1 %1 %0
    // Write to $line
    // SUBi %1 $l $o5
    // ANDi $i5 %1 #VERB_DL_MASK
    // Read from $line
    // MULf %1 $d5 #0.5
    // ADDf $d3 $d3 %1
    // MULf %1 $d3 #0.5
    // SUBf $d5 $d5 %1
    // SUBi %1 $l $o11
    // ANDi $i11 %1 #VERB_DL_MASK
    // Read from $line
    // MULf %1 %1 #0.5
    // ADDf $d3 $d3 %1
    // Read from $line
    // MULf %0 $d3 #0.5
    // SUBf %1 %1 %0
    // Write to $line
    // SUBi %1 $l $o7
    // ANDi $i7 %1 #VERB_DL_MASK
    // Read from $line
    // MULf %1 %1 #0.5
    // ADDf $d5 $d5 %1
    // Read from $line
    // MULf %0 $d5 #0.5
    // SUBf %1 %1 %0
    // Write to $line
    // Write to $line
    // Write to $line
    // Write to $line
    // SUBi %1 $l $oL1
    // ANDi %1 %1 #VERB_DL_MASK
    // SUBi %0 $l $oL2
    // ANDi %0 %0 #VERB_DL_MASK
    // Read from $line
    // Read from $line
    // SUBf %1 %1 %0
    // MULf %1 %1 #0.75
    // Write to $outLeft64
    // SUBi %1 $l $oR
    // ANDi %1 %1 #VERB_DL_MASK
    // Read from $line
    // SUBf %1 #0.0 %1
    // Write to $outRight64
    // ADDi $l $l #1
    // FORi $i #64 @.l1
    // .e0: NEQi $l #VERB_DL_SIZE @.f2
    l = 0;
    // .f2: ADRL %1 $size *0
    // COPY &verbState %1 *VERB_STATE_SIZE
    // RETU
}

function calcDecayFactor()
{
    // MOVf $factor #0.0
    // EQUf $time #0.0 @.f0
    // DIVf %2 #1.0 $reach
    log();
    // DIVf %2 #-1.0 $time
    // MULf %1 %2 %1
    exp();
    // MOVf $factor %0
    // .f0: RETU
}

function scale()
{
    // SUBf %0 $outTo $outFrom
    // SUBf %1 $x $inFrom
    // MULf %0 %0 %1
    // SUBf %1 $inTo $inFrom
    // DIVf %0 %0 %1
    // ADDf $y $outFrom %0
    // RETU
}

function logScale()
{
    // DIVf %1 $outTo $outFrom
    // SUBf %2 $x $inFrom
    // SUBf %3 $inTo $inFrom
    // DIVf %2 %2 %3
    pow();
    // MULf $y $outFrom %0
    // RETU
}

function fromDecibel()
{
    // MULf %1 $dB #0.1151292546497022
    exp();
    // MOVf $y %0
    // RETU
}

function intPow()
locals float x2, float x4, float x8
{
    // SUBi %0 $y #1
    // SWCH %0 *10 @.s0
    // .s0#0: MOVf $z $x
    // GOTO @.e1
    // .s0#1: MULf $x2 $x $x
    // MOVf $z $x2
    // GOTO @.e1
    // .s0#2: MULf $x2 $x $x
    // MULf $z $x2 $x
    // GOTO @.e1
    // .s0#3: MULf $x2 $x $x
    // MULf $x4 $x2 $x2
    // MOVf $z $x4
    // GOTO @.e1
    // .s0#4: MULf $x2 $x $x
    // MULf $x4 $x2 $x2
    // MULf $z $x4 $x
    // GOTO @.e1
    // .s0#5: MULf $x2 $x $x
    // MULf $x4 $x2 $x2
    // MULf $z $x4 $x2
    // GOTO @.e1
    // .s0#6: MULf $x2 $x $x
    // MULf $x4 $x2 $x2
    // MULf %0 $x4 $x2
    // MULf $z %0 $x
    // GOTO @.e1
    // .s0#7: MULf $x2 $x $x
    // MULf $x4 $x2 $x2
    // MULf $x8 $x4 $x4
    // MOVf $z $x8
    // GOTO @.e1
    // .s0#8: MULf $x2 $x $x
    // MULf $x4 $x2 $x2
    // MULf $x8 $x4 $x4
    // MULf $z $x8 $x
    // GOTO @.e1
    // .s0#9: MULf $x2 $x $x
    // MULf $x4 $x2 $x2
    // MULf $x8 $x4 $x4
    // MULf $z $x8 $x2
    // .s0: NOOP
    // .e1: RETU
}

function biPow()
{
    // GEQf $x #0.0 @.f0
    // SUBf %1 #0.0 $x
    %2 = negY;
    intPow();
    // SUBf $y #0.0 %0
    // GOTO @.e1
    // .f0: MOVf %1 $x
    %2 = posY;
    intPow();
    // MOVf $y %0
    // .e1: RETU
    // SINGLE_POLE_K_APPROX_C1: ! DEFf #3.017202252562013
    // SINGLE_POLE_K_APPROX_C2: ! DEFf #2.9654982727404704
}

function singlePoleKApprox()
locals float x, float a, float b
{
    // ! DIVf <A> #TWICE_PI #4.0
    // MULf $x <A> $f
    // SUBf $a $x #SINGLE_POLE_K_APPROX_C1
    // ADDf $b $x #SINGLE_POLE_K_APPROX_C1
    // MULf %0 $a $a
    // MULf %1 $b $b
    // ADDf %0 %0 #SINGLE_POLE_K_APPROX_C2
    // ADDf %1 %1 #SINGLE_POLE_K_APPROX_C2
    // DIVf $k %0 %1
    // MULf $k $k $k
    // MULf $k $k $k
    // SUBf $k #1.0 $k
    // RETU
}

function reseedVoice()
locals int seed
{
    // PARA *1
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // Write to &lastSeed
    // SHLi %0 $seed #16
    // ADDi $seed %0 $voiceId
    // SHLi %0 $seed #11
    // XORi $seed $seed %0
    // MULi %0 $seed #134775813
    // SHRu %0 %0 #13
    // MULi $seed $seed %0
    // SHRu %0 $seed #17
    // XORi $seed $seed %0
    // Write to &rndSeedX
    // Write to &rndSeedY
    // RETU
}

function selectSegment()
locals int r, int m, int i
{
    randomInt();
    // ANDi $r %0 #0xFFFF
    // NEQi $mask #0 @.f0
    segment = 0;
    // GOTO @.e1
    // .f0: MOVi $i #1
    if (condition) {
    // .l3: MULi %0 $r $r
    // SHRu $r %0 #16
    // FORi $i $skew @.l3
    // .e2: PEEK %0 &BIT_COUNTS $mask
    // MULi %0 $r %0
    // SHRu $r %0 #16
    // ! EQUi #DEBUG #0 @.a4
    // GRTi #0 $r @.f5
    if (condition) {
    // .f5: MOVp %1 &.a_0rr3d7e336cd
    assertFail();
    // .a4: MOVi $m $mask
    segment = 1;
    // .l6: ANDi %0 $m #8
    if (condition == 0) {
    // SUBi $r $r #1
    if (condition) {
    // GOTO @return
    // .f7: SHLi $m $m #1
    // ADDi $segment $segment #1
    // continue loop
    // .e1: NOOP
    // return: RETU
}

function segmentRandom()
locals float r
{
    // MOVf $value #0.0
    randomFloat();
    // MOVf $r %0
    if (condition) {
    // SUBi %0 $segment #1
    // iTOf %0 %0 #1.0
    // ADDf %0 %0 $r
    // MULf $value %0 #0.25
    // .f0: RETU
}

function randomSign()
{
    // MOVf $s #1.0
    randomInt();
    if (condition) {
    // MOVf $s #-1.0
    // .f0: RETU
}

function renderVoice()
locals int seed, int envPhase, int lastTrig, int nextTrig, float env, float attackRate, float decayFactor, float low, float high, float gone, float amp, float repeatDecay, int posPower, int negPower, float fmAmount, float fmRateHigh, float fmRateLow, float fmRateGone, float wetAmount, int fmType, float leftAmp, float rightAmp, float fmPhase, float fmNoiseD0, float fmNoiseD1, float carrierPhase, int spaceSegment, int lengthSegment, int pitchSegment, int modulationSegment, int reverbSegment, float durationSecs, float lengthSecs, float envTilt, float attackTime, float releaseTime, float f, float f2, float pan, float mono64, pointer m, int i, float fmRate, float fm0, float fm1, float fm2, float fm3, float enva, float m0, float m1, float m2, float m3, float fmNoiseAmp, float fmNoiseFilterK, float drop, float lowFreq, float highFreq, int prngSeedX, int prngSeedY
{
    // ADRL %0 $seed *0
    // COPY %0 $voiceDataPointer *VOICE_STATE_SIZE
    // Read from &rndSeedX
    // Read from &rndSeedY
    // LSSi $position #0 @.f2
    if (condition) {
    // NEQi $seed #0 @.f2
    // .t1: XORi %1 $voiceId #-1
    reseedVoice();
    // MOVf %1 $spacingBits
    %2 = 4;
    selectSegment();
    spaceSegment = %0;
    %2 = spaceSegment;
    segmentRandom();
    pow2();
    // MOVf $durationSecs %0
    %1 = voiceId;
    reseedVoice();
    // Read from &params:OPERATOR_1_PARAM_INDEX
    // NEQi %0 #ALIGNED_MODE @.f3
    // DIVf %1 $durationSecs #SIXTEENTH
    ceil();
    // MULf $durationSecs %0 #SIXTEENTH
    // .f3: PEEK %0 &params:OPERATOR_1_PARAM_INDEX
    // NEQi %0 #UNIFORM_MODE @.f4
    // MOVf $durationSecs #0.0
    // .f4: MOVi $lastTrig #0
    // ! DIVf <A> #SR #64.0
    // MULf %0 $durationSecs <A>
    // ADDf %0 %0 #0.5
    // fTOi $nextTrig %0 #1.0
    // Read from &rndSeedX
    // .f2: MOVf $drop #0.0
    // LSSi $position $nextTrig @.f5
    // LEQf $amp #ALMOST_SILENT @.f7
    // LEQf $env #ALMOST_SILENT @.f7
    // MOVf $drop #MUTE_RATE
    // GOTO @.e8
    // .f7: ANDi %0 $nextTrig $reseedMask
    // ANDi %1 $lastTrig $reseedMask
    // EQUi %0 %1 @.f9
    %1 = voiceId;
    reseedVoice();
    // Read from &rndSeedX
    // .f9: POKE &rndSeedX $seed
    // Write to &rndSeedY
    // MOVf %1 $spacingBits
    %2 = 4;
    selectSegment();
    spaceSegment = %0;
    %1 = lengthBits;
    %2 = 4;
    selectSegment();
    lengthSegment = %0;
    // MOVf %1 $reverbBits
    %2 = 1;
    selectSegment();
    reverbSegment = %0;
    %1 = modulationBits;
    %2 = 1;
    selectSegment();
    modulationSegment = %0;
    %1 = pitchBits;
    %2 = 1;
    selectSegment();
    pitchSegment = %0;
    %2 = spaceSegment;
    segmentRandom();
    pow5();
    // MULf %0 #30.0 %0
    // ADDf $durationSecs #0.08 %0
    %2 = lengthSegment;
    segmentRandom();
    pow5();
    // MULf $lengthSecs #30.0 %0
    randomFloat();
    pow3();
    // MOVf $envTilt %0
    // MULf %0 $lengthSecs $envTilt
    // ADDf $attackTime #0.001 %0
    // SUBf %0 #1.0 $envTilt
    // MULf %0 $lengthSecs %0
    // ADDf $releaseTime #0.08 %0
    // Read from &params:OPERATOR_1_PARAM_INDEX
    // EQUi %0 #UNIFORM_MODE @.t10
    // Read from &params:OPERATOR_1_PARAM_INDEX
    // NEQi %0 #ALIGNED_MODE @.f11
    // .t10: DIVf %1 $durationSecs #SIXTEENTH
    ceil();
    // MULf $durationSecs %0 #SIXTEENTH
    // DIVf %0 $attackTime #SIXTEENTH
    // FLOf %0 %0
    // MULf %0 %0 #SIXTEENTH
    // ADDf $attackTime #0.001 %0
    // DIVf %1 $releaseTime #SIXTEENTH
    ceil();
    // MULf %0 %0 #SIXTEENTH
    // SUBf $releaseTime %0 #0.001
    // .f11: NOOP
    // ! MULf <A> #SR #0.25
    // MULf %1 $attackTime <A>
    // MOVf %2 #1.0
    maxFloat();
    // DIVf $attackRate #1.0 %0
    // ! MULf <A> #SR #0.25
    // MULf %2 $releaseTime <A>
    // MOVf %3 #1.0
    maxFloat();
    // MOVf %2 #ALMOST_SILENT
    calcDecayFactor();
    // MOVf $decayFactor %0
    // Read from &params:OPERATOR_1_PARAM_INDEX
    // NEQi %0 #UNIFORM_MODE @.f12
    // Read from &params:OPERAND_2_HIGH_PARAM_INDEX
    // SHRi %0 %0 #4
    // ANDi %0 %0 #15
    // Read from &UNIFORM_RATES
    // MULf $durationSecs %0 #SIXTEENTH
    // MOVf $attackTime #0.0
    // MOVf $releaseTime #0.0
    // .f12: MOVi $lastTrig $nextTrig
    // MOVf %1 $durationSecs
    // ADDf %2 $attackTime $releaseTime
    maxFloat();
    // ! DIVf <A> #SR #64.0
    // MULf %0 %0 <A>
    // ADDf %0 %0 #0.5
    // fTOi %0 %0 #1.0
    // ADDi $nextTrig $nextTrig %0
    %2 = pitchSegment;
    segmentRandom();
    // MOVf %2 #0.0
    // MOVf %3 #1.0
    // MOVf %4 #40.0
    // MOVf %5 #2560.0
    logScale();
    // MOVf $lowFreq %0
    // MULf $highFreq $lowFreq #4.0
    randomFloat();
    // MOVf %2 #0.0
    // MOVf %3 #1.0
    // MOVf %4 $lowFreq
    // MOVf %5 $highFreq
    logScale();
    // MOVf $low %0
    %3 = modulationSegment;
    segmentRandom();
    randomSign();
    // MULf %2 %2 %3
    pow9();
    // MULf %1 $highFreq %1
    // ADDf %1 $low %1
    // MOVf %2 $lowFreq
    // MOVf %3 $highFreq
    clampFloat();
    // MOVf $high %0
    %3 = modulationSegment;
    segmentRandom();
    randomSign();
    // MULf %2 %2 %3
    pow9();
    // MULf %1 $highFreq %1
    // ADDf %1 $high %1
    // MOVf %2 $lowFreq
    // MOVf %3 $highFreq
    clampFloat();
    // MOVf $gone %0
    // MULf $low $low #RSR
    // MULf $high $high #RSR
    // MULf $gone $gone #RSR
    // MOVf %1 $low
    // MOVf %2 #0.49
    minFloat();
    // MOVf $low %0
    // MOVf %1 $high
    // MOVf %2 #0.49
    minFloat();
    // MOVf $high %0
    // MOVf %1 $gone
    // MOVf %2 #0.49
    minFloat();
    // MOVf $gone %0
    randomFloat();
    // MULf %1 %1 #-24.0
    // SUBf %1 %1 #6.0
    fromDecibel();
    // MOVf $amp %0
    randomFloat();
    // MOVf %3 $lengthSecs
    // MOVf %4 #0.02
    minFloat();
    // MOVf %3 #0.0
    // MOVf %4 #0.02
    // MOVf %5 #0.0
    // MOVf %6 #0.95
    scale();
    // MULf $repeatDecay %0 %1
    randomInt();
    // ANDi %0 %0 #0x7FFFFFFF
    // MODi %0 %0 #10
    // ADDi $posPower %0 #1
    randomInt();
    // ANDi %0 %0 #0x7FFFFFFF
    // MODi %0 %0 #10
    // ADDi $negPower %0 #1
    // MOVf %2 $low
    // MOVf %3 $high
    minFloat();
    // MOVf %2 $gone
    minFloat();
    // MOVf $f %0
    // MOVf %2 $low
    // MOVf %3 $high
    maxFloat();
    // MOVf %2 $gone
    maxFloat();
    // MOVf $f2 %0
    %2 = modulationSegment;
    segmentRandom();
    pow3();
    // MULf $fmAmount $f %0
    // SUBf %2 #0.49 $f2
    // MOVf %3 $f
    minFloat();
    // MOVf %2 $fmAmount
    minFloat();
    randomSign();
    // MULf $fmAmount %0 %1
    randomFloat();
    // MOVf %3 #0.0
    // MOVf %4 #1.0
    // MOVf %5 #1.0
    // MULf %6 $f #SR
    logScale();
    // MULf %1 %1 #RSR
    // MOVf %2 #0.0001
    // MOVf %3 $f
    clampFloat();
    // MOVf $fmRateHigh %0
    %3 = modulationSegment;
    segmentRandom();
    randomSign();
    // MULf %2 %2 %3
    pow5();
    // MULf %1 $f %1
    // ADDf %1 $fmRateHigh %1
    // MOVf %2 #0.0001
    // MOVf %3 $f
    clampFloat();
    // MOVf $fmRateLow %0
    %3 = modulationSegment;
    segmentRandom();
    randomSign();
    // MULf %2 %2 %3
    pow5();
    // MULf %1 $f %1
    // ADDf %1 $fmRateLow %1
    // MOVf %2 #0.0001
    // MOVf %3 $f
    clampFloat();
    // MOVf $fmRateGone %0
    randomFloat();
    // MULf %0 %0 #2.0
    // SUBf $pan %0 #1.0
    %1 = reverbSegment;
    segmentRandom();
    // MOVf $wetAmount %0
    // SUBf $leftAmp #1.0 $wetAmount
    // MOVf $rightAmp $leftAmp
    // LEQf $pan #0.0 @.f13
    // SUBf %0 #1.0 $pan
    // MULf $leftAmp $leftAmp %0
    // GOTO @.e14
    // .f13: ADDf %0 #1.0 $pan
    // MULf $rightAmp $rightAmp %0
    // .e14: CALL &randomInt %0 *1
    // ANDi $fmType %0 #3
    // MOVf $fmNoiseD0 #0.0
    // MOVf $fmNoiseD1 #0.0
    // MOVf $carrierPhase #0.0
    // MOVf $fmPhase #0.0
    // MOVf $env #0.0
    envPhase = 1;
    // LSSi $position $nextTrig @.f15
    envPhase = 0;
    // MOVf $amp #0.0
    // Write to &isChasing
    // .f15: PEEK $seed &rndSeedX
    // .e8: NOOP
    // .f5: LEQi $spaceSegment #0 @.f16
    // Read from &spaceLeds
    // SHRi %1 #16 $spaceSegment
    // IORi %0 %0 %1
    // Write to &spaceLeds
    // .f16: POKE &rndSeedX $prngSeedX
    // Write to &rndSeedY
    // EQUi $envPhase #0 @.f17
    if (condition) {
    // Read from &lengthLeds
    // SHRi %1 #16 $lengthSegment
    // IORi %0 %0 %1
    // Write to &lengthLeds
    // .f18: LEQi $pitchSegment #0 @.f19
    // Read from &pitchLeds
    // SHRi %1 #16 $pitchSegment
    // IORi %0 %0 %1
    // Write to &pitchLeds
    // .f19: LEQi $modulationSegment #0 @.f20
    // Read from &modulationLeds
    // SHRi %1 #16 $modulationSegment
    // IORi %0 %0 %1
    // Write to &modulationLeds
    // .f20: LEQi $reverbSegment #0 @.f21
    // Read from &reverbLeds
    // SHRi %1 #16 $reverbSegment
    // IORi %0 %0 %1
    // Write to &reverbLeds
    // .f21: ADRL $m $mono64 *0
    i = 0;
    if (condition) {
    // .l23: SWCH $envPhase *3 @.s24
    // .s24#0: MOVf $f #0.0
    // MOVf $fmRate #0.0
    // GOTO @.e25
    // .s24#1: ADDf $env $env $attackRate
    // LSSf $env #1.0 @.f26
    // MOVf $env #1.0
    envPhase = 2;
    // .f26: SUBf %0 $fmRateHigh $fmRateLow
    // MULf %0 %0 $env
    // ADDf $fmRate $fmRateLow %0
    // SUBf %0 $high $low
    // MULf %0 %0 $env
    // ADDf $f $low %0
    // GOTO @.e25
    // .s24#2: MULf $env $env $decayFactor
    // GRTf $env #ALMOST_SILENT @.f27
    // MOVf $env #0.0
    // MULf $amp $amp $repeatDecay
    envPhase = 1;
    // GRTf $amp #ALMOST_SILENT @.f27
    envPhase = 0;
    // .f27: SUBf %0 $fmRateHigh $fmRateGone
    // MULf %0 %0 $env
    // ADDf $fmRate $fmRateGone %0
    // SUBf %0 $high $gone
    // MULf %0 %0 $env
    // ADDf $f $gone %0
    // .s24: NOOP
    // .e25: EQUi $envPhase #0 @.f29
    // SWCH $fmType *4 @.s30
    // .s30#0: fTOi %0 $fmPhase #SIN_TABLE_SIZE_FLOAT
    // ANDi %0 %0 #SIN_TABLE_MASK
    // Read from &sinTable
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // fTOi %0 $fmPhase #SIN_TABLE_SIZE_FLOAT
    // ANDi %0 %0 #SIN_TABLE_MASK
    // Read from &sinTable
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // fTOi %0 $fmPhase #SIN_TABLE_SIZE_FLOAT
    // ANDi %0 %0 #SIN_TABLE_MASK
    // Read from &sinTable
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // fTOi %0 $fmPhase #SIN_TABLE_SIZE_FLOAT
    // ANDi %0 %0 #SIN_TABLE_MASK
    // Read from &sinTable
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // GOTO @.e31
    // .s30#1: MULf %0 $fmPhase #2.0
    // FLOf %0 %0
    // MULf %0 %0 #2.0
    // SUBf $fm0 #1.0 %0
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // MULf %0 $fmPhase #2.0
    // FLOf %0 %0
    // MULf %0 %0 #2.0
    // SUBf $fm1 #1.0 %0
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // MULf %0 $fmPhase #2.0
    // FLOf %0 %0
    // MULf %0 %0 #2.0
    // SUBf $fm2 #1.0 %0
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // MULf %0 $fmPhase #2.0
    // FLOf %0 %0
    // MULf %0 %0 #2.0
    // SUBf $fm3 #1.0 %0
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // GOTO @.e31
    // .s30#2: MULf %0 $fmPhase #2.0
    // SUBf $fm0 %0 #1.0
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // MULf %0 $fmPhase #2.0
    // SUBf $fm1 %0 #1.0
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // MULf %0 $fmPhase #2.0
    // SUBf $fm2 %0 #1.0
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // MULf %0 $fmPhase #2.0
    // SUBf $fm3 %0 #1.0
    // ADDf $fmPhase $fmPhase $fmRate
    // FLOf %0 $fmPhase
    // SUBf $fmPhase $fmPhase %0
    // GOTO @.e31
    // .s30#3: MOVf %1 $fmRate
    sqrtApprox();
    // ! MULf <A> #0.7071067811865475244 #0.69314718246459961
    // DIVf $fmNoiseAmp <A> %0
    // MOVf %1 $fmRate
    singlePoleKApprox();
    // MOVf $fmNoiseFilterK %0
    randomFloat();
    // MULf %0 %0 #2.0
    // SUBf %0 %0 #1.0
    // MULf %0 %0 $fmNoiseAmp
    // SUBf %0 %0 $fmNoiseD0
    // MULf %0 %0 $fmNoiseFilterK
    // ADDf $fmNoiseD0 $fmNoiseD0 %0
    // SUBf %0 $fmNoiseD0 $fmNoiseD1
    // MULf %0 %0 $fmNoiseFilterK
    // ADDf $fmNoiseD1 $fmNoiseD1 %0
    // MOVf $fm0 $fmNoiseD1
    randomFloat();
    // MULf %0 %0 #2.0
    // SUBf %0 %0 #1.0
    // MULf %0 %0 $fmNoiseAmp
    // SUBf %0 %0 $fmNoiseD0
    // MULf %0 %0 $fmNoiseFilterK
    // ADDf $fmNoiseD0 $fmNoiseD0 %0
    // SUBf %0 $fmNoiseD0 $fmNoiseD1
    // MULf %0 %0 $fmNoiseFilterK
    // ADDf $fmNoiseD1 $fmNoiseD1 %0
    // MOVf $fm1 $fmNoiseD1
    randomFloat();
    // MULf %0 %0 #2.0
    // SUBf %0 %0 #1.0
    // MULf %0 %0 $fmNoiseAmp
    // SUBf %0 %0 $fmNoiseD0
    // MULf %0 %0 $fmNoiseFilterK
    // ADDf $fmNoiseD0 $fmNoiseD0 %0
    // SUBf %0 $fmNoiseD0 $fmNoiseD1
    // MULf %0 %0 $fmNoiseFilterK
    // ADDf $fmNoiseD1 $fmNoiseD1 %0
    // MOVf $fm2 $fmNoiseD1
    randomFloat();
    // MULf %0 %0 #2.0
    // SUBf %0 %0 #1.0
    // MULf %0 %0 $fmNoiseAmp
    // SUBf %0 %0 $fmNoiseD0
    // MULf %0 %0 $fmNoiseFilterK
    // ADDf $fmNoiseD0 $fmNoiseD0 %0
    // SUBf %0 $fmNoiseD0 $fmNoiseD1
    // MULf %0 %0 $fmNoiseFilterK
    // ADDf $fmNoiseD1 $fmNoiseD1 %0
    // MOVf $fm3 $fmNoiseD1
    // .s30: NOOP
    // .e31: SUBf $amp $amp $drop
    // GEQf $amp #0.0 @.f32
    // MOVf $amp #0.0
    // .f32: MULf $enva $env $amp
    // fTOi %0 $carrierPhase #SIN_TABLE_SIZE_FLOAT
    // ANDi %0 %0 #SIN_TABLE_MASK
    // Read from &sinTable
    // ADDf %0 $carrierPhase $f
    // MULf %1 $fm0 $fmAmount
    // ADDf $carrierPhase %0 %1
    // FLOf %0 $carrierPhase
    // SUBf $carrierPhase $carrierPhase %0
    // fTOi %0 $carrierPhase #SIN_TABLE_SIZE_FLOAT
    // ANDi %0 %0 #SIN_TABLE_MASK
    // Read from &sinTable
    // ADDf %0 $carrierPhase $f
    // MULf %1 $fm1 $fmAmount
    // ADDf $carrierPhase %0 %1
    // FLOf %0 $carrierPhase
    // SUBf $carrierPhase $carrierPhase %0
    // fTOi %0 $carrierPhase #SIN_TABLE_SIZE_FLOAT
    // ANDi %0 %0 #SIN_TABLE_MASK
    // Read from &sinTable
    // ADDf %0 $carrierPhase $f
    // MULf %1 $fm2 $fmAmount
    // ADDf $carrierPhase %0 %1
    // FLOf %0 $carrierPhase
    // SUBf $carrierPhase $carrierPhase %0
    // fTOi %0 $carrierPhase #SIN_TABLE_SIZE_FLOAT
    // ANDi %0 %0 #SIN_TABLE_MASK
    // Read from &sinTable
    // ADDf %0 $carrierPhase $f
    // MULf %1 $fm3 $fmAmount
    // ADDf $carrierPhase %0 %1
    // FLOf %0 $carrierPhase
    // SUBf $carrierPhase $carrierPhase %0
    // MOVf %1 $m0
    %2 = negPower;
    %3 = posPower;
    biPow();
    // MULf $m0 %0 $enva
    // MOVf %1 $m1
    %2 = negPower;
    %3 = posPower;
    biPow();
    // MULf $m1 %0 $enva
    // MOVf %1 $m2
    %2 = negPower;
    %3 = posPower;
    biPow();
    // MULf $m2 %0 $enva
    // MOVf %1 $m3
    %2 = negPower;
    %3 = posPower;
    biPow();
    // MULf $m3 %0 $enva
    // Write to $m
    // Write to $m
    // Write to $m
    // Write to $m
    // GOTO @.e33
    // .f29: POKE $m #0 #0.0
    // Write to $m
    // Write to $m
    // Write to $m
    // .e33: ADDp $m $m #4
    // FORi $i #16 @.l23
    // .e22: MOVi $i #0
    if (condition) {
    // .l35: GETL $m0 $mono64 $i
    // MULf %0 $m0 $leftAmp
    // Write to $left64
    // MULf %0 $m0 $rightAmp
    // Write to $right64
    // MULf %0 $m0 $wetAmount
    // Write to $wet64
    // FORi $i #64 @.l35
    // GOTO @.e36
    // .f17: MOVi $i #0
    if (condition) {
    // .l38: POKE $left64 $i #0.0
    // Write to $right64
    // Write to $wet64
    // FORi $i #64 @.l38
    // .e37: NOOP
    // .e36: ADRL %0 $seed *0
    // COPY $voiceDataPointer %0 *VOICE_STATE_SIZE
    // MOVf $envReturn $env
    // RETU
}

function init()
locals int i, float p
{
    // PARA *1
    // MOVp %1 &.s_initd7e336d5
    trace();
    // MOVf $p #0.0
    i = 0;
    if (condition) {
    // .l1: MOVf %1 $p
    sin();
    // Write to &sinTable
    // ! DIVf <A> #TWICE_PI #SIN_TABLE_SIZE_FLOAT
    // ADDf $p $p <A>
    // FORi $i #SIN_TABLE_SIZE @.l1
    // .e0: NOOP
    // ! DIVf <A> #11579.0 #44100.0
    // fTOi %1 <A> #SR
    %2 = 2000;
    %3 = 32000;
    setupVerb();
    // RETU
}

function reset()
locals int i, pointer p
{
    // PARA *1
    // MOVp %1 &.s_resetd7e336d6
    trace();
    // MOVp $p &verbLine
    i = 0;
    // ! DIVi <A> #VERB_DL_SIZE #8
    if (condition) {
    // .l1: POKE $p #0 #0.0
    // Write to $p
    // Write to $p
    // Write to $p
    // Write to $p
    // Write to $p
    // Write to $p
    // Write to $p
    // ADDp $p $p #8
    // FORi $i <A> @.l1
    // .e0: MOVi $i #0
    // ! MULi <A> #VOICE_COUNT #VOICE_STATE_SIZE
    if (condition) {
    // .l3: POKE &voiceData $i #0
    // FORi $i <A> @.l3
    // .e2: POKE &songPos #0
    // RETU
}

function process()
locals float voiceL64, float voiceR64, float wet64, int i, int j, float sumL64, float sumR64, float sumWet64, float verbL64, float verbR64, int lengthBits, int spacingBits, int modulationBits, int reverbBits, int pitchBits, int muteBits, int dirXor, float lrPair, float env, int muteBit, int muteLeds, int op1Mode, int op2Mode, int clock, int x, float y, int measure, int songPos, int loopedPos, int reseedMask, float params, float reverbDamping
{
    // PARA *1
    loopedPos = 0;
    // DIVf %1 #5000.0 #SR
    singlePoleKApprox();
    // MOVf $reverbDamping %0
    // MOVf %1 $reverbDamping
    // MOVf %2 #0.01
    // MOVf %3 #0.49
    clampFloat();
    // MOVf $reverbDamping %0
    // .l0: ADRL %0 $params *0
    // COPY %0 &params *PARAM_COUNT
    // ANDi $lengthBits $params:OPERAND_2_HIGH_PARAM_INDEX #15
    // SHRi %0 $params:OPERAND_2_HIGH_PARAM_INDEX #4
    // ANDi $spacingBits %0 #15
    // ANDi $reverbBits $params:OPERAND_1_LOW_PARAM_INDEX #15
    // ANDi $modulationBits $params:OPERAND_2_LOW_PARAM_INDEX #15
    // SHRi %0 $params:OPERAND_2_LOW_PARAM_INDEX #4
    // ANDi $pitchBits %0 #15
    // SHRi %0 $params:OPERAND_1_LOW_PARAM_INDEX #4
    // ANDi $muteBits %0 #15
    op1Mode = params:OPERATOR_1_PARAM_INDEX;
    op2Mode = params:OPERATOR_2_PARAM_INDEX;
    reseedMask = 0;
    // LSSi $op2Mode #1 @.f2
    // NEQi $op1Mode #CYCLING_MODE @.f2
    // SUBi %0 $op2Mode #1
    // SHLi %0 #512 %0
    // SUBi %0 %0 #1
    // XORi $reseedMask %0 #-1
    // .f2: NEQi $op2Mode #0 @.f4
    // Read from &lastSeed
    // EQUi $params:OPERAND_1_HIGH_PARAM_INDEX %0 @.f4
    // ! XORi <A> #1023 #-1
    reseedMask = <A>;
    // .f4: PEEK $songPos &songPos
    // NEQi $op1Mode #OFF_MODE @.f5
    loopedPos = -1;
    // GOTO @.e6
    // .f5: ANDi %0 $params:SWITCHES_PARAM_INDEX #SWITCHES_SYNC_MASK
    // NEQi %0 #0 @.f7
    // ADDi $songPos $songPos #1
    loopedPos = songPos;
    // GOTO @.e8
    // .f7: PEEK %0 &hostPosition
    if (condition) {
    loopedPos = -1;
    // GOTO @.e10
    // .f9: PEEK $songPos &clock
    // ANDi %0 $params:SWITCHES_PARAM_INDEX #SWITCHES_REVERSE_MASK
    if (condition == 0) {
    // XORi $songPos $songPos #0xFFFF
    // .f11: PEEK %0 &hostPosition
    // SHLi %1 $songPos #16
    // ! MULi <A> #HOST_POSITION_PPQ #2
    // SHRi %1 %1 #31
    // ADDi %0 %0 #HOST_POSITION_PPQ
    // MULi %1 <A> %1
    // ADDi %0 %0 %1
    // ! MULi <A> #HOST_POSITION_PPQ #4
    // DIVi $measure %0 <A>
    // SHLi %0 $measure #10
    // SHRu %1 $songPos #6
    // IORi $songPos %0 %1
    loopedPos = songPos;
    // .e10: NOOP
    // .e8: NOOP
    // .e6: POKE &songPos $songPos
    // LSSi $loopedPos #0 @.f14
    // LSSi $op2Mode #0 @.f14
    // EQUi $op1Mode #UNALIGNED_MODE @.t13
    // EQUi $op1Mode #ALIGNED_MODE @.t13
    // NEQi $op1Mode #UNIFORM_MODE @.f14
    // .t13: SUBi %0 $op2Mode #1
    // SHLi %0 #512 %0
    // SUBi %0 %0 #1
    // ANDi $loopedPos $loopedPos %0
    // .f14: MOVi $j #0
    if (condition) {
    // .l16: SETL $sumL64 $j #0.0
    // SETL $sumR64 $j #0.0
    // SETL $sumWet64 $j #0.0
    // FORi $j #64 @.l16
    // .e15: POKE &spaceLeds #0
    // Write to &lengthLeds
    // Write to &pitchLeds
    // Write to &modulationLeds
    // Write to &reverbLeds
    // Write to &isChasing
    muteLeds = 0;
    i = 0;
    if (condition) {
    // .l18: SHRi %0 $i #1
    // SHLi $muteBit #1 %0
    // MOVf $env #0.0
    // ANDi %0 $muteBits $muteBit
    // NEQi %0 #0 @.f19
    // ADDi %1 #12934913 $i
    // MULi %2 $i #VOICE_STATE_SIZE
    // ADDp %2 &voiceData %2
    %3 = lengthBits;
    %4 = spacingBits;
    %5 = modulationBits;
    %6 = reverbBits;
    %7 = pitchBits;
    // ADRL %8 $voiceL64 *0
    // ADRL %9 $voiceR64 *0
    // ADRL %10 $wet64 *0
    %11 = loopedPos;
    %12 = reseedMask;
    renderVoice();
    // MOVf $env %0
    // LEQf $env #0.1 @.f20
    // IORi $muteLeds $muteLeds $muteBit
    // .f20: MOVi $j #0
    if (condition) {
    // .l22: GETL %0 $sumL64 $j
    // GETL %1 $voiceL64 $j
    // ADDf %0 %0 %1
    // SETL $sumL64 $j %0
    // GETL %0 $sumR64 $j
    // GETL %1 $voiceR64 $j
    // ADDf %0 %0 %1
    // SETL $sumR64 $j %0
    // GETL %0 $sumWet64 $j
    // GETL %1 $wet64 $j
    // ADDf %0 %0 %1
    // SETL $sumWet64 $j %0
    // FORi $j #64 @.l22
    // .f19: FORi $i #VOICE_COUNT @.l18
    // .e17: PEEK %0 &isChasing
    // EQUi %0 #FALSE @.f23
    // Read from &clock
    // SHRu %0 %0 #11
    // ANDi %0 %0 #7
    // SHRu %0 #128 %0
    // Write to &displayLEDs:3
    // Write to &displayLEDs:2
    // Write to &displayLEDs:1
    // Write to &displayLEDs:0
    // GOTO @.e24
    // .f23: PEEK %0 &lastSeed
    // Write to &displayLEDs:0
    // SHLi %0 $muteLeds #4
    // Read from &reverbLeds
    // IORi %0 %0 %1
    // Write to &displayLEDs:1
    // Read from &spaceLeds
    // SHLi %0 %0 #4
    // Read from &lengthLeds
    // IORi %0 %0 %1
    // Write to &displayLEDs:2
    // Read from &pitchLeds
    // SHLi %0 %0 #4
    // Read from &modulationLeds
    // IORi %0 %0 %1
    // Write to &displayLEDs:3
    // .e24: ADRL %1 $sumWet64 *0
    // MOVf %2 #0.5
    // MOVf %3 $reverbDamping
    // ADRL %4 $verbL64 *0
    // ADRL %5 $verbR64 *0
    processVerb();
    j = 0;
    if (condition) {
    // .l26: ADRL %0 $lrPair *0
    // COPY %0 &signal *2
    // GETL %0 $sumL64 $j
    // GETL %1 $verbL64 $j
    // ADDf %0 %0 %1
    // fTOi %0 %0 #2047.0
    // ADDi $lrPair:0 $lrPair:0 %0
    // GETL %0 $sumR64 $j
    // GETL %1 $verbR64 $j
    // ADDf %0 %0 %1
    // fTOi %0 %0 #2047.0
    // ADDi $lrPair:1 $lrPair:1 %0
    // Read from &clock
    %2 = 1;
    // ADRL %3 $lrPair *0
    write();
    // Read from &clock
    // SUBi %1 %1 #1
    %2 = 1;
    // MOVp %3 &signal
    read();
    yield();
    // FORi $j #64 @.l26
    // continue loop
    // RETU
}
