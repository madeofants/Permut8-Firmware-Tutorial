/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
const int FALSE = 0
const int TRUE = 1
const float XOR_SHIFT_RANDOM_TO_FLOAT_FACTOR = 4.6566128730774e-10
const int MAX_TAP_COUNT = 16
const int PAN_LEFT_BIT = 7
const int PAN_RIGHT_BIT = 6
const int VOL_DEC_BIT = 5
const int VOL_INC_BIT = 4
const int ACCELERATE_BIT = 3
const int DEACCELERATE_BIT = 2
const int RANDOM_BIT = 1
const int RECTIFIER_BIT = 0
const float VOL_DEC_FACTOR = 0.70710678118655
const float VOL_INC_FACTOR = 1.414213562373
const float TIME_DEC_FACTOR = 0.70710678118655
const float TIME_INC_FACTOR = 1.414213562373
const float PAN_ATTENUATE = 0.25
const int BATCH_SIZE = 64
const int TAP_BITS = 0
const int TAP_DELAY = 1
const int TAP_LEFT_GAIN = 2
const int TAP_RIGHT_GAIN = 3
const int TAP_STRUCT_SIZE = 4

global int clock = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int instance = 0
global int clockFreqLimit = 88200
global array signal[2]
global int xorShiftRandomSeedX = 123456789
global int xorShiftRandomSeedY = 362436069
global int tapCount = 0
global array tapData[<A>]
global array temp[2]
global array buffer[<A>]

function xorShiftRandom()
locals int x, int t
{
    // Read from &xorShiftRandomSeedX
    // Read from &xorShiftRandomSeedY
    // SHLi %0 $x #10
    // XORi $t $x %0
    x = y;
    // SHRu %0 $y #13
    // XORi %0 $y %0
    // XORi %0 %0 $t
    // SHRu %1 $t #10
    // XORi $y %0 %1
    // Write to &xorShiftRandomSeedX
    // Write to &xorShiftRandomSeedY
    // RETU
}

function init()
{
    // PARA *1
    // RETU
}

function reset()
{
    // PARA *1
    // RETU
}

function maxi()
{
    y = a;
    if (condition) {
    y = b;
    // .f0: RETU
}

function calcGainsAndDelays()
locals float g, float d, int i
{
    // PARA *1
    // MOVf $g $initGain
    // MOVf $d $initDelay
    i = 0;
    if (condition) {
    // .l1: SHRi %0 #0x80 $i
    // ANDi %0 $stepBits %0
    if (condition == 0) {
    // ! SHLi <A> #1 #VOL_INC_BIT
    // ANDi %0 $configBits <A>
    if (condition == 0) {
    // MULf $g $g #VOL_INC_FACTOR
    // .f3: NOOP
    // ! SHLi <A> #1 #VOL_DEC_BIT
    // ANDi %0 $configBits <A>
    if (condition == 0) {
    // MULf $g $g #VOL_DEC_FACTOR
    // .f4: NOOP
    // ! SHLi <A> #1 #ACCELERATE_BIT
    // ANDi %0 $configBits <A>
    if (condition == 0) {
    // MULf $d $d #TIME_DEC_FACTOR
    // .f5: NOOP
    // ! SHLi <A> #1 #DEACCELERATE_BIT
    // ANDi %0 $configBits <A>
    if (condition == 0) {
    // MULf $d $d #TIME_INC_FACTOR
    // .f2: PEEK %0 $maxGain
    // LEQf $g %0 @.f7
    // Write to $maxGain
    // .f7: PEEK %0 $maxDelay
    // LEQf $d %0 @.f8
    // Write to $maxDelay
    // .f8: POKE $gains $i $g
    // Write to $delays
    // FORi $i #8 @.l1
    // .e0: POKE $endGain $g
    // Write to $endDelay
    // RETU
}

function addTaps()
locals float g, float d, int i, float lg, float rg, float r, pointer p
{
    // MOVf $o $offset
    // Read from &tapCount
    // MULi %0 %0 #TAP_STRUCT_SIZE
    // ADDp $p &tapData %0
    i = 0;
    if (condition) {
    // .l1: PEEK %0 $gains $i
    // MULf $g %0 $gainScale
    // Read from $delays
    // MULf $d %0 $delayScale
    // SHRi %0 #0x80 $i
    // ANDi %0 $stepBits %0
    if (condition == 0) {
    // MOVf $lg $g
    // MOVf $rg $g
    // ! SHLi <A> #1 #PAN_LEFT_BIT
    // ANDi %0 $configBits <A>
    // NEQi %0 #0 @.f3
    // MULf $lg $lg #PAN_ATTENUATE
    // .f3: NOOP
    // ! SHLi <A> #1 #PAN_RIGHT_BIT
    // ANDi %0 $configBits <A>
    // NEQi %0 #0 @.f4
    // MULf $rg $rg #PAN_ATTENUATE
    // .f4: MOVf $r #0.0
    // ! SHLi <A> #1 #RANDOM_BIT
    // ANDi %0 $configBits <A>
    if (condition == 0) {
    xorShiftRandom();
    // ! DIVf <A> #1.0 #12.0
    // ! MULf <A> #XOR_SHIFT_RANDOM_TO_FLOAT_FACTOR <A>
    // iTOf %0 %0 <A>
    // MULf $r %0 $d
    // .f5: ADDi %0 $i $firstStep
    // SHRu %0 #0x80000000 %0
    // IORi %0 $configBits %0
    // Write to $p
    // ADDf %1 $o $r
    // fTOi %1 %1 #1.0
    // SUBi %1 %1 #BATCH_SIZE
    %2 = 0;
    maxi();
    // Write to $p
    // fTOi %0 $lg #1.0
    // Write to $p
    // fTOi %0 $rg #1.0
    // Write to $p
    // ADDp $p $p #TAP_STRUCT_SIZE
    // Read from &tapCount
    // ADDi %0 %0 #1
    // Write to &tapCount
    // .f2: ADDf $o $o $d
    // FORi $i #8 @.l1
    // .e0: RETU
}

function update()
locals float localParams, int i, int v, int rebuild, float stepLength1, float stepLength2, float offset, float gains, float delays, float maxGain1, float maxDelay1, float maxGain2, float maxDelay2, float endGain, float endDelay
{
    // PARA *1
    // ADRL %0 $localParams *0
    // COPY %0 &params *PARAM_COUNT
    // Write to &tapCount
    // Write to &xorShiftRandomSeedX
    // Write to &xorShiftRandomSeedY
    // ! DIVf <A> #65536.0 #8.0
    // MOVf $stepLength1 <A>
    // MOVf $maxGain1 #0.00001
    // MOVf $maxDelay1 #0.00001
    if (condition) {
    // ADDi %0 #2 $localParams:OPERATOR_1_PARAM_INDEX
    // SHRi %0 #65536 %0
    // iTOf $stepLength1 %0 #1.0
    %1 = localParams:OPERAND_1_LOW_PARAM_INDEX;
    %2 = localParams:OPERAND_1_HIGH_PARAM_INDEX;
    // MOVf %3 #1.0
    // MOVf %4 #1.0
    // ADRL %5 $gains *0
    // ADRL %6 $delays *0
    // ADRL %7 $maxGain1 *0
    // ADRL %8 $maxDelay1 *0
    // ADRL %9 $endGain *0
    // ADRL %10 $endDelay *0
    calcGainsAndDelays();
    // .f0: MOVf $stepLength2 $stepLength1
    // MOVf $offset #0.0
    // SWCH $localParams:OPERATOR_2_PARAM_INDEX *5 @.s1
    // .s1#0: GOTO @noSecond
    // GOTO @.e2
    // .s1#1: GOTO @.e2
    // .s1#2: MULf $stepLength2 $stepLength2 #0.5
    // GOTO @.e2
    // .s1#3: MULf $offset $stepLength2 #0.5
    // GOTO @.e2
    // .s1#4: MOVi %1 $localParams:OPERAND_2_LOW_PARAM_INDEX
    %2 = localParams:OPERAND_2_HIGH_PARAM_INDEX;
    // MOVf %3 $endGain
    // MOVf %4 $endDelay
    // ADRL %5 $gains:8 *0
    // ADRL %6 $delays:8 *0
    // ADRL %7 $maxGain1 *0
    // ADRL %8 $maxDelay1 *0
    // ADRL %9 $endGain *0
    // ADRL %10 $endDelay *0
    calcGainsAndDelays();
    %1 = localParams:OPERATOR_1_PARAM_INDEX;
    %2 = localParams:OPERAND_1_LOW_PARAM_INDEX;
    %3 = localParams:OPERAND_1_HIGH_PARAM_INDEX;
    // MOVf %4 #0.0
    // ADRL %5 $gains *0
    // ADRL %6 $delays *0
    // DIVf %7 #256.0 $maxGain1
    // DIVf %8 $stepLength1 $maxDelay1
    %9 = 0;
    addTaps();
    // MOVf $offset %0
    %1 = localParams:OPERATOR_2_PARAM_INDEX;
    %2 = localParams:OPERAND_2_LOW_PARAM_INDEX;
    %3 = localParams:OPERAND_2_HIGH_PARAM_INDEX;
    // MOVf %4 $offset
    // ADRL %5 $gains:8 *0
    // ADRL %6 $delays:8 *0
    // DIVf %7 #256.0 $maxGain1
    // DIVf %8 $stepLength2 $maxDelay1
    %9 = 8;
    addTaps();
    // GOTO @done
    // .s1: NOOP
    // .e2: MOVf $maxGain2 #0.00001
    // MOVf $maxDelay2 #0.00001
    %1 = localParams:OPERAND_2_LOW_PARAM_INDEX;
    %2 = localParams:OPERAND_2_HIGH_PARAM_INDEX;
    // MOVf %3 #1.0
    // MOVf %4 #1.0
    // ADRL %5 $gains:8 *0
    // ADRL %6 $delays:8 *0
    // ADRL %7 $maxGain2 *0
    // ADRL %8 $maxDelay2 *0
    // ADRL %9 $endGain *0
    // ADRL %10 $endDelay *0
    calcGainsAndDelays();
    %1 = localParams:OPERATOR_2_PARAM_INDEX;
    %2 = localParams:OPERAND_2_LOW_PARAM_INDEX;
    %3 = localParams:OPERAND_2_HIGH_PARAM_INDEX;
    // MOVf %4 $offset
    // ADRL %5 $gains:8 *0
    // ADRL %6 $delays:8 *0
    // DIVf %7 #256.0 $maxGain2
    // DIVf %8 $stepLength2 $maxDelay2
    %9 = 8;
    addTaps();
    // noSecond: LEQi $localParams:OPERATOR_1_PARAM_INDEX #0 @.f3
    %1 = localParams:OPERATOR_1_PARAM_INDEX;
    %2 = localParams:OPERAND_1_LOW_PARAM_INDEX;
    %3 = localParams:OPERAND_1_HIGH_PARAM_INDEX;
    // MOVf %4 #0.0
    // ADRL %5 $gains *0
    // ADRL %6 $delays *0
    // DIVf %7 #256.0 $maxGain1
    // DIVf %8 $stepLength1 $maxDelay1
    %9 = 0;
    addTaps();
    // .f3: NOOP
    // done: RETU
    // temp: GLOB *2
    // ! MULi <A> #BATCH_SIZE #2
    // buffer: GLOB *<A>
}

function process()
locals float tapData, int i, int clock, int l, int r, pointer p, pointer bp, int bi, float tapped, pointer tp, int ledBits, int dir
{
    // PARA *1
    // ! MULi <A> #BATCH_SIZE #2
    // .l0: MOVi $ledBits #0
    // MOVp $bp &buffer
    dir = 2;
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi %0 %0 #SWITCHES_REVERSE_MASK
    if (condition == 0) {
    // ! MULi <A> #BATCH_SIZE #2
    // ! SUBi <A> <A> #2
    // ADDp $bp $bp <A>
    dir = -2;
    // .f1: MOVi $bi #0
    if (condition) {
    // .l3: COPY &temp &signal *2
    // COPY &signal $bp *2
    // COPY $bp &temp *2
    // ADDp $bp $bp $dir
    yield();
    // FORi $bi #BATCH_SIZE @.l3
    // .e2: PEEK %0 &clock
    // SUBi $clock %0 #BATCH_SIZE
    %1 = clock;
    %2 = BATCH_SIZE;
    // MOVp %3 &buffer
    write();
    // MOVp $bp &buffer
    // ! MULi <A> #BATCH_SIZE #2
    // ADDp %0 &buffer <A>
    // GEQp &buffer %0 @.e4
    // .l5: POKE $bp #0
    // FORp $bp %0 @.l5
    // .e4: MOVp $p &tapData
    i = 0;
    // Read from &tapCount
    if (condition) {
    // .l7: MOVp $bp &buffer
    // ADRL %1 $tapData *0
    // COPY %1 $p *TAP_STRUCT_SIZE
    // SUBi %2 $clock $tapData:TAP_DELAY
    %3 = BATCH_SIZE;
    // ADRL %4 $tapped *0
    read();
    // ! SHLi <A> #1 #RECTIFIER_BIT
    // ANDi %1 $tapData:TAP_BITS <A>
    // EQUi %1 #0 @.f8
    // ADRL $tp $tapped *0
    bi = 0;
    // ! DIVi <A> #BATCH_SIZE #2
    if (condition) {
    // .l10: PEEK %1 $tp
    // ABSi $l %1
    // SHRi %1 $l #1
    // ADDi %1 $l %1
    // Write to $tp
    // Read from $tp
    // ABSi $r %1
    // SHRi %1 $r #1
    // ADDi %1 $r %1
    // Write to $tp
    // Read from $tp
    // ABSi $l %1
    // SHRi %1 $l #1
    // ADDi %1 $l %1
    // Write to $tp
    // Read from $tp
    // ABSi $r %1
    // SHRi %1 $r #1
    // ADDi %1 $r %1
    // Write to $tp
    // ADDp $tp $tp #4
    // FORi $bi <A> @.l10
    // .f8: MOVi $l $tapData:TAP_LEFT_GAIN
    r = tapData:TAP_RIGHT_GAIN;
    // ADRL $tp $tapped *0
    // Read from $tp
    // ABSi %1 %1
    if (condition) {
    // SHRi %1 $tapData:TAP_BITS #16
    // IORi $ledBits $ledBits %1
    // .f11: MOVi $bi #0
    // ! DIVi <A> #BATCH_SIZE #2
    if (condition) {
    // .l13: PEEK %1 $tp
    // Read from $bp
    // MULi %1 %1 $l
    // ADDi %2 %2 %1
    // Write to $bp
    // Read from $tp
    // Read from $bp
    // MULi %2 %2 $r
    // ADDi %1 %1 %2
    // Write to $bp
    // Read from $tp
    // Read from $bp
    // MULi %1 %1 $l
    // ADDi %2 %2 %1
    // Write to $bp
    // Read from $tp
    // Read from $bp
    // MULi %2 %2 $r
    // ADDi %1 %1 %2
    // Write to $bp
    // ADDp $bp $bp #4
    // ADDp $tp $tp #4
    // FORi $bi <A> @.l13
    // .e12: ADDp $p $p #TAP_STRUCT_SIZE
    // FORi $i %0 @.l7
    // .e6: MOVp $bp &buffer
    // ! MULi <A> #BATCH_SIZE #2
    // ADDp %0 &buffer <A>
    // GEQp &buffer %0 @.e14
    // .l15: PEEK %1 $bp
    // SHRi %1 %1 #8
    // Write to $bp
    // FORp $bp %0 @.l15
    // .e14: PEEK %0 &params:OPERAND_1_HIGH_PARAM_INDEX
    // SHRi %1 $ledBits #8
    // ANDi %0 %0 %1
    // Write to &displayLEDs:0
    // Read from &params:OPERAND_2_HIGH_PARAM_INDEX
    // ANDi %0 %0 $ledBits
    // Write to &displayLEDs:2
    // continue loop
    // RETU
}
