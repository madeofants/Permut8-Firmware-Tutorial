/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
const int FALSE = 0
const int TRUE = 1
const float LOG2 = 0.69314718055994530942
const float LOG2R = 1.44269504088896340736
const float LOG10R = 0.43429448190325182765
const float E = 2.71828182845904523536
const float HALF_PI = 1.57079632679489661923
const float PI = 3.14159265358979323846
const float COS_EPSILON = 1.0e-6
const int CURVE_SIZE_BITS = 4
const int NO_SHAPER = 0
const int LINEAR_SHAPER = 1
const int QUADRATIC_SHAPER = 2
const int SHAPER_COUNT = 3
const int BIT_CRUSH = 1
const int SINE_SHAPE = 2
const int SPIN = 3
const int STEREO_DELAY = 4

global int clock = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int clockFreqLimit = 132300
global array signal[2]
global array sinTable[0x1000]
global array linCurveA[CURVE_SIZE]
global array linCurveB[CURVE_SIZE]
global array quadCurveA[CURVE_SIZE_PLUS_1]
global array quadCurveB[CURVE_SIZE_PLUS_1]
global array quadCurveC[CURVE_SIZE_PLUS_1]
global int op1 = -1
global int shaper = 0
global int op1Stuff = 0
global int spinXOrR = 0
global int biasL = 0
global int biasR = 0
global int delayL = 0
global int delayR = 0
global int lastOp1Param = -1
global int lastOp2 = -1
global int lastShaperBits = -1

function error()
{
    // PARA *1
    // MOVp %1 $s
    trace();
    abort();
    // RETU
}

function trunc()
{
    // GEQf $x #0.0 @.f0
    // SUBf %0 #0.0 $x
    // FLOf %0 %0
    // SUBf $y #0.0 %0
    // GOTO @.e1
    // .f0: FLOf $y $x
    // .e1: RETU
    // 
    // 
}

function fmod()
{
    // NEQf $y #0.0 @.f0
    // MOVp %1 &.s_Divisi3482a96
    error();
    // GOTO @.e1
    // .f0: DIVf %1 $x $y
    trunc();
    // MULf %0 %0 $y
    // SUBf $z $x %0
    // .e1: RETU
    // 
    // 
}

function cos()
locals float a, float n, float m, float t
{
    // MOVf %1 $x
    // MOVf %2 #TWICE_PI
    fmod();
    // MOVf $m %0
    // SUBf %0 #0.0 $m
    // MULf $m %0 $m
    // MOVf $y #1.0
    // MOVf $n #1.0
    // MOVf $a #1.0
    // .l0: MOVf $t $y
    // MULf %0 $n $n
    // MULf %1 $a $m
    // ADDf %0 %0 $n
    // DIVf $a %1 %0
    // ADDf $y $y $a
    // ADDf $n $n #2.0
    // NEQf $y $t @.l0
    // ABSf %1 $y
    // GEQf %1 #COS_EPSILON @.f1
    // MOVf $y #0.0
    // .f1: RETU
    // 
    // 
}

function sin()
{
    // SUBf %1 $x #HALF_PI
    cos();
    // MOVf $y %0
    // RETU
}

function init()
locals int i, int s
{
    // PARA *1
    i = 0;
    if (condition) {
    // .l1: NOOP
    // ! MULf <A> #2.0 #PI
    // ! DIVf <A> <A> #4096.0
    // iTOf %1 $i <A>
    sin();
    // ! iTOf <A> #0x800 #1.0
    // MULf %0 <A> %0
    // ADDf %0 #0.5 %0
    // FLOf %0 %0
    // fTOi $s %0 #1.0
    if (condition) {
    s = -0x7FF;
    // GOTO @.e3
    // .f2: LEQi $s #0x7FF @.f4
    s = 0x7FF;
    // .f4: NOOP
    // .e3: POKE &sinTable $i $s
    // FORi $i #0x1000 @.l1
    // .e0: RETU
    // 
    // 
}

function update()
locals float params, float quadPoints, int v, int mask, int d, int i, int shaperBits, int shelf, int op1, int op2, int op1Param, int stereoBit, int t, float a, float b, float c
{
    // PARA *1
    // ! ADDi <A> #CURVE_SIZE_PLUS_1 #3
    // ADRL %0 $params *0
    // COPY %0 &params *PARAM_COUNT
    op1 = params:OPERATOR_1_PARAM_INDEX;
    op1Param = params:OPERAND_1_HIGH_PARAM_INDEX;
    // Read from &op1
    // NEQi %0 $op1 @.t0
    // Read from &lastOp1Param
    // EQUi %0 $op1Param @.f1
    // .t0: POKE &op1 $op1
    // Write to &lastOp1Param
    // ANDi $stereoBit $op1Param #0x80
    // SWCH $op1 *5 @.s2
    // .s2#BIT_CRUSH: ANDi %0 $op1Param #0x7F
    // SHLi $t %0 #3
    // ANDi %0 $op1Param #0x1
    if (condition == 0) {
    // IORi $t $t #0x07
    // .f4: POKE &op1Stuff $t
    // ! SUBi <A> #10 #3
    // ! SUBi <A> <A> #1
    // ! SHLi <A> #1 <A>
    // ADDi %0 $t <A>
    // ! SUBi <A> #10 #3
    // ! XORi <B> #0 #-1
    // SHRu %0 %0 <A>
    // SHLi %0 <B> %0
    // XORi %0 %0 #-1
    // Write to &displayLEDs:0
    // EQUi $stereoBit #0 @.f5
    // Write to &biasL
    // Write to &biasR
    // GOTO @.e3
    // .f5: SHRi $t $t #1
    // Write to &biasL
    // Write to &biasR
    // .e6: GOTO @.e3
    // .s2#SINE_SHAPE: ANDi %0 $op1Param #0x7F
    // ADDi $t %0 #1
    // Write to &op1Stuff
    // SHLi %0 $stereoBit #2
    // Write to &biasL
    // ! SUBi <B> #7 #3
    // ! SUBi <B> <B> #1
    // ! SHLi <B> #1 <B>
    // ADDi %0 $t <B>
    // ! SUBi <B> #7 #3
    // ! XORi <A> #0 #-1
    // SHRu %0 %0 <B>
    // SHLi %0 <A> %0
    // XORi %0 %0 #-1
    // Write to &displayLEDs:0
    // GOTO @.e3
    // .s2#SPIN: ANDi %0 $op1Param #0x7F
    // Write to &op1Stuff
    // Write to &spinXOrR
    // EQUi $stereoBit #0 @.f7
    // Write to &spinXOrR
    // .f7: POKE &displayLEDs:0 #0
    // GOTO @.e3
    // .s2#STEREO_DELAY: PEEK %0 &EIGHT_BIT_EXP_TABLE $op1Param
    // Write to &delayL
    // ! SUBi <A> #8 #3
    // SHRi %0 $op1Param <A>
    // SHLi %0 #0x1 %0
    // Write to &displayLEDs:0
    // .s2: NOOP
    // .e3: NOOP
    // .f1: PEEK %0 &EIGHT_BIT_EXP_TABLE $params:OPERAND_1_LOW_PARAM_INDEX
    // Write to &delayR
    // ! SUBi <A> #8 #3
    // SHRi %0 $params:OPERAND_1_LOW_PARAM_INDEX <A>
    // SHLi %0 #0x1 %0
    // Write to &displayLEDs:1
    op2 = params:OPERATOR_2_PARAM_INDEX;
    // SHLi %0 $params:OPERAND_2_HIGH_PARAM_INDEX #8
    // IORi $shaperBits %0 $params:OPERAND_2_LOW_PARAM_INDEX
    // Read from &lastOp2
    // NEQi %0 $op2 @.t8
    // Read from &lastShaperBits
    // EQUi %0 $shaperBits @.f9
    // .t8: POKE &lastOp2 $op2
    // Write to &lastShaperBits
    // Read from &OPERATOR_SHAPERS
    // Write to &shaper
    // ANDi $shelf $op2 #1
    v = 0;
    mask = 0x10000;
    i = 0;
    if (condition) {
    // .l11: SHRu $mask $mask #1
    // Write to &linCurveA
    d = 0;
    // ANDi %0 $shaperBits $mask
    // NEQi %0 #0 @.f12
    d = CURVE_STEP_SIZE;
    // GOTO @.e13
    // .f12: NEQi $shelf #0 @.f14
    // ! SUBi <A> #0 #CURVE_STEP_SIZE
    d = <A>;
    // .f14: NOOP
    // .e13: POKE &linCurveB $i $d
    // ADDi $v $v $d
    // FORi $i #CURVE_SIZE @.l11
    // .e10: NOOP
    // ! DIVi <A> #CURVE_SIZE #2
    // Read from &linCurveA:<A>
    i = 0;
    if (condition) {
    // .l16: PEEK %0 &linCurveA $i
    // SUBi %0 %0 $d
    // Write to &linCurveA
    // ADDi %0 $i #1
    // Read from &linCurveA
    // iTOf %1 %1 #1.0
    // SETL $quadPoints %0 %1
    // FORi $i #CURVE_SIZE @.l16
    // .e15: NOOP
    // ! SUBi <A> #CURVE_SIZE #1
    // ! SUBi <B> #CURVE_SIZE #1
    // Read from &linCurveA:<A>
    // Read from &linCurveB:<B>
    // ADDi %1 %1 %0
    // iTOf $quadPoints:CURVE_SIZE_PLUS_1 %1 #1.0
    // ! ADDi <B> #CURVE_SIZE #2
    // MOVf $quadPoints:<B> $quadPoints:CURVE_SIZE_PLUS_1
    // Read from &linCurveA:0
    // iTOf $quadPoints:0 %1 #1.0
    // MOVf $quadPoints:1 $quadPoints:0
    i = 0;
    if (condition) {
    // .l18: GETL $a $quadPoints $i
    // ADDi %1 $i #1
    // GETL $b $quadPoints %1
    // ADDi %1 $i #2
    // GETL $c $quadPoints %1
    // ADDf %1 $a $b
    // MULf %1 #0.5 %1
    // Write to &quadCurveA
    // SUBf %1 $b $a
    // Write to &quadCurveB
    // MULf %1 #2.0 $b
    // SUBf %1 $a %1
    // ADDf %1 %1 $c
    // MULf %1 #0.5 %1
    // Write to &quadCurveC
    // FORi $i #CURVE_SIZE_PLUS_1 @.l18
    // .f9: RETU
    // 
    // 
}

function process()
locals float localSignal, int left, int right, int localClock, int xl, int xr, int il, int ir, int tmp, float pl, float pr, int peak, int dip, int spinner, int innerLoopIndex, int localOp1, int localOp1Stuff, int localShaper, int localDelayL, int localDelayR, int localBiasL, int localBiasR, int localSpinXOrR, int clockDir
{
    // PARA *1
    peak = 0;
    dip = 0;
    spinner = 0;
    localClock = 0;
    // .l0: PEEK $localOp1 &op1
    // Read from &op1Stuff
    // Read from &shaper
    // Read from &delayL
    // Read from &delayR
    // Read from &biasL
    // Read from &biasR
    // Read from &spinXOrR
    clockDir = 1;
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi %1 %1 #SWITCHES_REVERSE_MASK
    // EQUi %1 #0 @.f1
    clockDir = -1;
    // .f1: PEEK %1 &params:SWITCHES_PARAM_INDEX
    // ANDi %1 %1 #SWITCHES_SYNC_MASK
    // EQUi %1 #0 @.f2
    // Read from &clock
    // EQUi $tmp $localClock @.f2
    localClock = tmp;
    // MULi $spinner $localClock $localOp1Stuff
    // .f2: SUBi %1 #0 $peak
    // SHRi %1 %1 #8
    // ADDi $peak $peak %1
    // SHRi %1 $dip #8
    // SUBi $dip $dip %1
    // ! SUBi <B> #10 #3
    // ! SHLi <B> #1 <B>
    // ADDi %1 $peak <B>
    // ! SUBi <B> #11 #3
    // SHRu %1 %1 <B>
    // SHRu %1 #0xFF %1
    // XORi %1 %1 #0xFF
    // Write to &displayLEDs:3
    // ! SUBi <B> #10 #3
    // SUBi %1 #0 $dip
    // ! SHLi <B> #1 <B>
    // ADDi %1 %1 <B>
    // ! SUBi <B> #11 #3
    // SHRu %1 %1 <B>
    // SHLi %1 #0xFF %1
    // XORi %1 %1 #0xFF
    // Write to &displayLEDs:2
    // NEQi $localOp1 #SPIN @.f4
    // SHRu $tmp $spinner #15
    // ANDi %1 $tmp #0x8
    // SHRu %1 %1 #3
    // SUBi %1 #0 %1
    // XORi %1 $tmp %1
    // ANDi $il %1 #0x7
    // ANDi %1 $localSpinXOrR #0x7
    // XORi $ir $il %1
    // SHRi %1 #0x80 $il
    // SHRi %0 #0x80 $ir
    // IORi %1 %1 %0
    // Write to &displayLEDs:0
    // .f4: MOVi $innerLoopIndex #0
    if (condition) {
    // .l6: PEEK $left &signal:0
    // Read from &signal:1
    localSignal:0 = left;
    localSignal:1 = right;
    %1 = localClock;
    %2 = 1;
    // ADRL %3 $localSignal *0
    write();
    // SUBi %1 $localClock $localDelayR
    %2 = 1;
    // ADRL %3 $localSignal *0
    read();
    left = localSignal:0;
    right = localSignal:1;
    // SWCH $localOp1 *5 @.s7
    // .s7#BIT_CRUSH: IORi %0 $left $localOp1Stuff
    // SUBi $left %0 $localBiasL
    // IORi %0 $right $localOp1Stuff
    // SUBi $right %0 $localBiasR
    // GOTO @.e8
    // .s7#SINE_SHAPE: MULi %0 $left $localOp1Stuff
    // SHRi %0 %0 #2
    // SUBi %0 %0 $localBiasL
    // ANDi %0 %0 #0xFFF
    // Read from &sinTable
    // MULi %0 $right $localOp1Stuff
    // SHRi %0 %0 #2
    // ADDi %0 %0 $localBiasL
    // ANDi %0 %0 #0xFFF
    // Read from &sinTable
    // GOTO @.e8
    // .s7#SPIN: SHRu $tmp $spinner #6
    // ADDi $il $left $tmp
    // XORi %0 $tmp $localSpinXOrR
    // ADDi $ir $right %0
    // ANDi %0 $il #0x1000
    // SHRu %0 %0 #12
    // SUBi %0 #0 %0
    // XORi %0 $il %0
    // ANDi %0 %0 #0xFFF
    // SUBi $left %0 #0x800
    // ANDi %0 $ir #0x1000
    // SHRu %0 %0 #12
    // SUBi %0 #0 %0
    // XORi %0 $ir %0
    // ANDi %0 %0 #0xFFF
    // SUBi $right %0 #0x800
    // ADDi $spinner $spinner $localOp1Stuff
    // GOTO @.e8
    // .s7#STEREO_DELAY: SUBi %1 $localClock $localDelayL
    %2 = 1;
    // ADRL %3 $localSignal *0
    read();
    left = localSignal:0;
    // .s7: NOOP
    // .e8: LEQi $left $peak @.f9
    peak = left;
    // .f9: GEQi $left $dip @.f10
    dip = left;
    // .f10: LEQi $right $peak @.f11
    peak = right;
    // .f11: GEQi $right $dip @.f12
    dip = right;
    // .f12: SWCH $localShaper *SHAPER_COUNT @.s13
    // .s13#LINEAR_SHAPER: ADDi $xl $left #0x800
    // ADDi $xr $right #0x800
    // SHRi $il $xl #CURVE_SHIFT
    // SHRi $ir $xr #CURVE_SHIFT
    // Read from &linCurveB
    // ANDi %1 $xl #CURVE_FRACTION_MASK
    // MULi %0 %0 %1
    // Read from &linCurveA
    // SHRi %0 %0 #CURVE_SHIFT
    // ADDi $left %1 %0
    // Read from &linCurveB
    // ANDi %0 $xr #CURVE_FRACTION_MASK
    // MULi %1 %1 %0
    // Read from &linCurveA
    // SHRi %1 %1 #CURVE_SHIFT
    // ADDi $right %0 %1
    // GOTO @.e14
    // .s13#QUADRATIC_SHAPER: NOOP
    // ! SUBi <B> #CURVE_SHIFT #1
    // ADDi %0 $left #0x800
    // ! SHLi <B> #1 <B>
    // ADDi $xl %0 <B>
    // ! SUBi <B> #CURVE_SHIFT #1
    // ADDi %0 $right #0x800
    // ! SHLi <B> #1 <B>
    // ADDi $xr %0 <B>
    // SHRi $il $xl #CURVE_SHIFT
    // SHRi $ir $xr #CURVE_SHIFT
    // ANDi %0 $xl #CURVE_FRACTION_MASK
    // iTOf $pl %0 #STEP_TO_FLOAT_SCALE
    // ANDi %0 $xr #CURVE_FRACTION_MASK
    // iTOf $pr %0 #STEP_TO_FLOAT_SCALE
    // Read from &quadCurveC
    // Read from &quadCurveB
    // MULf %0 %0 $pl
    // ADDf %1 %1 %0
    // Read from &quadCurveA
    // MULf %1 %1 $pl
    // ADDf %0 %0 %1
    // fTOi $left %0 #1.0
    // Read from &quadCurveC
    // Read from &quadCurveB
    // MULf %0 %0 $pr
    // ADDf %1 %1 %0
    // Read from &quadCurveA
    // MULf %1 %1 $pr
    // ADDf %0 %0 %1
    // fTOi $right %0 #1.0
    // .s13: NOOP
    // .e14: POKE &signal:0 $left
    // Write to &signal:1
    yield();
    // ADDi %0 $localClock $clockDir
    // ANDi $localClock %0 #0xFFFF
    // FORi $innerLoopIndex #64 @.l6
    // continue loop
    // RETU
}
