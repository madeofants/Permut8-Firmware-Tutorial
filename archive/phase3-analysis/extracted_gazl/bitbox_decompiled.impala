/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 3
const int FALSE = 0
const int TRUE = 1
const int SOUNDS_COUNT = 4
const int DRUM_COUNT = 3
const int DRUM_PARAM_COUNT = 8

global int clock = 0
global int hostPosition = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int clockFreqLimit = 132300
global array signal[2]
global array stepSounds[16]

function update()
locals int operand1Bits, int operand2Bits, float drumSounds, int step, int n, int i
{
    // PARA *1
    // Read from &params:OPERAND_1_HIGH_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_1_LOW_PARAM_INDEX
    // IORi $operand1Bits %0 %1
    // Read from &params:OPERAND_2_HIGH_PARAM_INDEX
    // SHLi %0 %0 #8
    // Read from &params:OPERAND_2_LOW_PARAM_INDEX
    // IORi $operand2Bits %0 %1
    // Read from &params:OPERATOR_1_PARAM_INDEX
    // Read from &params:OPERATOR_2_PARAM_INDEX
    // Read from &params:OPERATOR_2_PARAM_INDEX
    step = 0;
    if (condition) {
    // .l1: SHRi %0 $operand1Bits $step
    // SHRi %1 $operand2Bits $step
    // ANDi %1 %1 #0x1
    // ANDi %0 %0 #0x1
    // SHLi %1 %1 #1
    // IORi %0 %0 %1
    // SUBi $n %0 #1
    i = -1;
    // LSSi $n #0 @.f3
    // GETL %0 $drumSounds $n
    if (condition) {
    // GETL %0 $drumSounds $n
    // MULi %1 $n #SOUNDS_COUNT
    // SUBi %0 %0 #1
    // ADDi %1 %1 %0
    // MULi $i %1 #DRUM_PARAM_COUNT
    // .f3: SUBi %1 #15 $step
    // Write to &stepSounds
    // FORi $step #16 @.l1
    // .e0: RETU
}

function process()
locals int rnd, int rndXor, int rndAdd, int rndGain, int oscPhase, int oscRate, int oscDrop, int oscGain, int osc, int fadeRate, int y, int i, int lastStep, int step, int nextStep, int pump, int clock
{
    // PARA *1
    oscGain = 0;
    oscDrop = 0;
    oscRate = 0;
    oscPhase = 0;
    rndGain = 0;
    rndAdd = 0;
    rndXor = 0;
    rnd = 0;
    fadeRate = 0;
    lastStep = -1;
    pump = 0x1000;
    // .l0: MOVi $step #-1
    // Read from &params:SWITCHES_PARAM_INDEX
    // ANDi %1 %1 #SWITCHES_SYNC_MASK
    // EQUi %1 #0 @.t1
    // Read from &hostPosition
    // LSSi %1 #0 @.f2
    // .t1: PEEK $clock &clock
    // SHRi $step $clock #12
    // ADDi %1 $clock #1024
    // ANDi %1 %1 #65535
    // SHRi $nextStep %1 #12
    // EQUi $nextStep $step @.f2
    // Read from &stepSounds
    // LSSi %1 #0 @.f2
    fadeRate = 100;
    // .f2: EQUi $lastStep $step @.f5
    lastStep = step;
    if (condition) {
    // Write to &displayLEDs:0
    // Write to &displayLEDs:1
    // GOTO @.e7
    // .f6: SHRi %1 #0x80 $step
    // Write to &displayLEDs:2
    // Write to &displayLEDs:0
    // SHRi %1 #0x8000 $step
    // Write to &displayLEDs:3
    // Write to &displayLEDs:1
    // Read from &stepSounds
    // LSSi $i #0 @.f5
    // ADDi %1 $i #0
    // Read from &DRUM_PARAMS
    // ADDi %1 $i #1
    // Read from &DRUM_PARAMS
    // ADDi %1 $i #2
    // Read from &DRUM_PARAMS
    // ADDi %1 $i #3
    // Read from &DRUM_PARAMS
    // ADDi %1 $i #4
    // Read from &DRUM_PARAMS
    // ADDi %1 $i #5
    // Read from &DRUM_PARAMS
    // ADDi %1 $i #6
    // Read from &DRUM_PARAMS
    // ADDi %1 $i #7
    // Read from &DRUM_PARAMS
    oscPhase = 0x5000;
    pump = 0;
    // .e7: NOOP
    // .f5: MULi %1 $fadeRate #32
    // SUBi $rndGain $rndGain %1
    if (condition) {
    rndGain = 0;
    // .f9: SUBi $oscRate $oscRate $oscDrop
    if (condition) {
    oscRate = 0;
    // .f10: MOVi $i #0
    if (condition) {
    // .l12: SHLi %1 $rnd #1
    // SHRi %0 $rnd #15
    // IORi %1 %1 %0
    // XORi %1 %1 $rndXor
    // ADDi %1 %1 $rndAdd
    // ANDi $rnd %1 #0xFFFF
    // SHRu %1 $oscRate #8
    // ADDi %1 $oscPhase %1
    // ANDi $oscPhase %1 #0xFFFF
    if (condition) {
    // SUBi $osc #0xC000 $oscPhase
    // GOTO @.e14
    // .f13: SUBi $osc $oscPhase #0x4000
    // .e14: SHRi %1 $osc #4
    // MULi %1 %1 $oscGain
    // SUBi %0 $rnd #0x8000
    // SHRi %0 %0 #7
    // MULi %0 %0 $rndGain
    // SHRi %1 %1 #16
    // SHRi %0 %0 #16
    // ADDi %1 %1 %0
    // MULi $y %1 #2
    // SUBi $oscGain $oscGain $fadeRate
    if (condition) {
    oscGain = 0;
    // .f15: PEEK %1 &signal:0
    // MULi %1 %1 $pump
    // SHRi %1 %1 #12
    // ADDi %1 %1 $y
    // Write to &signal:0
    // Read from &signal:1
    // MULi %1 %1 $pump
    // SHRi %1 %1 #12
    // ADDi %1 %1 $y
    // Write to &signal:1
    // Read from &clock
    %2 = 1;
    // MOVp %3 &signal
    write();
    yield();
    // Read from &signal:0
    // MULi %0 %0 $pump
    // SHRi %0 %0 #12
    // ADDi %0 %0 $y
    // Write to &signal:0
    // Read from &signal:1
    // MULi %0 %0 $pump
    // SHRi %0 %0 #12
    // ADDi %0 %0 $y
    // Write to &signal:1
    // Read from &clock
    %2 = 1;
    // MOVp %3 &signal
    write();
    yield();
    // ADDi $pump $pump #0x2
    if (condition) {
    pump = 0x1000;
    // .f16: FORi $i #32 @.l12
    // continue loop
    // RETU
}
