/*
 * Decompiled from GAZL assembly
 * Generated by gazl_to_impala_decompiler.py
 */

const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
const int FALSE = 0
const int TRUE = 1
const float LOG2 = 0.69314718055994530942
const float LOG2R = 1.44269504088896340736
const float LOG10R = 0.43429448190325182765
const float E = 2.71828182845904523536
const float HALF_PI = 1.57079632679489661923
const float PI = 3.14159265358979323846
const float COS_EPSILON = 1.0e-6
const int FFT_POWER = 12
const int PROCESS_SPREAD_FACTOR = 5
const float ANTI_DENORMAL_CONSTANT = 1.0e-10
const int PERFORM_RESET = 0
const int THRESHOLD_PARAM = OPERAND_1_HIGH_PARAM_INDEX
const int BAND_PARAM = OPERAND_1_LOW_PARAM_INDEX
const int DECAY_PARAM = OPERAND_2_HIGH_PARAM_INDEX
const int PARTIALS_PARAM = OPERAND_2_LOW_PARAM_INDEX

global int clock = 0
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int instance = 0
global int clockFreqLimit = 44100
global array signal[2]
global int doReset = TRUE
global array window[FFT_SIZE_2]
global array cRotateRe[256]
global array cRotateIm[256]
global array partialGains[8]
global array fftWPRe[<A>]
global array fftWPIm[<A>]
global array randomArray[FFT_SIZE_2]
global array untangleParams[2]

function error()
{
    // PARA *1
    // MOVp %1 $s
    trace();
    abort();
    // RETU
}

function trunc()
{
    // GEQf $x #0.0 @.f0
    // SUBf %0 #0.0 $x
    // FLOf %0 %0
    // SUBf $y #0.0 %0
    // GOTO @.e1
    // .f0: FLOf $y $x
    // .e1: RETU
}

function fmod()
{
    // NEQf $y #0.0 @.f0
    // MOVp %1 &.s_Divisi684ca42
    error();
    // GOTO @.e1
    // .f0: DIVf %1 $x $y
    trunc();
    // MULf %0 %0 $y
    // SUBf $z $x %0
    // .e1: RETU
}

function cos()
locals float a, float n, float m, float t
{
    // MOVf %1 $x
    // MOVf %2 #TWICE_PI
    fmod();
    // MOVf $m %0
    // SUBf %0 #0.0 $m
    // MULf $m %0 $m
    // MOVf $a #1.0
    // MOVf $n #1.0
    // MOVf $y #1.0
    // .l0: MOVf $t $y
    // MULf %0 $n $n
    // MULf %1 $a $m
    // ADDf %0 %0 $n
    // DIVf $a %1 %0
    // ADDf $y $y $a
    // ADDf $n $n #2.0
    // NEQf $y $t @.l0
    // ABSf %1 $y
    // GEQf %1 #COS_EPSILON @.f1
    // MOVf $y #0.0
    // .f1: RETU
}

function sin()
{
    // SUBf %1 $x #HALF_PI
    cos();
    // MOVf $y %0
    // RETU
}

function sqrt()
locals float t
{
    // GEQf $x #0.0 @.f0
    // MOVp %1 &.s_Domain684ca43
    error();
    // .f0: MOVf $y $x
    // MOVf $t #0.0
    // .l1: EQUf $y $t @.e2
    // MOVf $t $y
    // DIVf %0 $x $y
    // ADDf %0 $y %0
    // MULf $y #0.5 %0
    // continue loop
    // .e2: RETU
    // FFT_POWER: ! DEFi #12
    // ! SHLi <A> #1 #FFT_POWER
    // FFT_SIZE: ! DEFi <A>
    // ! DIVi <A> #FFT_SIZE #2
    // FFT_SIZE_2: ! DEFi <A>
    // PROCESS_SPREAD_FACTOR: ! DEFi #5
    // ! iTOf <A> #FFT_SIZE #1.0
    // ! DIVf <A> #2.0 <A>
    // IFFT_SCALE: ! DEFf <A>
    // ANTI_DENORMAL_CONSTANT: ! DEFf #1.0e-10
    // PERFORM_RESET: ! DEFi #0
    // ! ADDi <A> #PERFORM_RESET #1
    // ANALYSIS_WINDOW: ! DEFi <A>
    // ! ADDi <A> #ANALYSIS_WINDOW #1
    // ANALYSIS_REINDEX: ! DEFi <A>
    // ! ADDi <A> #ANALYSIS_REINDEX #1
    // ANALYSIS_FFT_2: ! DEFi <A>
    // ! ADDi <A> #ANALYSIS_FFT_2 #FFT_POWER
    // ! SUBi <A> <A> #1
    // ANALYSIS_UNTANGLE: ! DEFi <A>
    // ! ADDi <A> #ANALYSIS_UNTANGLE #1
    // PROCESS_FIND_MAX: ! DEFi <A>
    // ! ADDi <A> #PROCESS_FIND_MAX #1
    // PROCESS_FEEDBACK: ! DEFi <A>
    // ! ADDi <A> #PROCESS_FEEDBACK #1
    // PROCESS_PARTIAL_1: ! DEFi <A>
    // ! ADDi <A> #PROCESS_PARTIAL_1 #8
    // SYNTHESIS_SMEAR_LEFT: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_SMEAR_LEFT #1
    // SYNTHESIS_UNTANGLE_LEFT: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_UNTANGLE_LEFT #1
    // SYNTHESIS_REINDEX_LEFT: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_REINDEX_LEFT #1
    // SYNTHESIS_FFT_LEFT_2: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #FFT_POWER
    // ! SUBi <A> <A> #1
    // SYNTHESIS_MIX_LEFT: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_MIX_LEFT #1
    // SYNTHESIS_SMEAR_RIGHT: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_SMEAR_RIGHT #1
    // SYNTHESIS_UNTANGLE_RIGHT: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_UNTANGLE_RIGHT #1
    // SYNTHESIS_REINDEX_RIGHT: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_REINDEX_RIGHT #1
    // SYNTHESIS_FFT_RIGHT_2: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #FFT_POWER
    // ! SUBi <A> <A> #1
    // SYNTHESIS_MIX_RIGHT: ! DEFi <A>
    // ! ADDi <A> #SYNTHESIS_MIX_RIGHT #1
    // PROCESS_STEPS: ! DEFi <A>
    // THRESHOLD_PARAM: ! DEFi #OPERAND_1_HIGH_PARAM_INDEX
    // BAND_PARAM: ! DEFi #OPERAND_1_LOW_PARAM_INDEX
    // DECAY_PARAM: ! DEFi #OPERAND_2_HIGH_PARAM_INDEX
    // PARTIALS_PARAM: ! DEFi #OPERAND_2_LOW_PARAM_INDEX
    // CNST *1
    // ! SHLi <A> #1 #THRESHOLD_PARAM
    // ! SHLi <B> #1 #DECAY_PARAM
    // ! IORi <A> <A> <B>
    // updateMask: DATi <A>
    // GLOB *1
    // doReset: DATi #TRUE
    // window: GLOB *FFT_SIZE_2
    // cRotateRe: GLOB *256
    // cRotateIm: GLOB *256
    // partialGains: GLOB *8
    // ! SUBi <A> #FFT_POWER #1
    // fftWPRe: GLOB *<A>
    // ! SUBi <A> #FFT_POWER #1
    // fftWPIm: GLOB *<A>
    // GLOB *1
    // threshold: DATf #0.0
    // GLOB *1
    // decayConstant: DATf #0.0
    // GLOB *1
    // outputGain: DATf #0.0
    // randomArray: GLOB *FFT_SIZE_2
    // untangleParams: GLOB *2
}

function fftReIndex()
locals int nn, int j, int i, int m, float t
{
    // PARA *1
    // SHRi $nn $n #1
    j = 0;
    i = 0;
    // .l0: GEQi $i $n @.e1
    if (condition) {
    // Read from $data
    // Read from $data
    // Write to $data
    // Write to $data
    // ADDi %0 $j #1
    // Read from $data
    // ADDi %0 $j #1
    // ADDi %1 $i #1
    // Read from $data
    // Write to $data
    // ADDi %1 $i #1
    // Write to $data
    // .f2: MOVi $m $nn
    // .l3: LSSi $m #2 @.e5
    // LSSi $j $m @.e5
    // SUBi $j $j $m
    // SHRi $m $m #1
    // continue loop
    // .e5: ADDi $j $j $m
    // ADDi $i $i #2
    // continue loop
    // .e1: RETU
}

function fftPass()
locals int mmax, int i, int i1, int j, int j1, int m, float wTemp, float wpRe, float wpIm, float wRe, float wIm, float tempRe, float tempIm, float dj0, float dj1, float di0, float di1
{
    // PARA *1
    // SHLi $mmax #2 $fftStep
    // Read from &fftWPRe
    // Read from &fftWPIm
    // MOVf $wRe #1.0
    // MOVf $wIm #0.0
    m = 0;
    // .l0: MOVi $i $m
    // .l1: GEQi $i $n @.e2
    // ADDi $j $i $mmax
    // ADDi $i1 $i #1
    // ADDi $j1 $j #1
    // Read from $data
    // Read from $data
    // Read from $data
    // Read from $data
    // MULf %1 $wRe $dj0
    // MULf %0 $wIm $dj1
    // SUBf $tempRe %1 %0
    // MULf %1 $wRe $dj1
    // MULf %0 $wIm $dj0
    // ADDf $tempIm %1 %0
    // SUBf %1 $di0 $tempRe
    // Write to $data
    // SUBf %1 $di1 $tempIm
    // Write to $data
    // ADDf %1 $di0 $tempRe
    // Write to $data
    // ADDf %1 $di1 $tempIm
    // Write to $data
    // ADDi $i $j $mmax
    // continue loop
    // .e2: MOVf $wTemp $wRe
    // MULf %1 $wRe $wpRe
    // MULf %0 $wIm $wpIm
    // SUBf %1 %1 %0
    // ADDf $wRe $wRe %1
    // MULf %1 $wIm $wpRe
    // MULf %0 $wTemp $wpIm
    // ADDf %1 %1 %0
    // ADDf $wIm $wIm %1
    // ADDi $m $m #2
    // LSSi $m $mmax @.l0
    // RETU
}

function fftUntangleParams()
locals float wpRe, float wpIm
{
    // PARA *1
    // MOVf %1 #2.0
    sqrt();
    // ! MULf <A> #2.0 #PI
    // ! MULf <A> <A> #0.5
    // iTOf %2 $n #1.0
    // DIVf %2 <A> %2
    sin();
    // MULf $wpRe %0 %1
    // MULf $wpRe $wpRe $wpRe
    // ! MULf <A> #2.0 #PI
    // iTOf %1 $n #1.0
    // DIVf %1 <A> %1
    sin();
    // MOVf $wpIm %0
    // Write to $params
    // Write to $params
    // RETU
}

function fftUntangle()
locals int indexA, int indexB, int i, float r0, float i0, float wRe, float wIm, float wpRe, float wpIm, float nwr, float nwy, float r1, float i1, float r0r1, float i0i1, float i0i1wr, float i0i1wi, float r1r0wr, float r0r1wi, float re0, float im0, float re1, float im1
{
    // PARA *1
    // Read from $data
    // Read from $data
    // ADDf %0 $r0 $i0
    // Write to $data
    // SUBf %0 $r0 $i0
    // Write to $data
    // MOVf $wRe #1.0
    // MOVf $wIm #0.0
    // Read from $params
    // Read from $params
    indexA = 2;
    // SUBi $indexB $n #2
    i = 1;
    // DIVi %0 $n #4
    if (condition) {
    // .l1: MULf %1 $wRe $wpRe
    // SUBf %1 $wRe %1
    // MULf %2 $wIm $wpIm
    // SUBf $nwr %1 %2
    // MULf %1 $wRe $wpIm
    // ADDf %1 %1 $wIm
    // MULf %2 $wIm $wpRe
    // SUBf $nwy %1 %2
    // MOVf $wRe $nwr
    // MOVf $wIm $nwy
    // Read from $data
    // ADDi %1 $indexA #1
    // Read from $data
    // Read from $data
    // ADDi %1 $indexB #1
    // Read from $data
    // ADDf $r0r1 $r0 $r1
    // SUBf $i0i1 $i0 $i1
    // ADDf %1 $i0 $i1
    // MULf $i0i1wr %1 $wRe
    // ADDf %1 $i0 $i1
    // MULf $i0i1wi %1 $wIm
    // SUBf %1 $r1 $r0
    // MULf $r1r0wr %1 $wRe
    // SUBf %1 $r0 $r1
    // MULf $r0r1wi %1 $wIm
    // SUBf %1 $i0i1wr $r0r1wi
    // ADDf %1 %1 $r0r1
    // MULf $re0 #0.5 %1
    // SUBf %1 $r1r0wr $i0i1wi
    // ADDf %1 %1 $i0i1
    // MULf $im0 #0.5 %1
    // SUBf %1 $r0r1wi $i0i1wr
    // ADDf %1 %1 $r0r1
    // MULf $re1 #0.5 %1
    // SUBf %1 $r1r0wr $i0i1wi
    // SUBf %1 %1 $i0i1
    // MULf $im1 #0.5 %1
    // Write to $data
    // ADDi %1 $indexA #1
    // Write to $data
    // Write to $data
    // ADDi %1 $indexB #1
    // Write to $data
    // ADDi $indexA $indexA #2
    // SUBi $indexB $indexB #2
    // FORi $i %0 @.l1
    // .e0: RETU
}

function mixOutput()
locals int i, int i2
{
    // PARA *1
    // ADDi $i2 $mixBufferOffset $channel
    i = 0;
    if (condition) {
    // .l1: PEEK %0 $fftBuffer $i
    // Read from &window
    // MULf %0 %0 %1
    // Read from $mixBuffer
    // fTOi %0 %0 #2048.0
    // ADDi %1 %1 %0
    // Write to $mixBuffer
    // ADDi $i2 $i2 #2
    // FORi $i #FFT_SIZE_2 @.l1
    // .e0: SUBi %1 #FFT_SIZE $mixBufferOffset
    // ADDi $i2 %1 $channel
    i = FFT_SIZE_2;
    if (condition) {
    // .l3: NOOP
    // ! SUBi <A> #FFT_SIZE #1
    // SUBi %1 <A> $i
    // Read from $fftBuffer
    // Read from &window
    // MULf %0 %0 %1
    // fTOi %0 %0 #2048.0
    // Write to $mixBuffer
    // ADDi $i2 $i2 #2
    // FORi $i #FFT_SIZE @.l3
    // .e2: RETU
}

function init()
locals int i, float theta, float wTemp, int prng
{
    // PARA *1
    // MOVp %1 &.s_init684ca44
    trace();
    i = 0;
    if (condition) {
    // .l1: NOOP
    // ! iTOf <A> #FFT_SIZE #1.0
    // ! DIVf <A> #PI <A>
    // iTOf %1 $i <A>
    sin();
    // Write to &window
    // FORi $i #FFT_SIZE_2 @.l1
    // .e0: MOVi $i #0
    if (condition) {
    // .l3: NOOP
    // ! MULf <A> #2.0 #PI
    // ! DIVf <A> <A> #256.0
    // iTOf $theta $i <A>
    // MOVf %1 $theta
    cos();
    // Write to &cRotateRe
    // MOVf %1 $theta
    sin();
    // Write to &cRotateIm
    // FORi $i #256 @.l3
    // .e2: MOVi $i #0
    if (condition) {
    // .l5: ADDi %1 $i #1
    // iTOf %1 %1 #1.0
    sqrt();
    // DIVf %0 #IFFT_SCALE %0
    // Write to &partialGains
    // FORi $i #8 @.l5
    // .e4: MOVi $i #0
    // ! SUBi <A> #FFT_POWER #1
    if (condition) {
    // .l7: SHLi %0 #2 $i
    // ! MULf <B> #2.0 #PI
    // iTOf %0 %0 #1.0
    // DIVf %0 <B> %0
    // SUBf $theta #0.0 %0
    // MULf %1 #0.5 $theta
    sin();
    // MOVf $wTemp %0
    // MULf %0 #-2.0 $wTemp
    // MULf %0 %0 $wTemp
    // Write to &fftWPRe
    // MOVf %1 $theta
    sin();
    // Write to &fftWPIm
    // FORi $i <A> @.l7
    // .e6: PEEK %0 &instance
    // SHLi %0 %0 #13
    // XORi $prng #2463534242 %0
    i = 1;
    if (condition) {
    // .l9: SHLi %0 $prng #13
    // XORi $prng $prng %0
    // SHRu %0 $prng #17
    // XORi $prng $prng %0
    // SHLi %0 $prng #5
    // XORi $prng $prng %0
    // ANDi %0 $prng #255
    // Write to &randomArray
    // FORi $i #FFT_SIZE_2 @.l9
    // .e8: MOVi %1 #FFT_SIZE
    // MOVp %2 &untangleParams
    fftUntangleParams();
    // RETU
}

function reset()
{
    // PARA *1
    // MOVp %1 &.s_reset684ca45
    trace();
    // Write to &doReset
    // RETU
}

function update()
locals float f
{
    // PARA *1
    // MOVp %1 &.s_update684ca46
    trace();
    // Read from &params:THRESHOLD_PARAM
    // ! DIVf <A> #1.0 #255.0
    // iTOf $f %0 <A>
    // MULf %0 $f $f
    // MULf $f %0 $f
    // Write to &threshold
    // Read from &params:THRESHOLD_PARAM
    // ADDi %0 %0 #16
    // SHRu %0 %0 #5
    // SHRi %0 #0xFF %0
    // XORi %0 %0 #-1
    // Write to &displayLEDs:0
    // Read from &params:DECAY_PARAM
    // ! DIVf <A> #1.0 #255.0
    // iTOf %0 %0 <A>
    // SUBf $f #1.0 %0
    // MULf %0 $f $f
    // MULf %0 %0 $f
    // SUBf %0 #1.0 %0
    // Write to &decayConstant
    // Read from &params:DECAY_PARAM
    // ADDi %0 %0 #16
    // SHRu %0 %0 #5
    // SHRi %0 #0xFF %0
    // XORi %0 %0 #-1
    // Write to &displayLEDs:2
    // Read from &decayConstant
    // SUBf %2 #1.0 %2
    sqrt();
    sqrt();
    // Write to &outputGain
    // RETU
}

function process()
locals float fftBuffer, float inputBuffer, int clock, int i, int i2, int processStep, float useThreshold, int bandBits, int nextBandBit, float re, float im, float power, float feedbackRe, float feedbackIm, float k, int partial, int partialBase1, int partialBase1Div2, float g, float cMulARe, float cMulAIm, float cMulBRe, float cMulBIm, float cMulRe, float cMulIm, int rotateIndex, int x, int y, int t, int prng, float mixBuffer, int mixBufferOffset, int myInstance, int includedBits
{
    // PARA *1
    // ! MULi <A> #FFT_SIZE #2
    // Write to &doReset
    // Read from &instance
    myInstance = 0;
    i = 0;
    if (condition) {
    // .l1: SHLi %0 $myInstance #1
    // ANDi %1 $t #1
    // IORi $myInstance %0 %1
    // SHRi $t $t #1
    // FORi $i #PROCESS_SPREAD_FACTOR @.l1
    // .e0: SHLi %0 $myInstance #13
    // XORi $prng #2463534242 %0
    i = 0;
    if (condition) {
    // .l3: SETL $inputBuffer $i #0.0
    // FORi $i #FFT_SIZE @.l3
    // .e2: MOVi $mixBufferOffset #0
    processStep = PROCESS_STEPS;
    // .l4: PEEK $clock &clock
    // ! SHLi <A> #1 #PROCESS_SPREAD_FACTOR
    // ! SUBi <A> <A> #1
    // ANDi %0 $clock <A>
    // NEQi %0 $myInstance @.f5
    // ADDi $processStep $processStep #1
    // ! SUBi <A> #FFT_SIZE_2 #1
    // ANDi %0 $clock <A>
    // NEQi %0 $myInstance @.f6
    processStep = PERFORM_RESET;
    // .f6: SWCH $processStep *PROCESS_STEPS @.s7
    // .s7#PERFORM_RESET: PEEK %0 &doReset
    // EQUi %0 #FALSE @.e8
    // Write to &doReset
    i = 0;
    if (condition) {
    // .l11: SETL $feedbackIm $i #0.0
    // SETL $feedbackRe $i #0.0
    // FORi $i #FFT_SIZE_2 @.l11
    // .e10: MOVi $i #0
    if (condition) {
    // .l13: SETL $mixBuffer $i #0
    // FORi $i #FFT_SIZE @.l13
    // .e12: MOVi $mixBufferOffset #0
    // GOTO @.e8
    // .s7#ANALYSIS_WINDOW: MOVi $i #0
    if (condition) {
    // .l15: SUBi %0 $clock #FFT_SIZE
    // ADDi %0 %0 $i
    // ! SUBi <A> #FFT_SIZE #1
    // ANDi %0 %0 <A>
    // GETL %0 $inputBuffer %0
    // Read from &window
    // MULf %0 %0 %1
    // SETL $fftBuffer $i %0
    // FORi $i #FFT_SIZE_2 @.l15
    // .e14: MOVi $i #FFT_SIZE_2
    if (condition) {
    // .l17: SUBi %0 $clock #FFT_SIZE
    // ADDi %0 %0 $i
    // ! SUBi <A> #FFT_SIZE #1
    // ANDi %0 %0 <A>
    // ! SUBi <A> #FFT_SIZE #1
    // SUBi %1 <A> $i
    // GETL %0 $inputBuffer %0
    // Read from &window
    // MULf %0 %0 %1
    // SETL $fftBuffer $i %0
    // FORi $i #FFT_SIZE @.l17
    // GOTO @.e8
    // .s7#ANALYSIS_REINDEX: NOOP
    // .s7#SYNTHESIS_REINDEX_LEFT: NOOP
    // .s7#SYNTHESIS_REINDEX_RIGHT: MOVi %1 #FFT_SIZE
    // ADRL %2 $fftBuffer *0
    fftReIndex();
    // GOTO @.e8
    // .s7#ANALYSIS_FFT_2: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #1
    // .s7#<A>: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #2
    // .s7#<A>: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #3
    // .s7#<A>: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #4
    // .s7#<A>: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #5
    // .s7#<A>: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #6
    // .s7#<A>: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #7
    // .s7#<A>: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #8
    // .s7#<A>: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #9
    // .s7#<A>: NOOP
    // ! ADDi <A> #ANALYSIS_FFT_2 #10
    // .s7#<A>: MOVi %1 #FFT_SIZE
    // ADRL %2 $fftBuffer *0
    // SUBi %3 $processStep #ANALYSIS_FFT_2
    fftPass();
    // GOTO @.e8
    // .s7#ANALYSIS_UNTANGLE: NOOP
    // .s7#SYNTHESIS_UNTANGLE_LEFT: NOOP
    // .s7#SYNTHESIS_UNTANGLE_RIGHT: MOVi %1 #FFT_SIZE
    // ADRL %2 $fftBuffer *0
    // MOVp %3 &untangleParams
    fftUntangle();
    // GOTO @.e8
    // .s7#PROCESS_FIND_MAX: MOVf $useThreshold #0.0
    // Read from &params:BAND_PARAM
    // ! SUBi <A> #FFT_POWER #8
    // ! SHLi <A> #1 <A>
    nextBandBit = <A>;
    i = 1;
    if (condition) {
    // .l19: NEQi $i $nextBandBit @.f20
    // SHLi $nextBandBit $nextBandBit #1
    // SHLi $bandBits $bandBits #1
    // .f20: MULi $i2 $i #2
    // ANDi %0 $bandBits #0x80
    // NEQi %0 #0 @.f21
    // SETL $fftBuffer $i2 #0.0
    // ADDi %0 $i2 #1
    // SETL $fftBuffer %0 #0.0
    // GOTO @.e22
    // .f21: GETL $re $fftBuffer $i2
    // ADDi %0 $i2 #1
    // GETL $im $fftBuffer %0
    // MULf %0 $re $re
    // MULf %1 $im $im
    // ADDf $power %0 %1
    // LEQf $power $useThreshold @.f23
    // MOVf $useThreshold $power
    // .f23: NOOP
    // .e22: FORi $i #FFT_SIZE_2 @.l19
    // .e18: PEEK %0 &threshold
    // MULf $useThreshold $useThreshold %0
    // GOTO @.e8
    // .s7#PROCESS_FEEDBACK: PEEK $k &decayConstant
    // ! SUBi <A> #FFT_POWER #8
    // ! SHLi <A> #1 <A>
    nextBandBit = <A>;
    includedBits = 0;
    i = 1;
    if (condition) {
    // .l25: GETL %0 $feedbackRe $i
    // MULf %0 %0 $k
    // ADDf %0 %0 #ANTI_DENORMAL_CONSTANT
    // SETL $feedbackRe $i %0
    // GETL %0 $feedbackIm $i
    // MULf %0 %0 $k
    // ADDf %0 %0 #ANTI_DENORMAL_CONSTANT
    // SETL $feedbackIm $i %0
    if (condition) {
    // ANDi %0 $i #15
    // NEQi %0 #0 @.f27
    // ! DIVf <A> #1.0 #256.0
    // ! SUBf <A> #1.0 <A>
    // MULf $k $k <A>
    // .f27: NEQi $i $nextBandBit @.f28
    // SHLi $nextBandBit $nextBandBit #1
    // SHLi $includedBits $includedBits #1
    // .f28: MULi $i2 $i #2
    // GETL $re $fftBuffer $i2
    // ADDi %0 $i2 #1
    // GETL $im $fftBuffer %0
    // MULf %0 $re $re
    // MULf %1 $im $im
    // ADDf %0 %0 %1
    // GEQf %0 $useThreshold @.f29
    // SETL $fftBuffer $i2 #0.0
    // ADDi %0 $i2 #1
    // SETL $fftBuffer %0 #0.0
    // GOTO @.e30
    // .f29: IORi $includedBits $includedBits #1
    // .e30: FORi $i #FFT_SIZE_2 @.l25
    // .e24: PEEK %0 &params:BAND_PARAM
    // ANDi %0 $includedBits %0
    // Write to &displayLEDs:1
    // GOTO @.e8
    // .s7#PROCESS_PARTIAL_1: NOOP
    // ! ADDi <A> #PROCESS_PARTIAL_1 #1
    // .s7#<A>: NOOP
    // ! ADDi <A> #PROCESS_PARTIAL_1 #2
    // .s7#<A>: NOOP
    // ! ADDi <A> #PROCESS_PARTIAL_1 #3
    // .s7#<A>: NOOP
    // ! ADDi <A> #PROCESS_PARTIAL_1 #4
    // .s7#<A>: NOOP
    // ! ADDi <A> #PROCESS_PARTIAL_1 #5
    // .s7#<A>: NOOP
    // ! ADDi <A> #PROCESS_PARTIAL_1 #6
    // .s7#<A>: NOOP
    // ! ADDi <A> #PROCESS_PARTIAL_1 #7
    // .s7#<A>: SUBi $partial $processStep #PROCESS_PARTIAL_1
    // Read from &params:PARTIALS_PARAM
    // SHRu %1 #128 $partial
    // ANDi %0 %0 %1
    if (condition == 0) {
    // Read from &outputGain
    // Read from &partialGains
    // MULf $g %0 %1
    // ADDi $partialBase1 $partial #1
    // DIVi $partialBase1Div2 $partialBase1 #2
    i = 1;
    if (condition) {
    // .l33: ADDi %0 $i $partialBase1Div2
    // DIVi %0 %0 $partialBase1
    // MULi $i2 %0 #2
    // GETL %0 $fftBuffer $i2
    // GETL %1 $feedbackRe $i
    // MULf %0 %0 $g
    // ADDf %1 %1 %0
    // SETL $feedbackRe $i %1
    // ADDi %1 $i2 #1
    // GETL %1 $fftBuffer %1
    // GETL %0 $feedbackIm $i
    // MULf %1 %1 $g
    // ADDf %0 %0 %1
    // SETL $feedbackIm $i %0
    // FORi $i #FFT_SIZE_2 @.l33
    // GOTO @.e8
    // .s7#SYNTHESIS_SMEAR_LEFT: NOOP
    // .s7#SYNTHESIS_SMEAR_RIGHT: MOVi $i #1
    if (condition) {
    // .l35: ADDi %0 $prng $i
    // ! SUBi <A> #FFT_SIZE_2 #1
    // ANDi %0 %0 <A>
    // Read from &randomArray
    // Read from &cRotateRe
    // Read from &cRotateIm
    // GETL $cMulBRe $feedbackRe $i
    // GETL $cMulBIm $feedbackIm $i
    // MULf %0 $cMulARe $cMulBRe
    // MULf %1 $cMulAIm $cMulBIm
    // SUBf $cMulRe %0 %1
    // MULf %0 $cMulAIm $cMulBRe
    // MULf %1 $cMulARe $cMulBIm
    // ADDf $cMulIm %0 %1
    // SETL $feedbackRe $i $cMulRe
    // SETL $feedbackIm $i $cMulIm
    // SUBi %0 #FFT_SIZE_2 $i
    // MULi $i2 %0 #2
    // SETL $fftBuffer $i2 $cMulRe
    // ADDi %0 $i2 #1
    // SETL $fftBuffer %0 $cMulIm
    // FORi $i #FFT_SIZE_2 @.l35
    // .e34: MOVf $fftBuffer:0 #0.0
    // MOVf $fftBuffer:1 #0.0
    // SHLi %0 $prng #13
    // XORi $prng $prng %0
    // SHRu %0 $prng #17
    // XORi $prng $prng %0
    // SHLi %0 $prng #5
    // XORi $prng $prng %0
    // GOTO @.e8
    // .s7#SYNTHESIS_FFT_LEFT_2: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #1
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #2
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #3
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #4
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #5
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #6
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #7
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #8
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #9
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_LEFT_2 #10
    // .s7#<A>: MOVi %1 #FFT_SIZE
    // ADRL %2 $fftBuffer *0
    // SUBi %3 $processStep #SYNTHESIS_FFT_LEFT_2
    fftPass();
    // GOTO @.e8
    // .s7#SYNTHESIS_FFT_RIGHT_2: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #1
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #2
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #3
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #4
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #5
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #6
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #7
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #8
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #9
    // .s7#<A>: NOOP
    // ! ADDi <A> #SYNTHESIS_FFT_RIGHT_2 #10
    // .s7#<A>: MOVi %1 #FFT_SIZE
    // ADRL %2 $fftBuffer *0
    // SUBi %3 $processStep #SYNTHESIS_FFT_RIGHT_2
    fftPass();
    // GOTO @.e8
    // .s7#SYNTHESIS_MIX_LEFT: ADRL %1 $fftBuffer *0
    // ADRL %2 $mixBuffer *0
    %3 = mixBufferOffset;
    %4 = 0;
    mixOutput();
    // GOTO @.e8
    // .s7#SYNTHESIS_MIX_RIGHT: ADRL %1 $fftBuffer *0
    // ADRL %2 $mixBuffer *0
    %3 = mixBufferOffset;
    %4 = 1;
    mixOutput();
    // ! SUBi <A> #FFT_SIZE_2 #1
    // ! XORi <A> <A> #-1
    // ANDi %1 $clock <A>
    // ! SHLi <A> #PROCESS_STEPS #PROCESS_SPREAD_FACTOR
    // ADDi %1 %1 <A>
    %2 = FFT_SIZE_2;
    // ADRL %3 $mixBuffer *0
    // ADDp %3 %3 $mixBufferOffset
    write();
    // SUBi $mixBufferOffset #FFT_SIZE $mixBufferOffset
    // .s7: NOOP
    // .e8: NOOP
    // .f5: NOOP
    // ! SUBi <A> #FFT_SIZE #1
    // ANDi %0 $clock <A>
    // Read from &signal:0
    // Read from &signal:1
    // ADDi %1 %1 %2
    // ! MULf <A> #2048.0 #2.0
    // ! DIVf <A> #1.0 <A>
    // iTOf %1 %1 <A>
    // SETL $inputBuffer %0 %1
    %1 = clock;
    %2 = 1;
    // MOVp %3 &signal
    read();
    yield();
    // continue loop
    // RETU
}
