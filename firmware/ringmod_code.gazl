 ; Compiled with Impala version 1.0

 PRAWN_FIRMWARE_PATCH_FORMAT: ! DEFi #2
 FALSE:				! DEFi #0
 TRUE:				! DEFi #1
 panelTextRows:		CNST *8
 					DATA &.s_53eb078e &.s_53eb078e &.s_53eb078e
 					DATA &.s_LEFTDE53eb078f &.s_53eb078e &.s_53eb078e
 					DATA &.s_53eb078e &.s_RINGMO53eb0790
 					GLOB *1
 clock:				DATi #0
 					GLOB *1
 hostPosition:		DATi #0
 params:			GLOB *PARAM_COUNT
 displayLEDs:		GLOB *4
 					GLOB *1
 instance:			DATi #0
 					CNST *1
 clockFreqLimit:	DATi #132300
 signal:			GLOB *2
 					CNST *1
 					! SHLi <A> #1 #OPERAND_1_HIGH_PARAM_INDEX
 					! SHLi <B> #1 #OPERAND_1_LOW_PARAM_INDEX
 					! IORi <A> <A> <B>
 					! SHLi <B> #1 #OPERAND_2_HIGH_PARAM_INDEX
 					! IORi <A> <A> <B>
 					! SHLi <B> #1 #OPERAND_2_LOW_PARAM_INDEX
 					! IORi <A> <A> <B>
 					! SHLi <B> #1 #SWITCHES_PARAM_INDEX
 					! IORi <A> <A> <B>
 updateMask:		DATi <A>
 EIGHT_BIT_EXP_TABLE: CNST *256
 					DATA #0x0 #0x1 #0x2 #0x3 #0x4 #0x5 #0x6 #0x7 #0x8 #0x9
 					DATA #0xa #0xb #0xc #0xd #0xe #0xf #0x10 #0x11 #0x12 #0x13
 					DATA #0x14 #0x15 #0x16 #0x17 #0x18 #0x19 #0x1a #0x1b #0x1c
 					DATA #0x1d #0x1e #0x1f #0x20 #0x21 #0x22 #0x23 #0x24 #0x25
 					DATA #0x26 #0x27 #0x28 #0x29 #0x2a #0x2b #0x2c #0x2d #0x2e
 					DATA #0x2f #0x30 #0x31 #0x32 #0x33 #0x34 #0x35 #0x36 #0x37
 					DATA #0x38 #0x39 #0x3a #0x3b #0x3c #0x3d #0x3e #0x3f #0x40
 					DATA #0x42 #0x44 #0x46 #0x48 #0x4a #0x4c #0x4e #0x50 #0x52
 					DATA #0x54 #0x56 #0x58 #0x5a #0x5c #0x5e #0x60 #0x62 #0x64
 					DATA #0x66 #0x68 #0x6a #0x6c #0x6e #0x70 #0x72 #0x74 #0x76
 					DATA #0x78 #0x7a #0x7c #0x7e #0x80 #0x84 #0x88 #0x8c #0x90
 					DATA #0x94 #0x98 #0x9c #0xa0 #0xa4 #0xa8 #0xac #0xb0 #0xb4
 					DATA #0xb8 #0xbc #0xc0 #0xc4 #0xc8 #0xcc #0xd0 #0xd4 #0xd8
 					DATA #0xdc #0xe0 #0xe4 #0xe8 #0xec #0xf0 #0xf4 #0xf8 #0xfc
 					DATA #0x100 #0x110 #0x120 #0x130 #0x140 #0x150 #0x160
 					DATA #0x170 #0x180 #0x190 #0x1a0 #0x1b0 #0x1c0 #0x1d0
 					DATA #0x1e0 #0x1f0 #0x200 #0x220 #0x240 #0x260 #0x280
 					DATA #0x2a0 #0x2c0 #0x2e0 #0x300 #0x320 #0x340 #0x360
 					DATA #0x380 #0x3a0 #0x3c0 #0x3e0 #0x400 #0x440 #0x480
 					DATA #0x4c0 #0x500 #0x540 #0x580 #0x5c0 #0x600 #0x640
 					DATA #0x680 #0x6c0 #0x700 #0x740 #0x780 #0x7c0 #0x800
 					DATA #0x880 #0x900 #0x980 #0xa00 #0xa80 #0xb00 #0xb80
 					DATA #0xc00 #0xc80 #0xd00 #0xd80 #0xe00 #0xe80 #0xf00
 					DATA #0xf80 #0x1000 #0x1100 #0x1200 #0x1300 #0x1400
 					DATA #0x1500 #0x1600 #0x1700 #0x1800 #0x1900 #0x1a00
 					DATA #0x1b00 #0x1c00 #0x1d00 #0x1e00 #0x1f00 #0x2000
 					DATA #0x2200 #0x2400 #0x2600 #0x2800 #0x2a00 #0x2c00
 					DATA #0x2e00 #0x3000 #0x3200 #0x3400 #0x3600 #0x3800
 					DATA #0x3a00 #0x3c00 #0x3e00 #0x4000 #0x4400 #0x4800
 					DATA #0x4c00 #0x5000 #0x5400 #0x5800 #0x5c00 #0x6000
 					DATA #0x6400 #0x6800 #0x6c00 #0x7000 #0x7400 #0x7800
 					DATA #0x7c00 #0x8000 #0x8800 #0x9000 #0x9800 #0xa000
 					DATA #0xa800 #0xb000 #0xb800 #0xc000 #0xc800 #0xd000
 					DATA #0xd800 #0xe000 #0xe800 #0xf000 #0xffff
 LOG2:				! DEFf #0.69314718055994530942
 LOG2R:				! DEFf #1.44269504088896340736
 LOG10R:			! DEFf #0.43429448190325182765
 E:					! DEFf #2.71828182845904523536
 HALF_PI:			! DEFf #1.57079632679489661923
 PI:				! DEFf #3.14159265358979323846
 					! MULf <A> #PI #2.0
 TWICE_PI:			! DEFf <A>
 COS_EPSILON:		! DEFf #1.0e-6

 ;-----------------------------------------------------------------------------
 stpcpy:			FUNC
 					$a:			OUTp
 					$d:			INPp
 					$s:			INPp
 					$b:			LOCp
 ;-----------------------------------------------------------------------------
 								MOVp $a $d 						; a = d
 								MOVp $b $s 						; b = s
 					.l0:		PEEK %0 $b 						; while ((*a = (int)*b) != 0) 
 								POKE $a %0 
 								EQUi %0 #0 @.e1
 								ADDp $a $a #1					; a = a + 1
 								ADDp $b $b #1					; b = b + 1
 								GOTO @.l0  						; }
 					.e1:		RETU   							; }


 ;-----------------------------------------------------------------------------
 intToString:		FUNC
 					$p:			OUTp
 					$i:			INPi
 					$radix:		INPi
 					$minLength:	INPi
 					$buffer:	INPp
 					$e:			LOCp
 					$x:			LOCi
 ;-----------------------------------------------------------------------------
 								! EQUi #DEBUG #0 @.a0			; assert(2 <= radix && radix <= 16)
 								GRTi #2 $radix @.f1
 								LEQi $radix #16 @.a0
 					.f1:		MOVp %1 &.a_2radix53eb078e 
 								CALL ^assertFail %0 *1
 					.a0:		NOOP
 								! EQUi #DEBUG #0 @.a2			; assert(0 <= minLength && minLength <= GAZL_WORD_SIZE)
 								GRTi #0 $minLength @.f3
 								LEQi $minLength #GAZL_WORD_SIZE @.a2
 					.f3:		MOVp %1 &.a_0minLe53eb078f 
 								CALL ^assertFail %0 *1
 					.a2:		ADDp %0 $buffer #GAZL_WORD_SIZE	; *(p = buffer + GAZL_WORD_SIZE + 1) = 0
 								ADDp $p %0 #1
 								POKE $p #0 
 								SUBp $e $p $minLength			; e = p - minLength
 								MOVi $x $i 						; x = i
 					.l4:		GRTp $p $e @.t5					; while (p > e || x != 0) 
 								EQUi $x #0 @.e6
 					.t5:		NOOP
 								! EQUi #DEBUG #0 @.a7			; assert(p >= buffer + 2)
 								ADDp %0 $buffer #2
 								GEQp $p %0 @.a7
 								MOVp %1 &.a_pbuffe53eb0790 
 								CALL ^assertFail %0 *1
 					.a7:		SUBp $p $p #1					; *(p = p - 1) = ("fedcba9876543210123456789abcdef")[15 + x % radix]
 								MODi %0 $x $radix
 								ADDi %0 #15 %0
 								PEEK %0 &.s_fedcba53eb0791 %0
 								POKE $p %0 
 								DIVi $x $x $radix				; x = x / radix
 								GOTO @.l4  						; }
 					.e6:		GEQi $i #0 @.f8					; if (i < 0) *(p = p - 1) = '-'
 								SUBp $p $p #1					; *(p = p - 1) = '-'
 								POKE $p #'-' 
 					.f8:		RETU   							; }


 ;-----------------------------------------------------------------------------
 traceInts:			FUNC
 								PARA *1
 					$text:		INPp
 					$n:			INPi
 					$ints:		INPp
 					! ADDi <A> #GAZL_WORD_SIZE #2
 					$buffer:	LOCA *<A>
 					$line:		LOCA *1024
 					$i:			LOCi
 					$p:			LOCp
 ;-----------------------------------------------------------------------------
 								ADRL $p $line:0 *0				; p = &line[0]
 								EQUp $text &NULL @.f0			; if (text != null) p = (pointer) stpcpy(p, text)
 								MOVp %1 $p 						; p = (pointer) stpcpy(p, text)
 								MOVp %2 $text 
 								CALL &stpcpy %0 *3
 								MOVp $p %0 
 					.f0:		POKE $p #0 						; *p = 0
 								MOVi $i #0 						; for (i = 0 to n) 
 								GEQi #0 $n @.e1
 					.l2:		EQUi $i #0 @.f3					; if (i != 0) 
 								POKE $p #',' 					; *p = ','
 								ADDp $p $p #1					; p = p + 1
 					.f3:		MOVp %1 $p 						; p = (pointer) stpcpy(p, intToString(ints[i], 10, 1, buffer))
 								PEEK %3 $ints $i
 								MOVi %4 #10 
 								MOVi %5 #1 
 								ADRL %6 $buffer *0
 								CALL &intToString %2 *5
 								CALL &stpcpy %0 *3
 								MOVp $p %0 
 								FORi $i $n @.l2					; }
 					.e1:		ADRL %1 $line *0				; trace(line)
 								CALL ^trace %0 *2
 								RETU   							; }


 ;-----------------------------------------------------------------------------
 traceInt:			FUNC
 								PARA *1
 					$text:		INPp
 					$i:			INPi
 					$ints:		LOCA *1
 ;-----------------------------------------------------------------------------
 								MOVi $ints:0 $i 				; ints[0] = i
 								MOVp %1 $text 					; traceInts(text, 1, ints)
 								MOVi %2 #1 
 								ADRL %3 $ints *0
 								CALL &traceInts %0 *4
 								RETU   							; }


 ;-----------------------------------------------------------------------------
 error:				FUNC
 								PARA *1
 					$s:			INPp
 ;-----------------------------------------------------------------------------
 								MOVp %1 $s 						; trace(s)
 								CALL ^trace %0 *2
 								CALL ^abort %0 *1				; abort()
 								RETU   							; }


 ;-----------------------------------------------------------------------------
 trunc:				FUNC
 					$y:			OUTf
 					$x:			INPf
 ;-----------------------------------------------------------------------------
 								GEQf $x #0.0 @.f0				; if (x < 0.0) y = -floor(-x)
 								SUBf %0 #0.0 $x					; y = -floor(-x)
 								FLOf %0 %0 
 								SUBf $y #0.0 %0
 								GOTO @.e1  
 					.f0:		FLOf $y $x 						; y = floor(x)
 					.e1:		RETU   							; }


 ;-----------------------------------------------------------------------------
 fmod:				FUNC
 					$z:			OUTf
 					$x:			INPf
 					$y:			INPf
 ;-----------------------------------------------------------------------------
 								NEQf $y #0.0 @.f0				; if (y == 0.0) error("Division by zero")
 								MOVp %1 &.s_Divisi53eb0792 		; error("Division by zero")
 								CALL &error %0 *2
 								GOTO @.e1  
 					.f0:		DIVf %1 $x $y					; z = x - (float)trunc(x / y) * y
 								CALL &trunc %0 *2
 								MULf %0 %0 $y
 								SUBf $z $x %0
 					.e1:		RETU   							; }


 ;-----------------------------------------------------------------------------
 cos:				FUNC
 					$y:			OUTf
 					$x:			INPf
 					$a:			LOCf
 					$n:			LOCf
 					$m:			LOCf
 					$t:			LOCf
 ;-----------------------------------------------------------------------------
 								MOVf %1 $x 						; m = (float) fmod(x, TWICE_PI)
 								MOVf %2 #TWICE_PI 
 								CALL &fmod %0 *3
 								MOVf $m %0 
 								SUBf %0 #0.0 $m					; m = -m * m
 								MULf $m %0 $m
 								MOVf $y #1.0 					; a = n = y = 1.0
 								MOVf $n #1.0 
 								MOVf $a #1.0 
 					.l0:		MOVf $t $y 						; t = y
 								MULf %0 $n $n					; a = a * m / (n * n + n)
 								MULf %1 $a $m
 								ADDf %0 %0 $n
 								DIVf $a %1 %0
 								ADDf $y $y $a					; y = y + a
 								ADDf $n $n #2.0					; n = n + 2.0
 								NEQf $y $t @.l0					; } while (y != t)
 								ABSf %1 $y 						; if (abs(y) < COS_EPSILON) y = 0.0
 								GEQf %1 #COS_EPSILON @.f1
 								MOVf $y #0.0 					; y = 0.0
 					.f1:		RETU   							; }

 COS_TABLE_BITS:	! DEFi #12
 					! SHLi <A> #1 #COS_TABLE_BITS
 COS_TABLE_SIZE:	! DEFi <A>
 BATCH_SIZE:		! DEFi #77
 					! ADDi <A> #COS_TABLE_SIZE #1
 cosTable:			GLOB *<A>
 					GLOB *1
 doReset:			DATi #FALSE
 					GLOB *1
 rate:				DATi #0
 					GLOB *1
 diff:				DATi #0
 					GLOB *1
 delayL:			DATi #0
 					GLOB *1
 delayR:			DATi #0
 					GLOB *1
 syncBit:			DATi #0

 ;-----------------------------------------------------------------------------
 init:				FUNC
 								PARA *1
 					$i:			LOCi
 					$buf:		LOCA *256
 ;-----------------------------------------------------------------------------
 								MOVp %1 &.s_init53eb0793 		; trace("init")
 								CALL ^trace %0 *2
 								PEEK %2 &instance 				; trace(intToString(global instance, 10, 1, buf))
 								MOVi %3 #10 
 								MOVi %4 #1 
 								ADRL %5 $buf *0
 								CALL &intToString %1 *5
 								CALL ^trace %0 *2
 								MOVi $i #0 						; for (i = 0 to COS_TABLE_SIZE) global cosTable[i] = ftoi((float) cos((TWICE_PI / itof(COS_TABLE_SIZE)) * itof(i)) * 2048.0)
 								GEQi #0 #COS_TABLE_SIZE @.e0
 					.l1:		NOOP
 								! iTOf <A> #COS_TABLE_SIZE #1.0	; global cosTable[i] = ftoi((float) cos((TWICE_PI / itof(COS_TABLE_SIZE)) * itof(i)) * 2048.0)
 								! DIVf <A> #TWICE_PI <A>
 								iTOf %1 $i <A>
 								CALL &cos %0 *2
 								fTOi %0 %0 #2048.0
 								POKE &cosTable $i %0
 								FORi $i #COS_TABLE_SIZE @.l1
 					.e0:		PEEK %0 &cosTable:0 			; global cosTable[COS_TABLE_SIZE] = global cosTable[0]
 								POKE &cosTable:COS_TABLE_SIZE %0 
 								RETU   							; }


 ;-----------------------------------------------------------------------------
 reset:				FUNC
 								PARA *1
 ;-----------------------------------------------------------------------------
 								MOVp %1 &.s_reset53eb0794 		; trace("reset")
 								CALL ^trace %0 *2
 								MOVp %1 &.s_params53eb0795 		; traceInts(" params: ", PARAM_COUNT, global params)
 								MOVi %2 #PARAM_COUNT 
 								MOVp %3 &params 
 								CALL &traceInts %0 *4
 								POKE &doReset #TRUE 			; global doReset = TRUE
 								RETU   							; }


 ;-----------------------------------------------------------------------------
 displayDelayValue:	FUNC
 					$y:			OUTi
 					$x:			LOCi
 ;-----------------------------------------------------------------------------
 								! SUBi <A> #8 #3				; y = 0x1 << (x >> (8 - 3))
 								SHRi %0 $x <A>
 								SHLi $y #0x1 %0
 								RETU   							; }


 ;-----------------------------------------------------------------------------
 update:			FUNC
 								PARA *1
 					$buf:		LOCA *256
 					$params:	LOCA *PARAM_COUNT
 ;-----------------------------------------------------------------------------
 								MOVp %1 &.s_update53eb0796 		; trace("update")
 								CALL ^trace %0 *2
 								MOVp %1 &.s_params53eb0795 		; traceInts(" params: ", PARAM_COUNT, global params)
 								MOVi %2 #PARAM_COUNT 
 								MOVp %3 &params 
 								CALL &traceInts %0 *4
 								ADRL %0 $params *0				; copy (PARAM_COUNT from global params to params)
 								COPY %0 &params *PARAM_COUNT
 								PEEK %0 &EIGHT_BIT_EXP_TABLE $params:OPERAND_1_HIGH_PARAM_INDEX	; global delayL = (int) global EIGHT_BIT_EXP_TABLE[(int) params[OPERAND_1_HIGH_PARAM_INDEX]]
 								POKE &delayL %0 
 								MOVi %1 $params:OPERAND_1_HIGH_PARAM_INDEX 	; global displayLEDs[0] = displayDelayValue((int) params[OPERAND_1_HIGH_PARAM_INDEX])
 								CALL &displayDelayValue %0 *2
 								POKE &displayLEDs:0 %0 
 								PEEK %0 &EIGHT_BIT_EXP_TABLE $params:OPERAND_1_LOW_PARAM_INDEX ; global delayR = (int) global EIGHT_BIT_EXP_TABLE[(int) params[OPERAND_1_LOW_PARAM_INDEX]]
 								POKE &delayR %0 
 								MOVi %1 $params:OPERAND_1_LOW_PARAM_INDEX  ; global displayLEDs[1] = displayDelayValue((int) params[OPERAND_1_LOW_PARAM_INDEX])
 								CALL &displayDelayValue %0 *2
 								POKE &displayLEDs:1 %0 
 								PEEK %0 &EIGHT_BIT_EXP_TABLE $params:OPERAND_2_HIGH_PARAM_INDEX	; global rate = (int) global EIGHT_BIT_EXP_TABLE[(int) params[OPERAND_2_HIGH_PARAM_INDEX]]
 								POKE &rate %0 
 								SHLi %0 $params:OPERAND_2_LOW_PARAM_INDEX #8 ; global diff = (int) params[OPERAND_2_LOW_PARAM_INDEX] << 8
 								POKE &diff %0 
 								MOVi %1 $params:OPERAND_2_LOW_PARAM_INDEX  ; global displayLEDs[3] = displayDelayValue((int) params[OPERAND_2_LOW_PARAM_INDEX])
 								CALL &displayDelayValue %0 *2
 								POKE &displayLEDs:3 %0 
 								PEEK %0 &params:SWITCHES_PARAM_INDEX  ; global syncBit = (int) global params[SWITCHES_PARAM_INDEX] & SWITCHES_SYNC_MASK
 								ANDi %0 %0 #SWITCHES_SYNC_MASK
 								POKE &syncBit %0 
 								RETU   							; }


 ;-----------------------------------------------------------------------------
 process:			FUNC
 								PARA *1
 					$i:			LOCi
 					$c0:		LOCi
 					$c1:		LOCi
 					$cosL:		LOCi
 					$cosR:		LOCi
 					$p:			LOCp
 					$f:			LOCi
 					$idx:		LOCi
 					$idxr:		LOCi
 					$rate:		LOCi
 					$diff:		LOCi
 					$delayL:	LOCi
 					$delayR:	LOCi
 					$clock:		LOCi
 					$leftPair:	LOCA *2
 					$rightPair:	LOCA *2
 ;-----------------------------------------------------------------------------
 								MOVi $idx #0 					; idx = 0
 					.l0:		PEEK %0 &doReset 				; if (global doReset != FALSE) 
 								EQUi %0 #FALSE @.f1
 								MOVi $idx #0 					; idx = 0
 								POKE &doReset #FALSE 			; global doReset = FALSE
 					.f1:		PEEK $rate &rate 				; rate = global rate
 								PEEK $diff &diff 				; diff = global diff
 								PEEK $delayL &delayL 			; delayL = global delayL
 								PEEK $delayR &delayR 			; delayR = global delayR
 								ADDi %0 $cosL #0x8000			; global displayLEDs[2] = 0x01 << ((cosL + 0x8000) >> (16 - 3))
 								! SUBi <A> #16 #3
 								SHRi %0 %0 <A>
 								SHLi %0 #0x01 %0
 								POKE &displayLEDs:2 %0 
 								PEEK %0 &syncBit 				; if (global syncBit != 0) idx = (global clock * rate)
 								EQUi %0 #0 @.f2
 								PEEK %0 &clock 					; idx = (global clock * rate)
 								MULi $idx %0 $rate
 					.f2:		MOVi $i #0 						; for (i = 0 to BATCH_SIZE) 
 								GEQi #0 #BATCH_SIZE @.l0
 					.l4:		PEEK $clock &clock 				; clock = global clock
 								MOVi %1 $clock 					; write(clock, 1, global signal)
 								MOVi %2 #1 
 								MOVp %3 &signal 
 								CALL ^write %0 *4
 								ANDi $idx $idx #0xFFFF			; idx = idx & 0xFFFF
 								! SUBi <A> #16 #COS_TABLE_BITS	; p = &global cosTable[idx >> (16 - COS_TABLE_BITS)]
 								SHRi %0 $idx <A>
 								ADDp $p &cosTable %0
 								PEEK $c0 $p 					; c0 = (int) *p
 								PEEK $c1 $p #1					; c1 = (int) p[1]
 								! SUBi <A> #16 #COS_TABLE_BITS	; f = idx & ((1 << (16 - COS_TABLE_BITS)) - 1)
 								! SHLi <A> #1 <A>
 								! SUBi <A> <A> #1
 								ANDi $f $idx <A>
 								! SUBi <A> #16 #COS_TABLE_BITS	; cosL = (c0 << (16 - COS_TABLE_BITS)) + ((c1 - c0) * f)
 								SUBi %0 $c1 $c0
 								SHLi %1 $c0 <A>
 								MULi %0 %0 $f
 								ADDi $cosL %1 %0
 								ADDi %1 $idx $diff				; idxr = (idx + diff) & 0xFFFF
 								ANDi $idxr %1 #0xFFFF
 								! SUBi <A> #16 #COS_TABLE_BITS	; p = &global cosTable[idxr >> (16 - COS_TABLE_BITS)]
 								SHRi %1 $idxr <A>
 								ADDp $p &cosTable %1
 								PEEK $c0 $p 					; c0 = (int) *p
 								PEEK $c1 $p #1					; c1 = (int) p[1]
 								! SUBi <A> #16 #COS_TABLE_BITS	; f = idxr & ((1 << (16 - COS_TABLE_BITS)) - 1)
 								! SHLi <A> #1 <A>
 								! SUBi <A> <A> #1
 								ANDi $f $idxr <A>
 								! SUBi <A> #16 #COS_TABLE_BITS	; cosR = (c0 << (16 - COS_TABLE_BITS)) + ((c1 - c0) * f)
 								SUBi %1 $c1 $c0
 								SHLi %0 $c0 <A>
 								MULi %1 %1 $f
 								ADDi $cosR %0 %1
 								SUBi %1 $clock $delayL			; read(clock - delayL, 1, leftPair)
 								MOVi %2 #1 
 								ADRL %3 $leftPair *0
 								CALL ^read %0 *4
 								SUBi %1 $clock $delayR			; read(clock - delayR, 1, rightPair)
 								MOVi %2 #1 
 								ADRL %3 $rightPair *0
 								CALL ^read %0 *4
 								MULi %0 $leftPair:0 $cosL		; global signal[0] = ((int) leftPair[0] * cosL) >> 15
 								SHRi %0 %0 #15
 								POKE &signal:0 %0 
 								MULi %0 $rightPair:1 $cosR		; global signal[1] = ((int) rightPair[1] * cosR) >> 15
 								SHRi %0 %0 #15
 								POKE &signal:1 %0 
 								ADDi $idx $idx $rate			; idx = idx + rate
 								CALL ^yield %0 *1				; yield()
 								FORi $i #BATCH_SIZE @.l4		; }
 								GOTO @.l0  						; }
 								RETU   							; }

 .s_53eb078e:		CNST *2
 					DATi #32 #0
 .s_LEFTDE53eb078f:	CNST *54
 					DATi #32 #32 #32 #32
 					DATs |----- LEFT DELAY -----| |----- RIGHT DELAY ----|
 					DATi #0
 .s_RINGMO53eb0790:	CNST *54
 					DATi #32 #32 #32 #32
 					DATs |--- RING MOD RATE ----| |---- STEREO PHASE ----|
 					DATi #0
 .s_fedcba53eb0791:	CNST *32
 					DATs fedcba9876543210123456789abcdef
 					DATi #0
 .s_Divisi53eb0792:	CNST *17
 					DATs Division by zero
 					DATi #0
 .s_init53eb0793:	CNST *5
 					DATs init
 					DATi #0
 .s_reset53eb0794:	CNST *6
 					DATs reset
 					DATi #0
 .s_params53eb0795:	CNST *10
 					DATi #32
 					DATs params:
 					DATi #32 #0
 .s_update53eb0796:	CNST *7
 					DATs update
 					DATi #0
 					! EQUi #DEBUG #0 @.noAssertStrings
 .a_2radix53eb078e:	CNST *28
 					DATs (2 <= radix && radix <= 16)
 					DATi #0
 .a_0minLe53eb078f:	CNST *48
 					DATs (0 <= minLength && minLength <= GAZL_WORD_SIZE)
 					DATi #0
 .a_pbuffe53eb0790:	CNST *18
 					DATs (p >= buffer + 2)
 					DATi #0
 .noAssertStrings:	!
