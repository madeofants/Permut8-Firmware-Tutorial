<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Permut8 Firmware Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fafafa;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; border-bottom: 2px solid #ecf0f1; padding-bottom: 5px; margin-top: 40px; }
        h3 { color: #7f8c8d; margin-top: 30px; }
        code {
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        pre {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
        }
        pre code {
            background: none;
            padding: 0;
        }
        .nav-toc {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        .nav-toc h2 {
            margin-top: 0;
            color: #2c3e50;
        }
        .nav-toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .nav-toc li {
            margin: 5px 0;
        }
        .nav-toc a {
            color: #3498db;
            text-decoration: none;
            padding: 2px 0;
        }
        .nav-toc a:hover {
            text-decoration: underline;
        }
        .file-section {
            margin: 40px 0;
            padding: 20px 0;
            border-top: 1px solid #ecf0f1;
        }
        .file-title {
            background: #3498db;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        blockquote {
            border-left: 4px solid #f39c12;
            background: #fef9e7;
            margin: 0;
            padding: 10px 20px;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .generation-info {
            background: #e8f6f3;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            border-left: 4px solid #27ae60;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéõÔ∏è Permut8 Firmware Documentation</h1>
        
        <div class="generation-info">
            <strong>üìñ Complete Documentation</strong><br>
            Generated: June 15, 2025 at 08:57 AM<br>
            All documentation files combined into a single HTML document for offline reference.
        </div>

        <div class="nav-toc">
            <h2>üìã Table of Contents</h2>
            <ul>
<li><a href="#quickstart">Quickstart</a></li>
<li><a href="#how-dsp-affects-sound">How Dsp Affects Sound</a></li>
<li><a href="#getting-audio-in-and-out">Getting Audio In And Out</a></li>
<li><a href="#simplest-distortion">Simplest Distortion</a></li>
<li><a href="#core-language-reference">Core Language Reference</a></li>
<li><a href="#language-syntax-reference">Language Syntax Reference</a></li>
<li><a href="#standard-library-reference">Standard Library Reference</a></li>
<li><a href="#types-and-operators">Types And Operators</a></li>
<li><a href="#core-functions">Core Functions</a></li>
<li><a href="#memory-layout">Memory Layout</a></li>
<li><a href="#memory-model">Memory Model</a></li>
<li><a href="#processing-order">Processing Order</a></li>
<li><a href="#state-management">State Management</a></li>
<li><a href="#p8bank-format">P8Bank Format</a></li>
<li><a href="#creating-firmware-banks">Creating Firmware Banks</a></li>
<li><a href="#compiler-troubleshooting-guide">Compiler Troubleshooting Guide</a></li>
<li><a href="#complete-development-workflow">Complete Development Workflow</a></li>
<li><a href="#debug-your-plugin">Debug Your Plugin</a></li>
<li><a href="#mod-vs-full-architecture-guide">Mod Vs Full Architecture Guide</a></li>
<li><a href="#basic-filter">Basic Filter</a></li>
<li><a href="#simplest-distortion">Simplest Distortion</a></li>
<li><a href="#bitcrusher">Bitcrusher</a></li>
<li><a href="#make-a-delay">Make A Delay</a></li>
            </ul>
        </div>

<div class="file-section" id="quickstart">
    <div class="file-title">üìÑ Quickstart</div>
    <h1>Permut8 Firmware in 30 Minutes</h1>
<p>Get your first custom firmware running on Permut8 in just 30 minutes!</p>
<h2>What is Firmware? (For Complete Beginners)</h2>
<p>If you're new to audio programming, here's what you need to know:</p>
<h3><strong>Firmware vs Plugins</strong></h3>
<ul><li><strong>Regular Audio Plugin</strong>: Software that processes audio on your computer</li><li><strong>Permut8 Firmware</strong>: Code that runs directly on Permut8 hardware for ultra-low latency</li></ul>
<h3><strong>Why Firmware?</strong></h3>
<ul><li><strong>No Computer Latency</strong>: Audio processing happens instantly on dedicated hardware</li><li><strong>Real-time Performance</strong>: Perfect for live performance and recording</li><li><strong>Custom Effects</strong>: Create effects that don't exist anywhere else</li><li><strong>Hardware Integration</strong>: Direct control from knobs and LEDs</li></ul>
<h3><strong>What You're Actually Doing</strong></h3>
When you write Permut8 firmware, you're creating instructions that tell the Permut8 hardware exactly how to modify audio signals in real-time. Every knob turn, every audio sample, every LED - your code controls it all.
<strong>Think of it like this</strong>: Instead of installing software on your computer, you're programming the brain of a dedicated audio computer that lives inside Permut8.
<h2>Five-Minute Setup</h2>
<h3>1. Check Your Installation</h3>
Navigate to your Permut8 Firmware Code directory and verify you have:
<pre><code>Permut8 Firmware Code/
‚îú‚îÄ‚îÄ PikaCmd.exe           # The Impala compiler
‚îú‚îÄ‚îÄ ringmod_code.impala   # Example firmware
‚îî‚îÄ‚îÄ linsub_code.impala    # Example firmware</code></pre>
<h3>2. Test the Compiler</h3>
Open a command prompt/terminal in this directory and run:
<pre><code>PikaCmd.exe -compile ringmod_code.impala</code></pre>
<strong>If you get an error</strong>, try this instead:
<pre><code>.\PikaCmd.exe impala.pika compile ringmod_code.impala ringmod_code.gazl</code></pre>
<p>You should see <code>ringmod_code.gazl</code> created - that's your compiled firmware!</p>
<strong>Why the different commands?</strong> See <a href="../tutorials/compiler-troubleshooting-guide.md">Compiler Troubleshooting Guide</a> for the technical explanation.
<h3>3. Create and Load Firmware Bank</h3>
1. Open Permut8 in your DAW
2. Create a firmware bank:
   - Package your <code>ringmod_code.gazl</code> into <code>ringmod.p8bank</code>
   - Add preset configuration (A0: "Ring Modulator")
3. Load bank: File ‚Üí Load Bank ‚Üí <code>ringmod.p8bank</code>
4. Select A0 preset
<strong>You just loaded custom firmware!</strong> The ring modulator is now running.
<h2>Your First Firmware (10 minutes)</h2>
<p>Let's create a simple bit crusher from scratch.</p>
<h3>1. Create a New File</h3>
Create <code>bitcrush.impala</code> with this code:
<pre><code>// Bit Crusher - Your First Permut8 Firmware
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>extern native yield</p>
<p>readonly array panelTextRows[8] = {
    "",
    "BIT |-------- CRUSH AMOUNT (MORE BITS = LESS CRUSH) --------|",
    "",
    "",
    "",
    "",
    "",
    ""
}</p>
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>function process()
locals int bits, int shift, int mask
{
    loop {
        bits = ((int) global params[3] >> 5) + 1;
        shift = 12 - bits;
        mask = 0xFFF0 << shift;
        
        global displayLEDs[0] = 1 << (bits - 1);
        
        global signal[0] = ((int) global signal[0]) & mask;
        global signal[1] = ((int) global signal[1]) & mask;
        
        yield();
    }
}</code></pre></p>
<h3>2. Compile Your Firmware</h3>
<pre><code>PikaCmd.exe -compile bitcrush.impala</code></pre>
<strong>If that doesn't work</strong>, use the full command:
<pre><code>.\PikaCmd.exe impala.pika compile bitcrush.impala bitcrush.gazl</code></pre>
<h3>3. Create Firmware Bank</h3>
<strong>Step 3a: Clean the GAZL File</strong>
Before creating the bank, you need to clean the compiled GAZL file:
<p>1. <strong>Open <code>bitcrush.gazl</code></strong> in a text editor
2. <strong>Remove the compiler comment line</strong> (if present):
   <pre><code>   ; Compiled with Impala version 1.0
   ``<code>
3. <strong>Remove any separator lines</strong> like:
   </code>`<code>
   ;-----------------------------------------------------------------------------
   </code>`<code>
4. <strong>Keep only the pure assembly code</strong></p>
<strong>Step 3b: Create the Bank File</strong>
Create </code>bitcrush.p8bank<code> with this <strong>exact format</strong> (note the header):</code></pre>
Permut8BankV2: {
    CurrentProgram: A0
    Programs: {
        A0: { Name: "Light Crush", Operator1: "2" }
        A1: { Name: "Heavy Crush", Operator1: "6" }
    }
    Firmware: {
        Name: "bitcrush"
        Code: {
[PASTE YOUR CLEANED GAZL CONTENT HERE]
 }
    }
}
<pre><code>
<h3>3. Prepare GAZL for Bank</h3>
<strong>Remove the first line</strong> from your compiled </code>bitcrush.gazl<code>:
1. Open </code>bitcrush.gazl<code> in any text editor
2. Delete the first line: </code>; Compiled with Impala version 1.0<code>
3. Save the file
<h3>4. Create Firmware Bank</h3>
Create </code>bitcrush.p8bank<code> with this <strong>exact format</strong> (note the header):</code></pre>
Permut8BankV2: {
    CurrentProgram: A0
    Programs: {
        A0: { Name: "Light Crush", Operator1: "2" }
        A1: { Name: "Heavy Crush", Operator1: "6" }
    }
    Firmware: {
        Name: "bitcrush"
        Code: {
[PASTE YOUR CLEANED GAZL CONTENT HERE]
 }
    }
}
<pre><code>
<strong>‚ö†Ô∏è Critical</strong>: 
<ul><li>Header MUST be </code>Permut8BankV2:<code> (not </code>bitcrush.p8bank:<code>)</li><li>Paste your entire cleaned </code>bitcrush.gazl<code> content between </code>Code: {<code> and </code> }<code></li></ul>
<h3>5. Load and Test</h3>
1. Load bank: File ‚Üí Load Bank ‚Üí </code>bitcrush.p8bank<code>
2. Select A0 preset (Light Crush) or A1 (Heavy Crush)
3. Play some audio through Permut8
4. Turn <strong>knob 4</strong> (not knob 1!) - hear the bit crushing!
<strong>Congratulations!</strong> You just created working DSP firmware. Knob 4 now controls bit depth, creating that classic lo-fi digital sound.
<h2>Modify Existing Firmware (15 minutes)</h2>
<p>Let's add LED animation to the ring modulator.</p>
<h3>1. Copy the Original</h3>
Make a copy of </code>ringmod_code.impala<code> called </code>ringmod_leds.impala<code>
<h3>2. Find the LED Code</h3>
Look for this line (around line 272):</code></pre>impala
global displayLEDs[2] = 0x01 << ((cosL + 0x8000) >> (16 - 3));
<pre><code>
<h3>3. Add Rainbow LED Animation</h3>
Replace that line with:</code></pre>impala
// Rainbow LED animation synced to modulation
global displayLEDs[0] = 0x01 << ((cosL + 0x8000) >> (16 - 3));
global displayLEDs[1] = 0x01 << ((cosR + 0x8000) >> (16 - 3));
global displayLEDs[2] = 0x01 << (((cosL + cosR) + 0x10000) >> (17 - 3));
global displayLEDs[3] = global displayLEDs[0] | global displayLEDs[1];
<pre><code>
<h3>4. Compile and Load</h3></code></pre>bash
PikaCmd.exe -compile ringmod_leds.impala
</code>`<code>
Load bank: File ‚Üí Load Bank ‚Üí </code>ringmod_leds.p8bank<code>
<p>Now all four LED displays dance with the ring modulation!</p>
<h3>5. Try More Modifications</h3>
<ul><li>Change delay times: Find </code>delayL<code> and </code>delayR<code> calculations</li><li>Adjust modulation shape: Look for the </code>cosTable<code> </li><li>Add parameter smoothing: Implement interpolation in </code>update()<code></li></ul>
<h2>What's Next?</h2>
<h3><strong>New to Audio Programming?</strong> Start with the foundation:</h3>
1. üìñ <a href="../cookbook/fundamentals/how-dsp-affects-sound.md">How DSP Affects Sound</a> - Understand how code creates audio effects (20 min)
2. üìñ <a href="../tutorials/getting-audio-in-and-out.md">Getting Audio In and Out</a> - Foundation I/O tutorial (10 min)
3. üìñ <a href="../cookbook/fundamentals/simplest-distortion.md">Your First Distortion Effect</a> - Progressive effect building (15 min)
<h3><strong>Ready for More Effects?</strong> Based on what you just did:</h3>
<strong>Created a bit crusher?</strong> ‚Üí Try these effects next:
<ul><li>üìñ <a href="../cookbook/fundamentals/basic-filter.md">Basic Filter</a> - Add resonance</li><li>üìñ <a href="../cookbook/audio-effects/bitcrusher.md">Bitcrusher</a> - More lo-fi options</li><li>üìñ <a href="../cookbook/parameters/parameter-smoothing.md">Parameter Smoothing</a> - Remove clicks</li></ul>
<strong>Modified the ring mod?</strong> ‚Üí Explore these:
<ul><li>üìñ <a href="../cookbook/visual-feedback/control-leds.md">Control LEDs</a> - More patterns</li><li>üìñ <a href="../cookbook/timing/sync-to-tempo.md">Sync to Tempo</a> - Beat-synced effects</li><li>üìñ <a href="../cookbook/audio-effects/make-a-delay.md">Make a Delay</a> - Use the memory buffer</li></ul>
<h3><strong>Understanding Permut8 Architecture:</strong></h3>
<strong>Which firmware type should you choose?</strong>
<ul><li><strong>Full Patches</strong> (like our bit crusher): Replace entire DSP engine, process audio samples directly</li><li><strong>Mod Patches</strong> (like linsub): Modify built-in operators, manipulate memory positions</li></ul>
<p>üìñ <a href="../tutorials/mod-vs-full-architecture-guide.md">Mod vs Full Architecture Guide</a> - Critical decision guidance</p>
<h3><strong>Professional Development:</strong></h3>
<ul><li>üìñ <a href="../tutorials/complete-development-workflow.md">Complete Development Workflow</a> - Systematic methodology</li><li>üìñ <a href="../tutorials/debug-your-plugin.md">Debug Your Plugin</a> - Essential troubleshooting</li></ul>
<h3>Quick Tips:</h3>
<ul><li></code>global signal[0]<code> = left channel, </code>global signal[1]<code> = right channel</li><li>Audio samples range from -2047 to 2047 (12-bit)</li><li></code>yield()<code> returns control to Permut8 after each sample</li><li></code>global params[]<code> contains all knob values (0-255)</li></ul>
<h3>Problems?</h3>
<strong>Bank Loading Issues:</strong>
<ul><li><strong>"Invalid data format (unsupported version?)"</strong> ‚Üí Check bank header format:</li></ul>
  - Must start with </code>Permut8BankV2: {<code> (not filename-based header)
  - Header format is case-sensitive and exact
<ul><li><strong>"Invalid mnemonic: Compiled"</strong> ‚Üí Clean your GAZL file:</li></ul>
  - Remove compiler comment: </code>; Compiled with Impala version 1.0<code>
  - Remove from first line of .gazl file before creating bank
<ul><li><strong>"Invalid mnemonic" with dashes</strong> ‚Üí Remove separator lines:</li></ul>
  - Remove lines like </code>;-----------------------------------------------------------------------------<code>
  - Keep only pure assembly code in bank
<strong>Compilation Issues:</strong>
<ul><li><strong>Command not recognized?</strong> Try </code>.\PikaCmd.exe impala.pika compile input.impala output.gazl<code></li><li><strong>"Cannot open file for reading"?</strong> You need the script: </code>.\PikaCmd.exe impala.pika compile ...<code></li><li><strong>Still having trouble?</strong> See <a href="../tutorials/compiler-troubleshooting-guide.md">Compiler Troubleshooting Guide</a></li></ul>
<strong>Runtime Issues:</strong>
<ul><li><strong>Firmware won't compile?</strong> Check for missing semicolons and proper syntax</li><li><strong>No sound?</strong> Make sure you called </code>yield()` in your loop</li><li><strong>LEDs not working?</strong> Values should be 8-bit (0-255)</li></ul>
<p>---</p>
<strong>Ready for more?</strong> The cookbook has 24+ ready-to-use recipes. Each one is complete, working code you can copy and modify. Start with any effect that interests you!
</div>


<div class="file-section" id="how-dsp-affects-sound">
    <div class="file-title">üìÑ How Dsp Affects Sound</div>
    <h1>How DSP Affects Sound</h1>
<em>Understanding how code changes create audio effects - Foundation tutorial for complete beginners (20 minutes)</em>
<p>---</p>
<h2>What You'll Learn</h2>
<p>By the end of this tutorial, you'll understand:
<ul><li>What audio samples are and how numbers become sound</li><li>How changing numbers in code changes what you hear</li><li>The fundamental relationship between programming and audio effects</li><li>Your first working sound modification</li></ul></p>
<strong>Prerequisites</strong>: None - this is for complete audio programming beginners  
<strong>Time</strong>: 20 minutes reading + 5 minutes hands-on  
<strong>Next Tutorial</strong>: <a href="getting-audio-in-and-out.md">Getting Audio In and Out</a>
<p>---</p>
<h2>Part 1: Numbers Become Sound (5 minutes)</h2>
<h3>The Magic Translation</h3>
<p>When you hear music from your computer, something amazing is happening: <strong>numbers are being turned into sound waves</strong>. Every fraction of a second, thousands of numbers flow from your software to your speakers, and those numbers control exactly what you hear.</p>
<h3>What is an Audio Sample?</h3>
<p>An <strong>audio sample</strong> is just a number that represents the position of a speaker cone at one tiny moment in time.</p>
<pre><code>Positive numbers ‚Üí Speaker pushes out ‚Üí You hear sound
Negative numbers ‚Üí Speaker pulls in ‚Üí You hear sound  
Zero ‚Üí Speaker stays still ‚Üí Silence</code></pre>
<h3>In Permut8 Firmware</h3>
<p>In Impala, audio samples are integers from <strong>-2047 to +2047</strong>:</p>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
extern native yield
<p>global array signal[2]  // [left channel, right channel]
global array params[8]  // Hardware knob values (0-255)</p>
<p>function process() {
    loop {
        // signal[0] = some number between -2047 and +2047
        // signal[1] = some number between -2047 and +2047
        yield();  // Send these numbers to the speakers
    }
}</code></pre></p>
<strong>Key Insight</strong>: Every time your code runs, it puts two numbers into <code>signal[0]</code> and <code>signal[1]</code>. Those numbers immediately become the sound you hear through your left and right speakers.
<p>---</p>
<h2>Part 2: Changing Numbers Changes Sound (10 minutes)</h2>
<p>Now for the exciting part: <strong>when you change the numbers in code, you change what people hear</strong>. This is the fundamental principle of Digital Signal Processing (DSP).</p>
<h3>Basic Sound Changes</h3>
<p>Here are the most fundamental ways code affects sound:</p>
<p>#### 1. Make it Louder (Multiply by Bigger Number)
<pre><code>signal[0] = signal[0] * 2;  // Twice as loud
signal[1] = signal[1] * 2;  // Both channels</code></pre>
<strong>What Happens</strong>: Every audio sample gets bigger ‚Üí Speaker moves more ‚Üí Sound is louder</p>
<p>#### 2. Make it Quieter (Multiply by Smaller Number)
<pre><code>signal[0] = signal[0] / 2;  // Half as loud
signal[1] = signal[1] / 2;  // Both channels</code></pre>
<strong>What Happens</strong>: Every audio sample gets smaller ‚Üí Speaker moves less ‚Üí Sound is quieter</p>
<p>#### 3. Add Distortion (Push Beyond Limits)
<pre><code>signal[0] = signal[0] * 5;  // Way too loud!
// Permut8 automatically prevents damage by limiting to ¬±2047
// But this creates distortion - harsh, buzzy sound</code></pre>
<strong>What Happens</strong>: Numbers try to go beyond ¬±2047 ‚Üí Get "clipped" ‚Üí Creates distortion</p>
<p>#### 4. Mix Two Sounds (Add Numbers)
<pre><code>int originalSound = signal[0];
int synthesizedSound = 1000;  // A constant tone
signal[0] = originalSound + synthesizedSound;  // Mix them!</code></pre>
<strong>What Happens</strong>: Two sound sources combine ‚Üí You hear both at once</p>
<p>#### 5. Create Echo (Use Old Numbers)
<pre><code>global array delayBuffer[1000];  // Store old audio
global int delayPos = 0;</p>
<p>// In your process() loop:
int currentAudio = signal[0];
int oldAudio = delayBuffer[delayPos];  // Audio from 1000 samples ago</p>
<p>signal[0] = currentAudio + (oldAudio / 2);  // Mix current + old = echo!</p>
<p>delayBuffer[delayPos] = currentAudio;  // Remember this audio for later
delayPos = (delayPos + 1) % 1000;      // Move to next position</code></pre>
<strong>What Happens</strong>: You hear current audio + audio from the past ‚Üí Echo effect!</p>
<h3>The Pattern</h3>
<p>Do you see the pattern? <strong>Every audio effect is just a different way of calculating numbers</strong>:</p>
<ul><li><strong>Volume</strong>: Multiply samples</li><li><strong>Distortion</strong>: Make samples too big</li><li><strong>Mixing</strong>: Add samples together  </li><li><strong>Echo</strong>: Use old samples</li><li><strong>Filtering</strong>: Average nearby samples</li><li><strong>Tremolo</strong>: Multiply by changing numbers</li><li><strong>Ring Modulation</strong>: Multiply by oscillating numbers</li></ul>
<strong>Programming + Math = Any Sound Effect You Can Imagine</strong>
<p>---</p>
<h2>Part 3: Your First Sound Change (5 minutes)</h2>
<p>Let's make your first audio modification! This will prove that code changes immediately affect what you hear.</p>
<h3>Complete Working Example</h3>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
extern native yield
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>function process() {
    loop {
        // Read the current audio coming into Permut8
        int leftInput = signal[0];
        int rightInput = signal[1];
        
        // CHANGE THE SOUND: Make it quieter using Knob 1
        int volumeKnob = params[0];  // 0-255 from hardware
        int volumeAmount = volumeKnob + 1;  // 1-256 (never zero)
        
        // Apply the volume change
        signal[0] = (leftInput * volumeAmount) / 256;
        signal[1] = (rightInput * volumeAmount) / 256;
        
        // Visual feedback: Show the volume on LED display
        displayLEDs[0] = volumeKnob;
        
        yield();  // Send the modified audio to speakers
    }
}</code></pre></p>
<h3>What This Code Does</h3>
<p>1. <strong>Reads</strong> the incoming audio samples
2. <strong>Reads</strong> Knob 1 position (0-255)
3. <strong>Calculates</strong> a volume multiplier (1-256)
4. <strong>Multiplies</strong> each audio sample by the volume amount
5. <strong>Shows</strong> the current volume on the LED display
6. <strong>Outputs</strong> the modified audio</p>
<h3>Try It!</h3>
<p>1. <strong>Compile</strong> this code: <code>PikaCmd.exe compile volume_control.impala</code>
2. <strong>Create and load bank</strong>: File ‚Üí Load Bank ‚Üí <code>volume_control.p8bank</code>
3. <strong>Select A0 preset</strong>
4. <strong>Play</strong> some audio through Permut8
5. <strong>Turn Knob 1</strong> and hear the volume change in real-time!</p>
<strong>You just modified sound with code!</strong> Turn the knob left (quieter) and right (louder). The LED display shows exactly what's happening.
<p>---</p>
<h2>Understanding What Just Happened</h2>
<h3>The DSP Loop</h3>
<p>Every time through the <code>loop</code>, your code:
1. <strong>Receives</strong> new audio samples (what's coming in)
2. <strong>Modifies</strong> those samples (your effect processing)
3. <strong>Outputs</strong> the modified samples (what people hear)
4. <strong>Repeats</strong> 44,100 times per second!</p>
<h3>Real-Time Processing</h3>
<p>This happens <strong>44,100 times every second</strong>. That's why turning the knob immediately changes the sound - your code is running constantly, modifying every single audio sample as it flows through Permut8.</p>
<h3>From Simple to Complex</h3>
<p>The volume control you just built uses the same fundamental principles as professional audio effects:</p>
<ul><li><strong>Professional EQ</strong>: Different math for different frequencies</li><li><strong>Professional Reverb</strong>: Complex delay and mixing calculations  </li><li><strong>Professional Compression</strong>: Dynamic volume calculations</li><li><strong>Professional Distortion</strong>: Controlled sample limiting and shaping</li></ul>
<strong>Every audio effect is built from these same building blocks: reading samples, doing math, outputting results.</strong>
<p>---</p>
<h2>Key Concepts Learned</h2>
<h3>1. Audio Samples Are Numbers</h3>
<ul><li>Sound = streams of numbers flowing to speakers</li><li>In Permut8: integers from -2047 to +2047</li><li>Every number controls speaker position at one moment</li></ul>
<h3>2. Code Changes = Sound Changes  </h3>
<ul><li>Multiply samples ‚Üí Volume changes</li><li>Add samples ‚Üí Mixing effects</li><li>Limit samples ‚Üí Distortion effects</li><li>Delay samples ‚Üí Echo effects</li></ul>
<h3>3. Real-Time Processing</h3>
<ul><li>Your code runs 44,100 times per second</li><li>Every sample gets processed individually</li><li>Changes happen immediately when you modify code</li></ul>
<h3>4. Effects Are Math</h3>
<ul><li>Volume = multiplication</li><li>Distortion = limiting  </li><li>Echo = delayed addition</li><li>Complex effects = combinations of simple math</li></ul>
<p>---</p>
<h2>What's Next?</h2>
<p>Now that you understand how code affects sound, you're ready for:</p>
<h3><strong>Immediate Next Steps</strong>:</h3>
1. <strong><a href="getting-audio-in-and-out.md">Getting Audio In and Out</a></strong> - Learn the basic I/O structure
2. <strong><a href="simplest-distortion.md">Your First Distortion Effect</a></strong> - Build a working guitar effect
3. <strong><a href="../../../fundamentals/audio-engineering-for-programmers.md">Audio Engineering for Programmers</a></strong> - Professional concepts
<h3><strong>Advanced Learning Path</strong>:</h3>
<ul><li><strong><a href="../../parameters/read-knobs.md">Control Something with Knobs</a></strong> - Hardware interface</li><li><strong><a href="../../tutorials/complete-development-workflow.md">Complete Development Workflow</a></strong> - Professional practices</li><li><strong><a href="../../tutorials/debug-your-plugin.md">Debug Your Plugin</a></strong> - Troubleshooting skills</li></ul>
<p>---</p>
<h2>Quick Reference</h2>
<h3><strong>Essential Pattern for All Effects</strong>:</h3>
<pre><code>function process() {
    loop {
        // 1. Read current audio
        int input = signal[0];
        
        // 2. Do some math to change it
        int output = input * someModification;
        
        // 3. Send modified audio to speakers
        signal[0] = output;
        
        yield();  // Repeat 44,100 times per second
    }
}</code></pre>
<h3><strong>Remember</strong>: </h3>
<ul><li><strong>Every effect</strong> is just different math applied to audio samples</li><li><strong>Code changes</strong> immediately become <strong>sound changes</strong></li><li><strong>Start simple</strong> and build complexity gradually</li><li><strong>Real-time</strong> means your code affects every sample as it flows through</li></ul>
<p>You now understand the fundamental relationship between programming and audio. Every professional audio effect started with these same basic concepts!</p>
<p>---</p>
<em>Next: <a href="getting-audio-in-and-out.md">Getting Audio In and Out</a> - Learn the foundational I/O structure for building effects</em>
</div>


<div class="file-section" id="getting-audio-in-and-out">
    <div class="file-title">üìÑ Getting Audio In And Out</div>
    <h1>Getting Audio In and Out - Your First Working Plugin</h1>
<h2>What This Tutorial Does</h2>
Create the simplest possible working plugin that proves your Permut8 setup is working. In just 10 minutes, you'll have audio passing through your own custom firmware and understand the basic structure every plugin needs.
<h2>What You'll Learn</h2>
<ul><li>Essential plugin structure that every firmware needs</li><li>How audio flows into and out of your plugin</li><li>The minimal code required for a working plugin</li><li>How to verify your development environment is working</li><li>Foundation concepts for all future plugin development</li></ul>
<strong>Prerequisites</strong>: None - this is your starting point!  
<strong>Time Required</strong>: 10 minutes  
<strong>Difficulty</strong>: Absolute Beginner
<p>---</p>
<h2>Step 1: Understanding the Goal</h2>
<h3>1.1 What We're Building</h3>
A plugin that:
<ul><li>‚úÖ Loads successfully into Permut8</li><li>‚úÖ Passes audio through unchanged</li><li>‚úÖ Proves your development environment works</li><li>‚úÖ Gives you the foundation for all future plugins</li></ul>
<h3>1.2 Success Criteria</h3>
<strong>When this tutorial is complete:</strong>
<ul><li>You hear audio playing through your custom plugin</li><li>The audio sounds identical to the original (no changes)</li><li>You understand the basic structure every plugin needs</li><li>You're ready to start modifying and creating effects</li></ul>
<p>---</p>
<h2>Step 2: Create Your First Plugin</h2>
<h3>2.1 The Absolute Minimum Code</h3>
Create a new text file called <code>audio_passthrough.impala</code>:
<pre><code>// My First Plugin - Audio Passthrough
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>function process()
{
    loop {
        // Audio automatically passes through - we don't need to do anything!
        yield()
    }
}</code></pre></p>
<h3>2.2 Understanding Each Line</h3>
<strong>Line 1: Comment</strong>
<pre><code>// My First Plugin - Audio Passthrough</code></pre>
<ul><li>Comments start with <code>//</code> and help you remember what your code does</li><li>Always document your plugins for future reference</li></ul>
<strong>Line 2: Format Declaration</strong>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2</code></pre>
<ul><li><strong>REQUIRED</strong> - tells Permut8 this is a valid plugin</li><li>Must be exactly this line in every plugin you create</li><li>Version 2 is for Permut8 v1.1 and later</li></ul>
<strong>Lines 4-6: Global Variables</strong>
<pre><code>global array signal[2]      // Audio input and output
global array params[8]      // Knob values from hardware
global array displayLEDs[4] // LED display control</code></pre>
<ul><li><strong>REQUIRED</strong> - these connect your plugin to Permut8 hardware</li><li><code>signal[2]</code> = left and right audio channels</li><li><code>params[8]</code> = values from 8 knobs (we'll use these later)</li><li><code>displayLEDs[4]</code> = control for LED displays (we'll use these later)</li></ul>
<strong>Lines 8-14: Main Processing Function</strong>
<pre><code>function process()
{
    loop {
        // Audio automatically passes through
        yield()
    }
}</code></pre>
<ul><li><strong>REQUIRED</strong> - this function runs continuously while your plugin is active</li><li><code>loop { }</code> = infinite loop that processes audio forever</li><li><code>yield()</code> = <strong>CRITICAL</strong> - gives control back to Permut8 after each audio sample</li><li>Audio passes through automatically - you don't need to copy it manually</li></ul>
<p>---</p>
<h2>Step 3: Compile and Test</h2>
<h3>3.1 Compile Your Plugin</h3>
1. Open command prompt in your Permut8 Firmware Code directory
2. Type: <code>PikaCmd.exe -compile audio_passthrough.impala</code>
3. <strong>Expected result</strong>: You should see <code>audio_passthrough.gazl</code> created
4. <strong>If compilation fails</strong>: Check that you typed the code exactly as shown
<h3>3.2 Create and Load Firmware Bank</h3>
1. Open your DAW with Permut8 loaded
2. Package your firmware:
   <pre><code>   audio_passthrough.p8bank: {
       Programs: { A0: { Name: "Audio Passthrough" } }
       Firmware: { Name: "audio_passthrough", Code: {...} }
   }
   ``<code>
3. Load Bank: File ‚Üí Load Bank ‚Üí </code>audio_passthrough.p8bank<code>
4. Select A0 preset and test audio flow
<h3>3.3 Test Audio Passthrough</h3>
1. <strong>Play audio</strong> through Permut8 (any audio source will work)
2. <strong>Expected result</strong>: You should hear the audio exactly as it was before
3. <strong>Success indicator</strong>: Audio plays normally with no changes
4. <strong>If no audio</strong>: Check your DAW routing and Permut8 input/output settings
<strong>üéâ Congratulations!</strong> You just created and loaded your first custom Permut8 plugin!
<p>---</p>
<h2>Step 4: Understanding What Just Happened</h2>
<h3>4.1 The Audio Flow</h3></code></pre>
Audio Input ‚Üí Your Plugin ‚Üí Audio Output
<pre><code>
<strong>Behind the scenes:</strong>
1. Permut8 receives audio from your DAW
2. Permut8 puts audio samples into </code>signal[0]<code> (left) and </code>signal[1]<code> (right)
3. Your </code>process()<code> function runs once per audio sample
4. Since you didn't change </code>signal[0]<code> or </code>signal[1]<code>, audio passes through unchanged
5. Permut8 sends the audio back to your DAW
<h3>4.2 The Real-Time Loop</h3></code></pre>impala
loop {
    // This runs 44,100 times per second (at 44.1kHz sample rate)
    // Each time, it processes one audio sample
    yield()  // Give control back so next sample can be processed
}
<pre><code>
<strong>Key concept:</strong> Your plugin processes one tiny audio sample at a time, 44,100 times per second. The </code>yield()<code> is essential - without it, your plugin would hang and no audio would play.
<h3>4.3 Why This Matters</h3>
<strong>This simple structure is the foundation for EVERY plugin:</strong>
<ul><li>Want to make a volume control? Modify </code>signal[0]<code> and </code>signal[1]<code> before </code>yield()<code></li><li>Want to add delay? Store samples in a buffer before outputting them</li><li>Want to add distortion? Apply math to the signal values</li><li>Want LED feedback? Set values in </code>displayLEDs[]<code></li></ul>
<p>---</p>
<h2>Step 5: Make a Simple Modification</h2>
<h3>5.1 Add a Volume Control</h3>
Let's prove you can modify audio. Replace your </code>process()<code> function:
</code></pre>impala
function process()
{
    loop {
        // Reduce volume to half (simple volume control)
        signal[0] = signal[0] / 2  // Left channel half volume
        signal[1] = signal[1] / 2  // Right channel half volume
        
        yield()
    }
}
<pre><code>
<h3>5.2 Test the Volume Control</h3>
1. <strong>Compile</strong>: </code>PikaCmd.exe -compile audio_passthrough.impala<code>
2. <strong>Load</strong>: Load </code>audio_passthrough.gazl<code> via plugin interface
3. <strong>Expected result</strong>: Audio should now be quieter (half volume)
4. <strong>Success indicator</strong>: Clear volume reduction while maintaining audio quality
<h3>5.3 Understanding the Change</h3></code></pre>impala
signal[0] = signal[0] / 2  // Take left audio, divide by 2, put it back
signal[1] = signal[1] / 2  // Take right audio, divide by 2, put it back
<pre><code>
<strong>What this does:</strong>
<ul><li>Reads the current audio sample from </code>signal[0]<code> (left channel)</li><li>Divides it by 2 (making it half as loud)</li><li>Puts the modified sample back into </code>signal[0]<code></li><li>Does the same for the right channel</li><li>Audio flows out to your DAW with reduced volume</li></ul>
<p>---</p>
<h2>Step 6: Add LED Feedback</h2>
<h3>6.1 Visual Confirmation Your Plugin Is Running</h3>
Add this line before </code>yield()<code>:
</code></pre>impala
function process()
{
    loop {
        signal[0] = signal[0] / 2
        signal[1] = signal[1] / 2
        
        // Light up first LED to show plugin is active
        displayLEDs[0] = 0xFF  // 0xFF = all LEDs on in first display
        
        yield()
    }
}
<pre><code>
<h3>6.2 Test LED Feedback</h3>
1. <strong>Compile and load</strong> as before
2. <strong>Expected result</strong>: First LED display should light up fully
3. <strong>Success indicator</strong>: Visual confirmation your plugin is running
<h3>6.3 Understanding LED Control</h3></code></pre>impala
displayLEDs[0] = 0xFF  // First LED display, all 8 LEDs on
<pre><code>
<strong>LED values:</strong>
<ul><li></code>0x00<code> = all LEDs off</li><li></code>0x01<code> = only first LED on</li><li></code>0xFF<code> = all 8 LEDs on</li><li></code>0x0F<code> = first 4 LEDs on</li><li>You have 4 LED displays: </code>displayLEDs[0]<code> through </code>displayLEDs[3]<code></li></ul>
<p>---</p>
<h2>Step 7: Complete Working Plugin</h2>
<h3>7.1 Final Version with Comments</h3>
Here's your complete first plugin with full documentation:
</code></pre>impala
// Audio Passthrough with Volume Control - My First Plugin
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>// Required global variables that connect to Permut8 hardware
global array signal[2]      // Audio I/O: signal[0] = left, signal[1] = right
global array params[8]      // Knob values: params[0] through params[7] (0-255 each)
global array displayLEDs[4] // LED displays: displayLEDs[0] through displayLEDs[3]</p>
<p>// Main processing function - runs continuously while plugin is active
function process()
{
    loop {
        // Process audio: reduce volume to half
        signal[0] = signal[0] / 2  // Left channel volume control
        signal[1] = signal[1] / 2  // Right channel volume control
        
        // Visual feedback: light up LED to show plugin is running
        displayLEDs[0] = 0xFF      // All LEDs on in first display
        
        // CRITICAL: Return control to Permut8 for next audio sample
        yield()
    }
}
<pre><code>
<h3>7.2 What You've Accomplished</h3>
‚úÖ <strong>Created a working plugin</strong> that modifies audio in real-time  
‚úÖ <strong>Understood the basic structure</strong> every plugin needs  
‚úÖ <strong>Modified audio samples</strong> with simple mathematical operations  
‚úÖ <strong>Added visual feedback</strong> with LED control  
‚úÖ <strong>Verified your development environment</strong> is working correctly</p>
<p>---</p>
<h2>Step 8: What's Next</h2>
<h3>8.1 You Now Know</h3>
<strong>Essential Concepts:</strong>
<ul><li>Every plugin needs the same basic structure</li><li>Audio flows through </code>signal[0]<code> and </code>signal[1]<code></li><li></code>yield()<code> is required for real-time operation</li><li>You can modify audio with simple math</li><li>LEDs provide visual feedback</li></ul>
<strong>Foundation Skills:</strong>
<ul><li>Compiling plugins with PikaCmd</li><li>Loading plugins into Permut8</li><li>Testing audio modifications</li><li>Basic audio sample manipulation</li></ul>
<h3>8.2 Ready For Next Steps</h3>
<strong>Build on this foundation:</strong>
<ul><li>üìñ <a href="make-your-first-sound.md">Make Your First Sound</a> - Generate audio instead of just modifying it</li><li>üìñ <a href="control-something-with-knobs.md">Control Something with Knobs</a> - Use hardware knobs to control your effects</li><li>üìñ <a href="light-up-leds.md">Light Up LEDs</a> - Advanced LED patterns and feedback</li><li>üìñ <a href="build-your-first-filter.md">Build Your First Filter</a> - Create your first real audio effect</li></ul>
<h3>8.3 Experiment Ideas</h3>
<strong>Try these modifications:</strong></code></pre>impala
// Different volume levels
signal[0] = signal[0] * 2    // Double volume (be careful - can be loud!)
signal[0] = signal[0] / 4    // Quarter volume
<p>// Mute one channel
signal[0] = 0               // Mute left channel
signal[1] = signal[1]       // Keep right channel</p>
<p>// Swap left and right
int temp = signal[0]
signal[0] = signal[1]       // Left gets right audio
signal[1] = temp            // Right gets left audio</p>
<p>// Different LED patterns
displayLEDs[0] = 0x01       // Only first LED
displayLEDs[0] = 0xAA       // Alternating LEDs (10101010)
displayLEDs[0] = 0x0F       // First 4 LEDs
</code>``</p>
<strong>üéâ You're now ready to start creating real audio effects!</strong> Every complex plugin starts with these same basic concepts - you've mastered the foundation.
</div>


<div class="file-section" id="simplest-distortion">
    <div class="file-title">üìÑ Simplest Distortion</div>
    <h1>Your First Distortion Effect</h1>
<em>From clean audio to guitar pedal sound in 15 minutes - Progressive distortion tutorial</em>
<p>---</p>
<h2>What You'll Build</h2>
<p>By the end of this tutorial, you'll have:
<ul><li>A working distortion effect that sounds like a real guitar pedal</li><li>Understanding of how different math creates different distortion sounds</li><li>Control over distortion amount using hardware knobs</li><li>Foundation for building any distortion-based effect</li></ul></p>
<strong>Prerequisites</strong>: <a href="how-dsp-affects-sound.md">How DSP Affects Sound</a>, <a href="getting-audio-in-and-out.md">Getting Audio In and Out</a>  
<strong>Time</strong>: 15 minutes hands-on  
<strong>Next Tutorial</strong>: <a href="../../../fundamentals/audio-engineering-for-programmers.md">Audio Engineering for Programmers</a>
<p>---</p>
<h2>The Journey: Clean ‚Üí Harsh ‚Üí Musical</h2>
<p>We'll build distortion in three progressive steps:</p>
<p>1. <strong>Step 1</strong>: Basic gain boost (2 minutes) - Make it louder
2. <strong>Step 2</strong>: Safe clipping (5 minutes) - Prevent harsh overload  
3. <strong>Step 3</strong>: Musical curves (8 minutes) - Sound like real guitar pedals</p>
<p>Each step builds on the previous one, so you'll always have working audio.</p>
<p>---</p>
<h2>Step 1: Basic Gain Boost (2 minutes)</h2>
<h3>The Simplest Distortion</h3>
<p>The most basic distortion is just <strong>making audio louder than it should be</strong>:</p>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
extern native yield
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>function process() {
    loop {
        // Basic distortion: just make it louder!
        signal[0] = signal[0] * 3;  // 3x louder
        signal[1] = signal[1] * 3;  // Both channels
        
        yield();
    }
}</code></pre></p>
<h3>Try It Right Now</h3>
<p>1. <strong>Compile</strong>: <code>PikaCmd.exe compile basic_gain.impala</code>
2. <strong>Load</strong>: Load <code>basic_gain.gazl</code> via plugin interface
3. <strong>Play</strong> some audio and <strong>listen</strong></p>
<strong>What You'll Hear</strong>: Much louder audio that starts to sound harsh and buzzy when the input is loud. This harshness IS distortion - you're hearing the audio system struggle with numbers that are too big.
<h3>Why This Works</h3>
<ul><li><strong>Quiet parts</strong> (small numbers): <code>100 * 3 = 300</code> ‚Üí Still clean</li><li><strong>Loud parts</strong> (big numbers): <code>1000 * 3 = 3000</code> ‚Üí Too big! Gets automatically limited to 2047</li><li><strong>The limiting creates distortion</strong> - that harsh, buzzy sound</li></ul>
<strong>Key Insight</strong>: Distortion happens when audio numbers get too big for the system to handle cleanly.
<p>---</p>
<h2>Step 2: Safe Clipping (5 minutes)</h2>
<p>The basic gain boost works, but it's unpredictable. Sometimes it's clean, sometimes harsh. Let's take control.</p>
<h3>Controlled Clipping</h3>
<p>Instead of hoping the system limits our audio safely, <strong>we'll do the limiting ourselves</strong>:</p>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
extern native yield
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>function process() {
    loop {
        // Read knob for distortion amount
        int distortionKnob = params[0];  // 0-255
        int gainAmount = 1 + (distortionKnob / 32);  // 1x to 9x gain
        
        // Apply gain to both channels
        int leftGained = signal[0] * gainAmount;
        int rightGained = signal[1] * gainAmount;
        
        // Safe clipping - WE control when distortion happens
        if (leftGained > 2047) leftGained = 2047;
        if (leftGained < -2047) leftGained = -2047;
        if (rightGained > 2047) rightGained = 2047;
        if (rightGained < -2047) rightGained = -2047;
        
        // Output the controlled distortion
        signal[0] = leftGained;
        signal[1] = rightGained;
        
        // Show distortion amount on LED
        displayLEDs[0] = distortionKnob;
        
        yield();
    }
}</code></pre></p>
<h3>Try the Controlled Version</h3>
<p>1. <strong>Compile and load</strong> this new version
2. <strong>Turn Knob 1</strong> from left (clean) to right (distorted)
3. <strong>Listen</strong> to how the distortion becomes predictable and controlled</p>
<strong>What You'll Hear</strong>: 
<ul><li><strong>Knob left</strong>: Clean audio (1x gain, no clipping)</li><li><strong>Knob middle</strong>: Mild distortion (moderate gain, some clipping)</li><li><strong>Knob right</strong>: Heavy distortion (high gain, lots of clipping)</li></ul>
<h3>Why This Is Better</h3>
<ul><li><strong>Predictable</strong>: You control exactly when distortion starts</li><li><strong>Safe</strong>: Never damages speakers or ears with unexpected volume spikes</li><li><strong>Musical</strong>: Distortion amount follows your knob movements</li><li><strong>Visual</strong>: LED shows current distortion setting</li></ul>
<strong>Key Insight</strong>: Professional distortion effects control the clipping instead of letting it happen randomly.
<p>---</p>
<h2>Step 3: Musical Curves (8 minutes)</h2>
<p>Hard clipping sounds harsh and digital. Real guitar pedals use <strong>soft clipping</strong> that sounds warm and musical.</p>
<h3>Understanding Clipping Curves</h3>
<p>Different clipping shapes create different sounds:</p>
<pre><code>Hard Clipping (harsh):          Soft Clipping (warm):
     ____                            ____
    |                               /
----+----  ‚Üí  _____|_____          /
    |              |               |
    ____           ____            ____</code></pre>
<h3>Soft Clipping Implementation</h3>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
extern native yield
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>function softClip(int input, int threshold) {
    // Soft clipping algorithm - sounds warm like tube amps
    if (input > threshold) {
        int excess = input - threshold;
        return threshold + (excess / 4);  // Gentle compression above threshold
    } else if (input < -threshold) {
        int excess = input + threshold;
        return -threshold + (excess / 4);  // Gentle compression below threshold
    } else {
        return input;  // No change in normal range
    }
}</p>
<p>function process() {
    loop {
        // Distortion controls from knobs
        int driveKnob = params[0];     // 0-255: Distortion amount
        int toneKnob = params[1];      // 0-255: Clipping threshold
        
        // Calculate gain (1x to 8x)
        int gainAmount = 1 + (driveKnob / 36);
        
        // Calculate clipping threshold (500 to 1800)
        int clipThreshold = 500 + ((toneKnob * 1300) / 255);
        
        // Process both channels
        int leftGained = signal[0] * gainAmount;
        int rightGained = signal[1] * gainAmount;
        
        // Apply soft clipping for musical distortion
        int leftClipped = softClip(leftGained, clipThreshold);
        int rightClipped = softClip(rightGained, clipThreshold);
        
        // Final safety clipping (just in case)
        if (leftClipped > 2047) leftClipped = 2047;
        if (leftClipped < -2047) leftClipped = -2047;
        if (rightClipped > 2047) rightClipped = 2047;  
        if (rightClipped < -2047) rightClipped = -2047;
        
        // Output the musical distortion
        signal[0] = leftClipped;
        signal[1] = rightClipped;
        
        // Visual feedback
        displayLEDs[0] = driveKnob;      // Drive amount
        displayLEDs[1] = toneKnob;       // Tone control
        
        yield();
    }
}</code></pre></p>
<h3>Try Your Musical Distortion</h3>
<p>1. <strong>Compile and load</strong> the soft clipping version
2. <strong>Experiment with both knobs</strong>:
   - <strong>Knob 1</strong> (Drive): Amount of distortion
   - <strong>Knob 2</strong> (Tone): Character of distortion
3. <strong>Listen</strong> for the warm, musical quality</p>
<strong>What You'll Hear</strong>:
<ul><li><strong>Low drive</strong>: Clean or very mild overdrive</li><li><strong>High drive</strong>: Rich, warm distortion like vintage tube amps</li><li><strong>Low tone</strong>: Gentle, smooth clipping</li><li><strong>High tone</strong>: Brighter, more aggressive clipping</li></ul>
<h3>Why This Sounds Better</h3>
<p>#### <strong>Soft vs Hard Clipping</strong>:
<pre><code>// Hard clipping (harsh, digital):
if (signal > 1000) signal = 1000;</p>
<p>// Soft clipping (warm, musical):
if (signal > 1000) {
    excess = signal - 1000;
    signal = 1000 + (excess / 4);  // Gentle transition
}</code></pre></p>
<p>#### <strong>The Magic</strong>:
<ul><li><strong>Hard clipping</strong>: Immediate cutoff ‚Üí harsh sound</li><li><strong>Soft clipping</strong>: Gradual compression ‚Üí warm sound</li><li><strong>Variable threshold</strong>: Different tone characters</li><li><strong>Gain staging</strong>: Professional volume control</li></ul></p>
<p>---</p>
<h2>Understanding Your Distortion Pedal</h2>
<h3>What You Built</h3>
<p>You now have a professional-quality distortion effect with:</p>
<p>1. <strong>Drive Control</strong> (Knob 1): How much distortion
2. <strong>Tone Control</strong> (Knob 2): Character of distortion  
3. <strong>Soft Clipping</strong>: Musical, warm sound
4. <strong>Safety Limiting</strong>: No damage or surprises
5. <strong>Visual Feedback</strong>: LED shows settings</p>
<h3>How It Compares to Commercial Pedals</h3>
<strong>Your firmware</strong> vs <strong>$200 Distortion Pedal</strong>:
<ul><li>‚úÖ <strong>Gain staging</strong>: Professional volume control</li><li>‚úÖ <strong>Soft clipping</strong>: Warm, musical distortion  </li><li>‚úÖ <strong>Tone shaping</strong>: Variable clipping character</li><li>‚úÖ <strong>Safety features</strong>: No damage or surprises</li><li>‚úÖ <strong>Real-time control</strong>: Immediate response to knobs</li></ul>
<strong>You built the core of a professional distortion pedal!</strong>
<p>---</p>
<h2>Advanced Variations</h2>
<p>Now that you understand the fundamentals, try these modifications:</p>
<h3>1. Asymmetrical Clipping</h3>
<pre><code>// Different clipping for positive and negative
if (input > threshold) {
    return threshold + ((input - threshold) / 4);
} else if (input < -threshold) {
    return -threshold + ((input + threshold) / 2);  // Different ratio!
}</code></pre>
<h3>2. Multiple Stages</h3>
<pre><code>// Run through soft clipping twice for more saturation
int stage1 = softClip(input * gain1, threshold1);
int stage2 = softClip(stage1 * gain2, threshold2);</code></pre>
<h3>3. Frequency-Dependent Distortion</h3>
<pre><code>// Different distortion for different frequencies
// (Requires filtering - see advanced tutorials)</code></pre>
<p>---</p>
<h2>The Distortion Spectrum</h2>
<p>You now understand how different approaches create different sounds:</p>
<h3><strong>Clean</strong>: <code>signal = signal</code></h3>
<ul><li>No processing</li><li>Original audio unchanged</li></ul>
<h3><strong>Volume</strong>: <code>signal = signal * gain</code>  </h3>
<ul><li>Louder but clean (until clipping)</li><li>Linear volume control</li></ul>
<h3><strong>Hard Distortion</strong>: <code>clamp(signal * gain, -limit, +limit)</code></h3>
<ul><li>Harsh, digital sound</li><li>Immediate cutoff</li></ul>
<h3><strong>Soft Distortion</strong>: <code>softClip(signal * gain, threshold)</code></h3>
<ul><li>Warm, musical sound  </li><li>Gradual compression</li></ul>
<h3><strong>Professional Distortion</strong>: Multiple stages + tone shaping</h3>
<ul><li>Complex harmonic content</li><li>Musical and controllable</li></ul>
<p>---</p>
<h2>Key Concepts Learned</h2>
<h3>1. Distortion Is Controlled Overload</h3>
<ul><li>Make audio too loud ‚Üí System limits it ‚Üí Creates distortion</li><li>Control when/how limiting happens ‚Üí Control distortion character</li></ul>
<h3>2. Clipping Shapes Define Sound</h3>
<ul><li><strong>Hard clipping</strong>: Immediate cutoff ‚Üí harsh sound</li><li><strong>Soft clipping</strong>: Gradual compression ‚Üí warm sound  </li><li><strong>Asymmetrical</strong>: Different positive/negative ‚Üí unique character</li></ul>
<h3>3. Professional Features</h3>
<ul><li><strong>Gain staging</strong>: Control how much signal hits the distortion</li><li><strong>Threshold control</strong>: Adjust where distortion begins</li><li><strong>Safety limiting</strong>: Prevent damage and surprises</li><li><strong>Visual feedback</strong>: Show users what's happening</li></ul>
<h3>4. Real Guitar Pedal Architecture</h3>
<ul><li>Input gain ‚Üí Soft clipping ‚Üí Tone shaping ‚Üí Output limiting</li><li>Multiple controls for musical flexibility</li><li>Warm, musical algorithms instead of harsh digital</li></ul>
<p>---</p>
<h2>What's Next?</h2>
<h3><strong>Immediate Next Steps</strong>:</h3>
1. <strong><a href="../../../fundamentals/audio-engineering-for-programmers.md">Audio Engineering for Programmers</a></strong> - Professional concepts
2. <strong><a href="../audio-effects/waveshaper-distortion.md">Waveshaper Distortion</a></strong> - Advanced mathematical approaches
3. <strong><a href="../../parameters/parameter-mapping.md">Parameter Mapping</a></strong> - Professional parameter design
<h3><strong>Building on Distortion</strong>:</h3>
<ul><li><strong><a href="../audio-effects/multi-band-compressor.md">Multi-band Compressor</a></strong> - Frequency-specific processing</li><li><strong><a href="../audio-effects/chorus-effect.md">Chorus Effect</a></strong> - Modulation-based effects</li><li><strong><a href="../../tutorials/complete-development-workflow.md">Complete Development Workflow</a></strong> - Professional practices</li></ul>
<h3><strong>Advanced Distortion</strong>:</h3>
<ul><li><strong><a href="../../../performance/optimization-basics.md">Optimization Basics</a></strong> - Performance improvement</li><li><strong><a href="../../../advanced/advanced-memory-management.md">Advanced Memory Management</a></strong> - Complex algorithms</li></ul>
<p>---</p>
<h2>Quick Reference</h2>
<h3><strong>Basic Distortion Pattern</strong>:</h3>
<pre><code>// 1. Control input gain
int gained = signal[0] * gainAmount;
<p>// 2. Apply clipping algorithm  
int clipped = softClip(gained, threshold);</p>
<p>// 3. Safety limiting
if (clipped > 2047) clipped = 2047;
if (clipped < -2047) clipped = -2047;</p>
<p>// 4. Output result
signal[0] = clipped;</code></pre></p>
<h3><strong>Soft Clipping Function</strong>:</h3>
<pre><code>function softClip(int input, int threshold) {
    if (input > threshold) {
        return threshold + ((input - threshold) / compressionRatio);
    } else if (input < -threshold) {
        return -threshold + ((input + threshold) / compressionRatio);
    }
    return input;
}</code></pre>
<h3><strong>Professional Controls</strong>:</h3>
<ul><li><strong>Drive/Gain</strong>: How much signal hits the distortion</li><li><strong>Tone/Threshold</strong>: Where and how distortion begins  </li><li><strong>Output Level</strong>: Final volume control</li><li><strong>Safety Limiting</strong>: Prevent damage</li></ul>
<p>You now understand the fundamentals of distortion and have built a professional-quality effect! This knowledge applies to all overdrive, distortion, and saturation effects.</p>
<p>---</p>
<em>Next: <a href="../../../fundamentals/audio-engineering-for-programmers.md">Audio Engineering for Programmers</a> - Essential audio concepts in programming terms</em>
</div>


<div class="file-section" id="core-language-reference">
    <div class="file-title">üìÑ Core Language Reference</div>
    <h1>Core Language Reference - Essential Impala</h1>
<p>The minimal language reference you need to start creating Permut8 firmware.</p>
<h2>Impala Basics</h2>
<p>Impala is a C-like language that compiles to GAZL assembly. If you know C, you know 90% of Impala.</p>
<h3>Key Differences from C:</h3>
<ul><li>No <code>#include</code> or preprocessor</li><li>No pointers to functions</li><li>No <code>malloc/free</code> (static memory only)</li><li>Built-in <code>loop</code> construct</li><li>Native <code>yield()</code> for cooperative multitasking</li></ul>
<h2>Essential Firmware Structure</h2>
<h3>Full Patch (Audio Processing)</h3>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2  // Required!
<h2>Firmware Format Versions</h2>
<h3>Version 2 (Standard) - Recommended for Most Projects</h3></code></pre>impala
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<pre><code>- <strong>Features</strong>: Basic parameter handling, standard memory layout
<ul><li><strong>Step Sequencing</strong>: 16 steps maximum</li><li><strong>Compatibility</strong>: All Permut8 versions</li><li><strong>Use Cases</strong>: Effects, basic sequencers, audio processors</li></ul>
<h3>Version 3 (Advanced) - Professional Features</h3></code></pre>impala  
const int PRAWN_FIRMWARE_PATCH_FORMAT = 3
<pre><code>- <strong>Features</strong>: Extended parameter handling, host synchronization
<ul><li><strong>Step Sequencing</strong>: 32 steps maximum</li><li><strong>Host Integration</strong>: DAW transport sync, position tracking</li><li><strong>Use Cases</strong>: Complex sequencers, synchronized effects</li><li><strong>Examples</strong>: FooBar firmware (official advanced sequencer)</li></ul>
<h2>Standard Global Layout (Bank-Compatible)</h2>
</code></pre>impala
// MUST match this exact pattern for bank compatibility
global array signal[2]       // Audio I/O [left, right]
global array params[PARAM_COUNT]  // Plugin parameters  
global array displayLEDs[4]  // LED displays
global int clock = 0         // Clock counter
<p>function process() {
    loop {  // Infinite processing loop
        // Process global signal[0] and signal[1]
        // Audio range: -2047 to 2047 (12-bit)
        
        yield();  // Return control to Permut8
    }
}
<pre><code>
<h3>Mod Patch (Operator Replacement)</h3></code></pre>impala
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2  // Required!</p>
<p>global array positions[2]   // Memory positions: [left, right]
global array params[PARAM_COUNT]   // Parameters array
global array displayLEDs[4]        // LED displays</p>
<p>function operate1(int a)
returns int processed
{
    // Check if we should handle this operator
    if ((int) global params[OPERATOR_1_PARAM_INDEX] == OPERATOR_1_MUL) {
        // Modify global positions[0] and positions[1]
        // Positions: 0x00000 to 0xFFFFF (20-bit with 4 frac bits)
        processed = 1;  // Return 1 if handled, 0 to pass through
    } else {
        processed = 0;  // Pass to default handler
    }
}
<pre><code>
<h2>Core Global Variables</h2></p>
<h3>Always Available</h3>
| Global | Type | Description |
|--------|------|-------------|
| <code>global array params[PARAM_COUNT]</code> | int array | Knob/switch values (0-255) |
| <code>global array displayLEDs[4]</code> | int array | LED displays under knobs |
| <code>global int clock</code> | int | Sample counter (0-65535) |
| <code>global int instance</code> | int | Unique plugin instance ID |
<h3>Full Patches Only</h3>
| Global | Type | Description |
|--------|------|-------------|
| <code>global array signal[2]</code> | int array | Audio samples L/R (-2047 to 2047) |
<h3>Mod Patches Only</h3>
| Global | Type | Description |
|--------|------|-------------|
| <code>global array positions[2]</code> | int array | Memory positions L/R (20-bit fixed point) |
<h2>Parameter Indices</h2>
<p>Access knob/switch values via <code>global params[]</code>:
</code></pre>impala
// Parameter indices (externally defined constants)
const int CLOCK_FREQ_PARAM_INDEX       // Clock rate
const int SWITCHES_PARAM_INDEX         // Switch states (bitmask)
const int OPERATOR_1_PARAM_INDEX       // Operator 1 selection
const int OPERAND_1_HIGH_PARAM_INDEX   // First knob (top)
const int OPERAND_1_LOW_PARAM_INDEX    // Second knob
const int OPERATOR_2_PARAM_INDEX       // Operator 2 selection
const int OPERAND_2_HIGH_PARAM_INDEX   // Third knob
const int OPERAND_2_LOW_PARAM_INDEX    // Fourth knob (bottom)
const int PARAM_COUNT                  // Total parameter count</p>
<p>// Operator constants (externally defined)
const int OPERATOR_1_NOP               // No operation
const int OPERATOR_1_AND               // Bitwise AND
const int OPERATOR_1_MUL               // Multiply
const int OPERATOR_1_OSC               // Oscillator
const int OPERATOR_1_RND               // Random</p>
<p>const int OPERATOR_2_NOP               // No operation
const int OPERATOR_2_OR                // Bitwise OR
const int OPERATOR_2_XOR               // Bitwise XOR
const int OPERATOR_2_MSK               // Mask
const int OPERATOR_2_SUB               // Subtract
<pre><code>
<h3>Switch Bitmasks</h3></code></pre>impala
// Switch bitmasks (externally defined constants)
const int SWITCHES_SYNC_MASK           // Tempo sync enabled
const int SWITCHES_TRIPLET_MASK        // Triplet timing
const int SWITCHES_DOTTED_MASK         // Dotted timing
const int SWITCHES_WRITE_PROTECT_MASK  // Write protection
const int SWITCHES_REVERSE_MASK        // Reverse playback</p>
<p>// Example usage:
if ((int) global params[SWITCHES_PARAM_INDEX] & SWITCHES_SYNC_MASK) {
    // Sync is ON
}
<pre><code>
<h2>Official Parameter Handling Patterns</h2></p>
<p>Based on Beatrick and FooBar official firmware implementations:</p>
<h3>Parameter Update Mask (Critical Pattern)</h3></code></pre>impala
// Official pattern for parameter change detection
const int updateMask = (
    (1 << OPERATOR_1_PARAM_INDEX) |
    (1 << OPERAND_1_HIGH_PARAM_INDEX) |
    (1 << OPERAND_1_LOW_PARAM_INDEX) |
    (1 << OPERATOR_2_PARAM_INDEX) |
    (1 << OPERAND_2_HIGH_PARAM_INDEX) |
    (1 << OPERAND_2_LOW_PARAM_INDEX)
);
<pre><code>
<h3>Bit Manipulation for High/Low Parameters</h3></code></pre>impala
// Official pattern for combining high/low bytes
function readParameterPair(int highIndex, int lowIndex)
returns int combined
{
    int high = (int) global params[highIndex];
    int low = (int) global params[lowIndex];
    combined = (high << 8) | low;  // 16-bit value
}
<pre><code>
<h3>Parameter Reading in update() Function</h3></code></pre>impala
// Official pattern for parameter processing
function update() {
    // Read operator selection
    int operator1 = (int) global params[OPERATOR_1_PARAM_INDEX];
    
    // Read operand values
    int operand1 = readParameterPair(OPERAND_1_HIGH_PARAM_INDEX, 
                                     OPERAND_1_LOW_PARAM_INDEX);
    
    // Process parameter changes...
}
<pre><code>
<h2>Essential Functions</h2>
<h3>Required by Permut8</h3>
| Function | When Called | Purpose |
|----------|-------------|---------|
| <code>process()</code> | Every sample (full patch) | Main audio processing |
| <code>operate1/2()</code> | When operator active (mod patch) | Modify memory positions |
<h3>Optional Callbacks  </h3>
| Function | When Called | Purpose |
|----------|-------------|---------|
| <code>init()</code> | Once at load | Initialize tables/state |
| <code>reset()</code> | Reset switch/DAW | Clear delays/state |
| <code>update()</code> | Parameter change | Recalculate values |
<h3>Native Functions</h3></code></pre>impala
yield()         // Return control (use in process loop)
abort()         // Kill firmware, restore normal operation
trace(string)   // Debug output (console/DebugView)
read(offset, count, buffer)   // Read from delay memory
write(offset, count, buffer)  // Write to delay memory
<pre><code>
<h2>Data Types</h2>
<h3>Basic Types</h3>
<ul><li><code>int</code> - 32-bit signed integer</li><li><code>float</code> - 32-bit floating point</li><li><code>pointer</code> - Memory address</li><li><code>array</code> - Fixed-size array</li></ul>
<h3>Type Casting</h3></code></pre>impala
int x = (int) global params[3];     // Always cast params[]
float f = itof(x);                  // int to float
int i = ftoi(f);                    // float to int
<pre><code>
<h2>Control Flow</h2>
<h3>Loops</h3></code></pre>impala
loop { }                // Infinite loop (use yield()!)
for (i = 0 to n) { }    // Inclusive: 0,1,2,...,n
while (x < 10) { }      // Standard while
<pre><code>
<h3>Conditionals</h3></code></pre>impala
if (x > 0) { }
else if (x < 0) { }
else { }
<pre><code>
<h2>LED Display Patterns</h2>
<p>LEDs are 8-bit values (0-255) where each bit lights one LED:
</code></pre>impala
global displayLEDs[0] = 0x01;  // Single LED (leftmost)
global displayLEDs[0] = 0x80;  // Single LED (rightmost)
global displayLEDs[0] = 0xFF;  // All LEDs on
global displayLEDs[0] = 0x0F;  // Left 4 LEDs
global displayLEDs[0] = 1 << position;  // Variable position
<pre><code>
<h2>Common Patterns</h2></p>
<h3>Parameter Scaling</h3></code></pre>impala
// Map 0-255 to useful range
int depth = (int) global params[OPERAND_1_HIGH_PARAM_INDEX] >> 2;      // 0-63
int bits = ((int) global params[OPERAND_1_HIGH_PARAM_INDEX] >> 5) + 1; // 1-8
float mix = itof((int) global params[OPERAND_1_HIGH_PARAM_INDEX]) / 255.0; // 0.0-1.0
<pre><code>
<h3>Safe Audio Processing</h3></code></pre>impala
// Clamp to valid range
if (sample > 2047) sample = 2047;
else if (sample < -2047) sample = -2047;
<pre><code>
<h3>Memory Access (Delays)</h3></code></pre>impala
array buffer[2];
read(global clock - 1000, 1, buffer);  // Read 1000 samples ago
// buffer[0] = left, buffer[1] = right
<pre><code>
<h2>Quick Debugging</h2>
<h3>Trace Values</h3></code></pre>impala
array buf[128];
sprintf(buf, "Value: %d", myValue);
trace(buf);
<pre><code>
<h3>Test Mode</h3></code></pre>impala
if (DEBUG) {  // Defined when loading in debug mode
    trace("Debug mode active");
}
<pre><code>
<h2>Minimal Working Examples</h2>
<h3>Bit Crusher (Full Patch)</h3></code></pre>impala
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>global array signal[2]              // Audio I/O
global array params[PARAM_COUNT]    // Parameters
global array displayLEDs[4]        // LED displays</p>
<p>function process() {
    loop {
        int bits = ((int) global params[OPERAND_1_HIGH_PARAM_INDEX] >> 5) + 1;
        int mask = 0xFFF0 << (12 - bits);
        global signal[0] = (int) global signal[0] & mask;
        global signal[1] = (int) global signal[1] & mask;
        yield();
    }
}
<pre><code>
<h3>Position Shifter (Mod Patch)</h3></code></pre>impala
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2</p>
<p>global array positions[2]           // Memory positions 
global array params[PARAM_COUNT]    // Parameters
global array displayLEDs[4]        // LED displays</p>
<p>function operate1(int a)
returns int r
{
    if ((int) global params[OPERATOR_1_PARAM_INDEX] == OPERATOR_1_MUL) {
        int shift = (int) global params[OPERAND_1_HIGH_PARAM_INDEX] << 8;
        global positions[0] = (int) global positions[0] + shift;
        global positions[1] = (int) global positions[1] + shift;
        r = 1;  // Handled
    } else {
        r = 0;  // Pass through
    }
}
<pre><code>
---</p>
<h2>Bank Integration Patterns</h2>
<h3>Bank-Compatible Firmware Requirements</h3>
<p>For firmware that works with .p8bank deployment:</p>
<p>#### Standard Global Layout (Required)</code></pre>impala
// MUST match this exact pattern for bank compatibility
global array signal[2]       // Audio I/O [left, right]
global array params[PARAM_COUNT]  // Plugin parameters  
global array displayLEDs[4]  // LED displays
global int clock = 0         // Clock counter
<pre><code>
#### Required Function Structure</code></pre>impala
// Bank-compatible firmware MUST implement:
function reset() {
    // Initialize state, clear delays
}</p>
<p>function update() {
    // Handle parameter changes using official patterns
}</p>
<p>function process() {
    loop {
        // Main processing with yield()
        yield();
    }
}
<pre><code>
#### Preset Integration Patterns</code></pre>impala
// Design firmware for multiple presets
function update() {
    // Read current operator settings
    int mode = (int) global params[OPERATOR_1_PARAM_INDEX];
    
    // Different behaviors for different presets
    switch (mode) {
        case 1: setupLightMode(); break;
        case 2: setupHeavyMode(); break;
        // Allow A0-C9 presets to change behavior
    }
}
```</p>
<p>---</p>
<h2>See Also</h2>
<strong>üìö Complete Documentation:</strong>
<ul><li><strong><a href="language-syntax-reference.md">Complete Language Syntax Reference</a></strong> - Full syntax guide with all operators and constructs</li><li><strong><a href="../reference/memory_management.md">Memory Management Reference</a></strong> - Delay lines, read/write operations, position arrays</li><li><strong><a href="../reference/utilities_reference.md">Utilities Reference</a></strong> - Native functions, math, strings, debugging</li><li><strong><a href="../../../Impala Snippets.txt">Impala Snippets</a></strong> - Copy-paste utility functions and math library</li></ul>
<strong>üì¶ Bank Integration:</strong>
<ul><li><strong><a href="../architecture/p8bank-format.md">P8Bank Format</a></strong> - Complete firmware packaging</li><li><strong><a href="../user-guides/tutorials/creating-firmware-banks.md">Creating Firmware Banks</a></strong> - Distribution workflow</li><li><strong><a href="../user-guides/cookbook/advanced/firmware-patterns.md">Official Firmware Patterns</a></strong> - Beatrick/FooBar patterns</li></ul>
<strong>üç≥ Cookbook Examples:</strong>
<ul><li><strong><a href="../user-guides/cookbook/fundamentals/basic-oscillator.md">Basic Oscillator</a></strong> - Simple sine wave generation</li><li><strong><a href="../user-guides/cookbook/audio-effects/make-a-delay.md">Make a Delay</a></strong> - Basic delay effect implementation</li><li><strong><a href="../user-guides/cookbook/fundamentals/parameter-mapping.md">Parameter Mapping</a></strong> - Knob and switch handling</li></ul>
<strong>üèóÔ∏è Architecture:</strong>
<ul><li><strong><a href="../architecture/memory-model.md">Memory Model</a></strong> - Understanding Permut8's memory system</li><li><strong><a href="../architecture/processing-order.md">Processing Order</a></strong> - When functions are called</li><li><strong><a href="../architecture/mod-vs-full.md">Mod vs Full Patches</a></strong> - Choosing the right patch type</li></ul>
</div>


<div class="file-section" id="language-syntax-reference">
    <div class="file-title">üìÑ Language Syntax Reference</div>
    <h1>Language Syntax Reference</h1>
<p>Complete syntax guide for the Impala programming language used in Permut8 firmware development.</p>
<h2>Overview</h2>
<p>Impala is a C-like language that compiles to GAZL assembly for the Permut8 device. It provides real-time audio processing capabilities with static memory allocation and cooperative multitasking.</p>
<strong>Key Features:</strong>
<ul><li>C-like syntax with simplified semantics</li><li>Static memory allocation (no malloc/free)</li><li>Cooperative multitasking with <code>yield()</code></li><li>Built-in audio processing constructs</li><li>Direct hardware integration</li></ul>
<h2>Program Structure</h2>
<p>Every Impala firmware follows this basic structure:</p>
<pre><code>/*
    Firmware comments and description
*/
<p>/<em> ------ Required Format Declaration ------ </em>/
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2</p>
<p>/<em> ------ Global Variables ------ </em>/
global array signal[2]              // Full patches only
global array positions[2]           // Mod patches only  
global array params[PARAM_COUNT]    // Always available
global array displayLEDs[4]         // Always available</p>
<p>/<em> ------ Global State ------ </em>/
global int myVariable = 0
global array myBuffer[1024]</p>
<p>/<em> ------ Required Functions ------ </em>/
function process()                   // Full patches
function operate1(int a) returns int processed  // Mod patches</p>
<p>/<em> ------ Optional Functions ------ </em>/
function init()                     // Called once at load
function reset()                    // Called on reset
function update()                   // Called on parameter change</code></pre></p>
<h2>Data Types</h2>
<h3>Basic Types</h3>
| Type | Size | Range | Description |
|------|------|-------|-------------|
| <code>int</code> | 32-bit | -2,147,483,648 to 2,147,483,647 | Signed integer |
| <code>float</code> | 32-bit | IEEE 754 | Floating point |
| <code>pointer</code> | 32-bit | Memory address | Pointer to memory |
<h3>Arrays</h3>
<pre><code>// Fixed-size arrays only
array buffer[1024]              // Local array
global array delayLine[8192]    // Global array
readonly array table[256]       // Read-only array
<p>// Array access
buffer[0] = 123;               // Set element
int value = buffer[0];         // Get element</code></pre></p>
<h3>Type Casting</h3>
<pre><code>int x = (int) global params[0];         // Cast to int
float f = itof(x);                      // int to float
int i = ftoi(f);                        // float to int
pointer p = &buffer[0];                 // Address of array element</code></pre>
<h2>Constants and Variables</h2>
<h3>Constants</h3>
<pre><code>const int BUFFER_SIZE = 1024            // Integer constant
const float PI = 3.14159265             // Float constant
const int FALSE = 0                     // Boolean constant
const int TRUE = 1                      // Boolean constant</code></pre>
<h3>Variable Declarations</h3>
<pre><code>// Local variables
int sampleCount
float delayTime = 0.5
array tempBuffer[64]
<p>// Global variables (accessible across functions)
global int position = 0
global array circularBuffer[2048]
global float mixLevel</p>
<p>// Read-only global data
readonly array sineTable[1024] = { /<em> data </em>/ }
readonly int maxDelay = 8000</code></pre></p>
<h2>Operators</h2>
<h3>Arithmetic Operators</h3>
<pre><code>int a = 10 + 5;        // Addition
int b = 10 - 5;        // Subtraction  
int c = 10 * 5;        // Multiplication
int d = 10 / 5;        // Division
int e = 10 % 3;        // Modulo</code></pre>
<h3>Bitwise Operators</h3>
<pre><code>int a = 0xFF & 0x0F;   // Bitwise AND
int b = 0xFF | 0x0F;   // Bitwise OR
int c = 0xFF ^ 0x0F;   // Bitwise XOR
int d = ~0xFF;         // Bitwise NOT
int e = 0xFF << 2;     // Left shift
int f = 0xFF >> 2;     // Right shift</code></pre>
<h3>Comparison Operators</h3>
<pre><code>if (a == b) { }        // Equal
if (a != b) { }        // Not equal
if (a < b) { }         // Less than
if (a <= b) { }        // Less than or equal
if (a > b) { }         // Greater than
if (a >= b) { }        // Greater than or equal</code></pre>
<h3>Logical Operators</h3>
<pre><code>if (a && b) { }        // Logical AND
if (a || b) { }        // Logical OR  
if (!a) { }            // Logical NOT</code></pre>
<h2>Control Flow</h2>
<h3>Conditional Statements</h3>
<pre><code>// Basic if statement
if (condition) {
    // statements
}
<p>// If-else
if (condition) {
    // statements
} else {
    // statements
}</p>
<p>// If-else-if chain
if (condition1) {
    // statements
} else if (condition2) {
    // statements
} else {
    // statements
}</code></pre></p>
<h3>Loops</h3>
<p>#### For Loops
<pre><code>// Inclusive range (0, 1, 2, ..., n)
for (i = 0 to n) {
    // loop body
}</p>
<p>// With step (manual implementation)
for (i = 0; i < n; i = i + 2) {
    // loop body  
}</code></pre></p>
<p>#### While Loops
<pre><code>while (condition) {
    // loop body
}</p>
<p>// Example
int i = 0;
while (i < 10) {
    // process
    i = i + 1;
}</code></pre></p>
<p>#### Infinite Loops
<pre><code>loop {
    // Main processing loop
    // MUST include yield() for real-time processing
    yield();
}</code></pre></p>
<h2>Functions</h2>
<h3>Function Declaration</h3>
<pre><code>// Basic function
function myFunction() {
    // function body
}
<p>// Function with parameters
function processSignal(int gain, float frequency) {
    // function body
}</p>
<p>// Function with return value
function calculateGain(int input) 
returns int output
{
    output = input * 2;
}</p>
<p>// Function with local variables
function complexFunction(int param)
returns float result
locals int temp, array workspace[256]
{
    temp = param * 2;
    result = itof(temp);
}</code></pre></p>
<h3>Required Functions for Firmware</h3>
<p>#### Full Patches
<pre><code>function process() {
    loop {
        // Process global signal[0] and signal[1]
        // Audio range: -2047 to 2047 (12-bit)
        
        yield();  // REQUIRED - return control to host
    }
}</code></pre></p>
<p>#### Mod Patches
<pre><code>function operate1(int a)
returns int processed
{
    if ((int) global params[OPERATOR_1_PARAM_INDEX] == OPERATOR_1_MUL) {
        // Process global positions[0] and positions[1]
        // Return 1 if handled, 0 to pass through
        processed = 1;
    } else {
        processed = 0;
    }
}</p>
<p>function operate2(int a)
returns int processed
{
    // Similar to operate1 for second operator
    processed = 0;  // Pass through by default
}</code></pre></p>
<h3>Optional Callback Functions</h3>
<pre><code>function init() {
    // Called once when firmware loads
    // Initialize lookup tables, state, etc.
}
<p>function reset() {
    // Called on reset button or DAW reset
    // Clear delays, reset state
}</p>
<p>function update() {
    // Called when parameters change
    // Recalculate derived values
}</code></pre></p>
<h2>Built-in Functions</h2>
<h3>Audio Processing</h3>
<pre><code>// Memory operations (delay lines)
read(int offset, int frameCount, pointer buffer)
write(int offset, int frameCount, pointer buffer)
<p>// Control flow
yield()                 // Return control to host (required in loops)
abort()                 // Kill firmware, restore normal operation</code></pre></p>
<h3>Debug Functions</h3>
<pre><code>trace(pointer string)   // Output debug string to console</code></pre>
<h3>Math Functions</h3>
<pre><code>// Basic math (from source examples)
float cos(float x)      // Cosine (if available)
float sin(float x)      // Sine (if available)
float abs(float x)      // Absolute value
float floor(float x)    // Floor function</code></pre>
<h2>Global Variables and APIs</h2>
<h3>Always Available</h3>
<pre><code>global array params[PARAM_COUNT]        // Parameter values (0-255)
global array displayLEDs[4]            // LED displays (8-bit masks)
global int clock                       // Sample counter (0-65535)
global int instance                    // Unique plugin instance ID</code></pre>
<h3>Full Patches Only</h3>
<pre><code>global array signal[2]                 // Audio I/O: [left, right]
                                       // Range: -2047 to 2047 (12-bit)</code></pre>
<h3>Mod Patches Only</h3>
<pre><code>global array positions[2]              // Memory positions: [left, right]
                                       // Range: 0x00000 to 0xFFFFF (20-bit fixed point)</code></pre>
<h3>Parameter Access</h3>
<pre><code>// Use predefined constants (externally defined)
int knob1 = (int) global params[OPERAND_1_HIGH_PARAM_INDEX];
int knob2 = (int) global params[OPERAND_1_LOW_PARAM_INDEX];
int switches = (int) global params[SWITCHES_PARAM_INDEX];
<p>// Switch testing
if ((int) global params[SWITCHES_PARAM_INDEX] & SWITCHES_SYNC_MASK) {
    // Sync is enabled
}</code></pre></p>
<h2>Memory Management</h2>
<h3>Static Allocation Only</h3>
<pre><code>// All memory must be declared at compile time
global array largeBuffer[16384]    // Global storage
array tempBuffer[64]               // Local storage (function scope)
<p>// NO dynamic allocation - these don't exist:
// malloc(), free(), new, delete</code></pre></p>
<h3>Memory Access Patterns</h3>
<pre><code>// Safe array access
array buffer[1024];
int index = 0;
if (index >= 0 && index < 1024) {
    buffer[index] = value;  // Safe
}
<p>// Circular buffer pattern
global int writePos = 0;
global array circularBuffer[1024];</p>
<p>writePos = (writePos + 1) % 1024;   // Wrap around
circularBuffer[writePos] = newValue;</code></pre></p>
<h2>Real-time Considerations</h2>
<h3>Cooperative Multitasking</h3>
<pre><code>function process() {
    loop {
        // Process one sample or small batch
        
        yield();  // REQUIRED - return control regularly
    }
}</code></pre>
<h3>Performance Guidelines</h3>
<pre><code>// Prefer integer operations for speed
int sample = (int) global signal[0];
sample = sample >> 1;  // Fast divide by 2
global signal[0] = sample;
<p>// Use lookup tables for expensive calculations
readonly array expTable[256] = { /<em> precomputed values </em>/ };
int result = expTable[input & 0xFF];</code></pre></p>
<h2>Common Patterns</h2>
<h3>Parameter Scaling</h3>
<pre><code>// Map 0-255 parameter to useful range
int bits = ((int) global params[OPERAND_1_HIGH_PARAM_INDEX] >> 5) + 1;  // 1-8
float gain = itof((int) global params[OPERAND_1_HIGH_PARAM_INDEX]) / 255.0;  // 0.0-1.0
int delay = (int) global params[OPERAND_1_HIGH_PARAM_INDEX] << 3;  // 0-2040</code></pre>
<h3>Audio Range Clamping</h3>
<pre><code>// Ensure audio stays in valid range
if (sample > 2047) sample = 2047;
else if (sample < -2047) sample = -2047;</code></pre>
<h3>LED Display</h3>
<pre><code>// Set LED patterns (8-bit mask, bit 0 = leftmost LED)
global displayLEDs[0] = 0x01;           // Single LED left
global displayLEDs[0] = 0x80;           // Single LED right  
global displayLEDs[0] = 0xFF;           // All LEDs on
global displayLEDs[0] = 1 << position;  // Variable position</code></pre>
<h3>Delay Line Access</h3>
<pre><code>// Read/write delay memory
array buffer[2];  // Stereo pair
<p>// Write current sample to delay line
write(global clock, 1, global signal);</p>
<p>// Read delayed sample
read(global clock - delayTime, 1, buffer);
int delayedLeft = buffer[0];
int delayedRight = buffer[1];</code></pre></p>
<h2>Comments</h2>
<pre><code>// Single line comment
<p>/*
   Multi-line comment
   can span multiple lines
*/</p>
<p>/* 
 * Traditional C-style
 * multi-line comment
 */</code></pre></p>
<h2>Preprocessor</h2>
<strong>Note:</strong> Impala has NO preprocessor. These don't exist:
<ul><li><code>#include</code></li><li><code>#define</code></li><li><code>#ifdef</code></li><li><code>#pragma</code></li></ul>
<p>All configuration must be done with <code>const</code> declarations and conditional compilation is not available.</p>
<h2>Error Handling</h2>
<pre><code>// No exceptions - use return values and defensive programming
function safeDivide(int a, int b)
returns int result
{
    if (b != 0) {
        result = a / b;
    } else {
        result = 0;  // Safe default
        trace("Division by zero avoided");
    }
}</code></pre>
<h2>Example: Complete Bit Crusher</h2>
<pre><code>/*
    Simple bit crusher firmware demonstrating core Impala syntax
*/
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>global array signal[2]              // Audio I/O
global array params[PARAM_COUNT]    // Parameters
global array displayLEDs[4]        // LED displays</p>
<p>function process() {
    loop {
        // Get bit depth from first knob (1-12 bits)
        int bits = ((int) global params[OPERAND_1_HIGH_PARAM_INDEX] >> 4) + 1;
        
        // Create bit mask for quantization
        int mask = 0xFFF0 << (12 - bits);
        
        // Apply bit crushing to both channels
        global signal[0] = (int) global signal[0] & mask;
        global signal[1] = (int) global signal[1] & mask;
        
        // Show bit depth on LEDs
        global displayLEDs[0] = (1 << bits) - 1;
        
        yield();  // Return control to host
    }
}</code></pre></p>
<p>This syntax reference reflects the actual Impala language as implemented in the Permut8 compiler, based on analysis of working source code.</p>
<p>---</p>
<h2>See Also</h2>
<strong>üìö Essential References:</strong>
<ul><li><strong><a href="core_language_reference.md">Core Language Reference</a></strong> - Quick start guide with minimal examples</li><li><strong><a href="../reference/memory_management.md">Memory Management Reference</a></strong> - Delay lines, read/write operations, advanced patterns</li><li><strong><a href="../reference/utilities_reference.md">Utilities Reference</a></strong> - Native functions, math library, debugging tools</li><li><strong><a href="../../../Impala Snippets.txt">Impala Snippets</a></strong> - Copy-paste utility functions and advanced math</li></ul>
<strong>üç≥ Practical Examples:</strong>
<ul><li><strong><a href="../user-guides/QUICKSTART.md">QUICKSTART Guide</a></strong> - 30-minute firmware tutorial</li><li><strong><a href="../user-guides/cookbook/fundamentals/">Cookbook Fundamentals</a></strong> - Basic building blocks</li><li><strong><a href="../user-guides/cookbook/audio-effects/">Audio Effects Cookbook</a></strong> - Complete effect implementations</li></ul>
<strong>üèóÔ∏è System Architecture:</strong>
<ul><li><strong><a href="../architecture/memory-model.md">Memory Model</a></strong> - Static allocation, delay lines, position arrays</li><li><strong><a href="../architecture/processing-order.md">Processing Order</a></strong> - Function call sequence and timing</li><li><strong><a href="../architecture/state-management.md">State Management</a></strong> - Global variables and persistence</li></ul>
<strong>üîß Development:</strong>
<ul><li><strong><a href="../user-guides/tutorials/build-your-first-filter.md">Build Your First Filter</a></strong> - Step-by-step tutorial</li><li><strong><a href="../user-guides/tutorials/debug-your-plugin.md">Debug Your Plugin</a></strong> - Debugging and troubleshooting</li><li><strong><a href="../user-guides/tutorials/test-your-plugin.md">Test Your Plugin</a></strong> - Validation and testing</li></ul>
</div>


<div class="file-section" id="standard-library-reference">
    <div class="file-title">üìÑ Standard Library Reference</div>
    <h1>Standard Library Reference</h1>
<h2>Overview</h2>
<p>The Impala language provides essential native functions and mathematical operations optimized for real-time audio processing on Permut8 firmware. This reference documents all available built-in functions, their usage patterns, and practical applications in firmware development.</p>
<p>Impala focuses on real-time safety with static allocation, cooperative multitasking, and direct hardware integration for professional audio processing.</p>
<h2>Native Functions</h2>
<h3>Memory Operations</h3>
<p>Essential functions for delay line and audio buffer management:</p>
<pre><code>// Read from delay memory
read(int offset, int frameCount, pointer buffer)
<p>// Write to delay memory  
write(int offset, int frameCount, pointer buffer)</code></pre></p>
<strong>Delay Line Example:</strong>
<pre><code>global array signal[2]      // Audio I/O
global array delayBuffer[2] // For reading delay samples
<p>function process() {
    loop {
        // Write current samples to delay line
        write(global clock, 1, global signal)
        
        // Read delayed samples (1000 samples ago)
        read(global clock - 1000, 1, delayBuffer)
        
        // Mix with delay
        global signal[0] = (global signal[0] + delayBuffer[0]) >> 1
        global signal[1] = (global signal[1] + delayBuffer[1]) >> 1
        
        yield()
    }
}</code></pre></p>
<h3>Control Flow Functions</h3>
<pre><code>// Return control to audio engine (REQUIRED in processing loops)
yield()
<p>// Kill firmware and restore normal operation
abort()</code></pre></p>
<strong>Processing Loop Pattern:</strong>
<pre><code>function process() {
    loop {
        // Process audio samples
        global signal[0] = global signal[0] >> 1  // Simple gain reduction
        global signal[1] = global signal[1] >> 1
        
        yield()  // CRITICAL: Return control to system
    }
}</code></pre>
<h3>Debug Functions</h3>
<pre><code>// Output debug message to console
trace(pointer string)</code></pre>
<strong>Debug Usage:</strong>
<pre><code>function update() {
    trace("Parameters updated")
    trace("Knob 1 value changed")
}</code></pre>
<h2>Mathematical Operations</h2>
<h3>Basic Arithmetic</h3>
<p>Impala supports standard arithmetic with integer and floating-point operations:</p>
<pre><code>// Integer arithmetic (preferred for performance)
int result = a + b       // Addition
int result = a - b       // Subtraction  
int result = a * b       // Multiplication
int result = a / b       // Division
int result = a % b       // Modulo
<p>// Bitwise operations (very fast)
int result = a & b       // Bitwise AND
int result = a | b       // Bitwise OR
int result = a ^ b       // Bitwise XOR
int result = ~a          // Bitwise NOT
int result = a << 2      // Left shift (multiply by 4)
int result = a >> 2      // Right shift (divide by 4)</code></pre></p>
<h3>Trigonometric Functions</h3>
<p>Available floating-point math functions:</p>
<pre><code>// Basic trigonometric functions
float cos(float x)       // Cosine function
float sin(float x)       // Sine function
float tan(float x)       // Tangent function</code></pre>
<strong>Oscillator Example:</strong>
<pre><code>const float TWO_PI = 6.28318530717958647692
<p>global float phase = 0.0</p>
<p>function process() {
    loop {
        // Generate sine wave
        int sineOutput = ftoi(sin(phase) * 1000.0)
        
        global signal[0] = sineOutput
        global signal[1] = sineOutput
        
        // Advance phase for 440Hz at 48kHz sample rate
        phase = phase + TWO_PI * 440.0 / 48000.0
        if (phase > TWO_PI) phase = phase - TWO_PI
        
        yield()
    }
}</code></pre></p>
<h3>Number Functions</h3>
<pre><code>// Absolute value
int abs(int x)           // Integer absolute value
float fabs(float x)      // Floating-point absolute value
<p>// Min/max functions
int min(int a, int b)    // Minimum value
int max(int a, int b)    // Maximum value
float fmin(float a, float b)  // Float minimum
float fmax(float a, float b)  // Float maximum</code></pre></p>
<strong>Audio Clipping Example:</strong>
<pre><code>function clipToRange(int sample) returns int clipped {
    clipped = max(-2047, min(2047, sample))  // Clip to 12-bit audio range
}</code></pre>
<h3>Type Conversion</h3>
<pre><code>// Convert between int and float
float itof(int x)        // Integer to float
int ftoi(float x)        // Float to integer (truncates)</code></pre>
<strong>Parameter Scaling Example:</strong>
<pre><code>function update() {
    // Convert 8-bit parameter (0-255) to float (0.0-1.0)
    float knobValue = itof((int)global params[0]) / 255.0
    
    // Convert to audio range
    int audioGain = ftoi(knobValue * 2047.0)
}</code></pre>
<h2>String Operations</h2>
<p>Basic string utilities for debugging and parameter display:</p>
<pre><code>// String length
int strlen(pointer string)
<p>// String copy
pointer strcpy(pointer dest, pointer src)</p>
<p>// String concatenation  
pointer strcat(pointer dest, pointer src)</p>
<p>// String comparison
int strcmp(pointer str1, pointer str2)</code></pre></p>
<strong>Debug Message Building:</strong>
<pre><code>function debugParameterChange() {
    array message[64]
    array valueStr[16]
    
    strcpy(message, "Param changed: ")
    // Convert parameter value to string representation
    // (Note: number-to-string conversion depends on available utilities)
    strcat(message, valueStr)
    
    trace(message)
}</code></pre>
<h2>Memory Management</h2>
<h3>Static Allocation Only</h3>
<p>Impala uses static memory allocation - no dynamic allocation available:</p>
<pre><code>// Global arrays (allocated at compile time)
global array largeBuffer[8192]     // Global storage
global int bufferPosition = 0      // Global state
<p>// Local arrays (function scope)
function processBuffer() {
    array tempBuffer[64]           // Local temporary storage
    int localCounter               // Local variable
    
    // All memory sizes must be known at compile time
}</code></pre></p>
<h3>Safe Array Access</h3>
<p>Always validate array indices to prevent memory corruption:</p>
<pre><code>function safeArrayAccess(array buffer[1024], int index, int value) {
    // Bounds checking
    if (index >= 0 && index < 1024) {
        buffer[index] = value     // Safe access
    }
}
<p>// Circular buffer with wraparound
function circularAccess(array buffer[256], int position) returns int value {
    int safePosition = position % 256  // Automatic wraparound
    value = buffer[safePosition]
}</code></pre></p>
<h2>Random Number Generation</h2>
<p>Simple random number generation for audio effects:</p>
<pre><code>// Basic linear congruential generator
global int randomSeed = 1
<p>function simpleRandom() returns int randomValue {
    randomSeed = randomSeed * 1103515245 + 12345
    randomValue = (randomSeed >> 16) & 0x7FFF  // 15-bit positive value
}</p>
<p>// Random value in range
function randomRange(int minVal, int maxVal) returns int result {
    int range = maxVal - minVal + 1
    result = minVal + (simpleRandom() % range)
}</code></pre></p>
<strong>Noise Generator Example:</strong>
<pre><code>function process() {
    loop {
        // Generate white noise
        int noise = randomRange(-1000, 1000)
        
        // Mix with input
        global signal[0] = (global signal[0] + noise) >> 1
        global signal[1] = (global signal[1] + noise) >> 1
        
        yield()
    }
}</code></pre>
<h2>Performance Utilities</h2>
<h3>Fixed-Point Arithmetic</h3>
<p>Prefer integer operations for best performance:</p>
<pre><code>// Use bit shifts instead of division/multiplication by powers of 2
int half = input >> 1        // Divide by 2
int quarter = input >> 2     // Divide by 4
int double = input << 1      // Multiply by 2
<p>// Fixed-point scaling (8.8 format - 8 integer bits, 8 fractional bits)
int scaledValue = (input * 256) >> 8  // Multiply by 1.0 in 8.8 format</code></pre></p>
<h3>Lookup Tables</h3>
<p>Pre-compute expensive calculations for real-time performance:</p>
<pre><code>global array sineTable[256]
<p>function init() {
    // Pre-compute sine table during initialization
    int i
    for (i = 0 to 255) {
        float angle = itof(i) * TWO_PI / 256.0
        sineTable[i] = ftoi(sin(angle) * 2047.0)  // Scale to audio range
    }
}</p>
<p>function fastSine(int phase) returns int result {
    int index = (phase >> 8) & 0xFF  // Scale phase to table index
    result = sineTable[index]
}</code></pre></p>
<h2>Audio-Specific Utilities</h2>
<h3>Parameter Scaling</h3>
<p>Convert parameter values to useful audio ranges:</p>
<pre><code>// Scale 8-bit parameter to frequency range using lookup table
global array freqLookupTable[256]  // Pre-computed frequency values
<p>function paramToFrequency(int paramValue) returns int frequency {
    // paramValue: 0-255 ‚Üí frequency: 20Hz-20000Hz (logarithmic)
    if (paramValue >= 0 && paramValue <= 255) {
        frequency = freqLookupTable[paramValue]
    } else {
        frequency = 440  // Default frequency
    }
}</p>
<p>// Scale parameter to linear gain using lookup table
global array gainLookupTable[256]  // Pre-computed gain values</p>
<p>function paramToGain(int paramValue) returns int linearGain {
    // paramValue: 0-255 ‚Üí gain: linear values from lookup table
    if (paramValue >= 0 && paramValue <= 255) {
        linearGain = gainLookupTable[paramValue]
    } else {
        linearGain = 256  // Default unity gain (scaled)
    }
}</code></pre></p>
<h3>Audio Processing Helpers</h3>
<pre><code>// Soft clipping using integer approximation
function softClip(int input) returns int output {
    if (input > 1500) {
        output = 1500 + ((input - 1500) >> 2)  // Gentle compression above threshold
    } else if (input < -1500) {
        output = -1500 + ((input + 1500) >> 2)
    } else {
        output = input  // Linear region
    }
    
    // Hard limit to audio range
    if (output > 2047) output = 2047
    if (output < -2047) output = -2047
}
<p>// Simple low-pass filter
global int filterMemory = 0</p>
<p>function lowPass(int input, int cutoff) returns int filtered {
    // cutoff: 0-255, higher values = more filtering
    int difference = input - filterMemory
    filterMemory = filterMemory + ((difference * cutoff) >> 8)
    filtered = filterMemory
}</code></pre></p>
<h2>Best Practices</h2>
<h3>Real-Time Safety</h3>
<ul><li><strong>Use static allocation</strong> - all array sizes known at compile time</li><li><strong>Call yield() regularly</strong> - in all processing loops</li><li><strong>Prefer integer math</strong> - faster than floating-point operations</li><li><strong>Avoid complex algorithms</strong> - keep processing predictable</li></ul>
<h3>Performance Optimization</h3>
<ul><li><strong>Use lookup tables</strong> for expensive calculations (sin, exp, etc.)</li><li><strong>Use bit shifts</strong> instead of multiplication/division by powers of 2</li><li><strong>Cache parameter values</strong> - avoid repeated array access</li><li><strong>Minimize function calls</strong> in inner loops</li></ul>
<h3>Memory Management</h3>
<ul><li><strong>Initialize arrays</strong> to known values in init() function</li><li><strong>Validate array indices</strong> before access</li><li><strong>Use modulo arithmetic</strong> for circular buffers</li><li><strong>Group related data</strong> together for cache efficiency</li></ul>
<h3>Error Prevention</h3>
<ul><li><strong>Always clip audio output</strong> to valid range (-2047 to 2047)</li><li><strong>Check for division by zero</strong> in calculations</li><li><strong>Validate parameter ranges</strong> before use</li><li><strong>Use trace() liberally</strong> during development</li></ul>
<p>---</p>
<em>This reference covers the core Impala standard library functions available for Permut8 firmware development. For advanced patterns and examples, see the <a href="../user-guides/cookbook/">Cookbook</a> and <a href="../user-guides/tutorials/">Tutorials</a>.</em>
</div>


<div class="file-section" id="types-and-operators">
    <div class="file-title">üìÑ Types And Operators</div>
    <h1>Types and Operators - Data Types in Permut8 Firmware</h1>
<p>Understanding Impala's data types and operators is essential for efficient audio processing. Permut8 firmware works with integers, arrays, and specialized operations designed for real-time DSP performance.</p>
<h2>Basic Data Types</h2>
<h3>Integer Type</h3>
<p>All audio samples and most calculations use signed integers:</p>
<pre><code>int sample = -1024          // Audio sample (-2047 to 2047)
int param = 127             // Parameter value (0 to 255)
int position = 0x80000      // 20-bit position value</code></pre>
<strong>Key Range</strong>: Audio samples range from -2047 to 2047, giving you 12-bit signed audio with plenty of headroom for calculations.
<h3>Boolean Type</h3>
<p>Use for control logic and state flags:</p>
<pre><code>int gate_open = 1                    // Use 1 for true, 0 for false
int effect_bypass = 0
if (params[7] > 128) effect_bypass = 1
<p>if (gate_open && (effect_bypass == 0)) {
    // Process audio
}</code></pre></p>
<h3>Array Types</h3>
<p>Fixed-size arrays for buffers and lookup tables:</p>
<pre><code>global array delay_line[1024]               // 1024-sample delay buffer
global array sine_table[256]                // Lookup table for oscillator
global array coefficients[8] = {64, 32, 16, 8, 4, 2, 1, 1}  // Filter coefficients</code></pre>
<h2>Fixed-Point Arithmetic</h2>
<h3>Position Values (20-bit)</h3>
<p>Positions use 16.4 fixed-point format (16 integer bits, 4 fractional bits):</p>
<pre><code>int base_pos = 0x10000      // Position 1.0
int half_pos = 0x08000      // Position 0.5
int quarter = 0x04000       // Position 0.25
<p>// Extract integer part
int sample_index = position >> 4</p>
<p>// Extract fractional part for interpolation
int frac = position & 0xF</code></pre></p>
<h3>Parameter Scaling</h3>
<p>Convert 8-bit parameters to useful ranges:</p>
<pre><code>// Scale parameter (0-255) to full audio range
int gain = params[0] * 2047 / 255
<p>// Scale to frequency range (0-4000 Hz equivalent)
int frequency = params[1] * 4000 / 255</p>
<p>// Scale to feedback amount (-128 to +127)
int feedback = params[2] - 128</code></pre></p>
<h2>Bitwise Operations</h2>
<h3>Efficient Calculations</h3>
<p>Use bit operations for fast arithmetic:</p>
<pre><code>// Fast division by powers of 2
int half_sample = input >> 1        // Divide by 2
int quarter = input >> 2            // Divide by 4
int eighth = input >> 3             // Divide by 8
<p>// Fast multiplication by powers of 2
int doubled = input << 1            // Multiply by 2
int quadrupled = input << 2         // Multiply by 4</p>
<p>// Wraparound using bit masks (for buffer sizes that are powers of 2)
int next_pos = (current_pos + 1) & 1023  // Wrap at 1024</code></pre></p>
<h3>Bit Manipulation for Control</h3>
<p>Extract and combine multiple values efficiently:</p>
<pre><code>// Pack two 8-bit values into one int
int packed = (high_byte << 8) | low_byte
<p>// Extract values back
int high = (packed >> 8) & 0xFF
int low = packed & 0xFF</p>
<p>// Set individual bits for LED control
int led_pattern = 0
led_pattern |= (1 << 3)   // Turn on LED 3
led_pattern &= ~(1 << 1)  // Turn off LED 1</code></pre></p>
<h2>Array Operations</h2>
<h3>Safe Array Access</h3>
<p>Use modulo or bit masking to prevent buffer overruns:</p>
<pre><code>global array buffer[512]
global int pos = 0
<p>// Safe access with modulo
buffer[pos % 512] = input</p>
<p>// Faster access with bit mask (buffer size must be power of 2)
buffer[pos & 511] = input
pos = (pos + 1) & 511</code></pre></p>
<h3>Linear Interpolation</h3>
<p>Smooth array lookups for high-quality audio:</p>
<pre><code>function interpolate_lookup(array table[256], int position) returns int result {
    int index = position >> 8          // Integer part
    int frac = position & 0xFF         // Fractional part
    
    int sample1 = table[index & 255]
    int sample2 = table[(index + 1) & 255]
    
    // Linear interpolation
    result = sample1 + ((sample2 - sample1) * frac / 256)
}</code></pre>
<h2>Arithmetic Operators</h2>
<h3>Audio-Safe Math</h3>
<p>Prevent overflow in audio calculations:</p>
<pre><code>// Safe addition with saturation
function add_saturate(int a, int b) returns int result {
    result = a + b
    if (result > 2047) result = 2047
    if (result < -2047) result = -2047
}
<p>// Safe multiplication with scaling
function multiply_audio(int sample, int gain) returns int result {
    result = (sample * gain) >> 8  // Assume gain is 8-bit (0-255)
}</code></pre></p>
<h3>Comparison and Logic</h3>
<pre><code>// Threshold detection
int above_threshold = 0
if (abs(input) > noise_floor) above_threshold = 1
<p>// Range checking
int in_range = 0
if ((param >= min_val) && (param <= max_val)) in_range = 1</p>
<p>// Conditional assignment
int output = input  // Default value
if (bypass == 0) output = process_effect(input)</code></pre></p>
<p>Understanding these types and operators helps you write efficient, reliable audio processing code that makes full use of Permut8's capabilities while maintaining real-time performance.</p>
</div>


<div class="file-section" id="core-functions">
    <div class="file-title">üìÑ Core Functions</div>
    <h1>Impala Core Functions API Reference</h1>
<h2>Overview</h2>
<p>This comprehensive API reference documents all Impala core functions, global variables, and integration patterns for professional Permut8 firmware development. Use this as your daily development reference for building efficient, maintainable DSP code.</p>
<strong>Target Audience</strong>: Experienced developers building custom Permut8 firmware  
<strong>Prerequisites</strong>: Understanding of digital signal processing and C programming  
<strong>Integration</strong>: Works with parameter mapping (Session 16b) and preset systems (Session 16a)
<p>---</p>
<h2>Core Processing Functions</h2>
<h3>process()</h3>
<strong>Primary processing function for full patches that replace the entire audio engine.</strong>
<pre><code>function process() {
    loop {
        // Process audio samples
        yield()
    }
}</code></pre>
<strong>Global Variables Used</strong>:
<ul><li><code>global array signal[2]</code>: Stereo audio I/O [left, right] with values -2047 to 2047</li><li><code>global array params[8]</code>: Parameter values 0-255 from hardware controls</li></ul>
<strong>Usage Pattern</strong>:
<pre><code>function process() {
    loop {
        // Process left channel
        int left = global signal[0]
        left = applyEffect(left)
        global signal[0] = clampAudio(left)
        
        // Process right channel  
        int right = global signal[1]
        right = applyEffect(right)
        global signal[1] = clampAudio(right)
        
        yield()
    }
}</code></pre>
<strong>Performance Considerations</strong>:
<ul><li>Called at 44.1kHz with typical count values of 8-32 samples</li><li>Must complete processing within ~725Œºs (32 samples @ 44.1kHz)</li><li>Use lookup tables for complex calculations</li><li>Avoid memory allocation within process()</li></ul>
<strong>Integration with Parameter System</strong>:
<pre><code>function process() {
    loop {
        // Read mapped parameters
        int gainParam = (int)global params[0]
        int cutoffParam = (int)global params[1]
        
        // Apply parameter morphing if enabled
        if (morphingActive) {
            gainParam = interpolateParameter(gainParam, targetGain, morphRate)
        }
        
        // Process audio
        global signal[0] = applyGain(global signal[0], gainParam)
        global signal[1] = applyGain(global signal[1], gainParam)
        
        yield()
    }
}</code></pre>
<p>---</p>
<h3>operate1() and operate2()</h3>
<strong>Modular processing functions for mod patches that replace individual operators.</strong>
<pre><code>function operate1() {
    // Process single operator input
}
<p>function operate2() {
    // Process dual operator inputs
}</code></pre></p>
<strong>Parameters</strong>:
<ul><li>Operators work with <code>global signal[]</code> array directly</li><li><strong>Audio Range</strong>: -2047 to 2047 (12-bit signed)</li></ul>
<strong>operate1() Single-Input Operator</strong>:
<pre><code>function operate1() {
    // Example: Waveshaper with drive parameter
    int drive = (int)global params[0]
    
    // Apply drive (1-100 range mapped to 1x-10x)
    int input = global signal[0]
    int driven = (input * drive) / 10
    
    // Waveshaping lookup table
    if (driven > 2047) driven = 2047
    if (driven < -2047) driven = -2047
    
    int shaped = waveshapeTable[driven + 2047]
    global signal[0] = clampAudio(shaped)
}</code></pre>
<strong>operate2() Dual-Input Operator</strong>:
<pre><code>function operate2() {
    // Example: Ring modulator
    int depth = (int)global params[1]
    
    // Ring modulation: multiply and scale
    int input1 = global signal[0]
    int input2 = global signal[1]
    int product = (input1 * input2) >> 11  // Divide by 2048 using bit shift
    
    // Mix with dry signal based on depth
    int dry = (input1 * (100 - depth)) / 100
    int wet = (product * depth) / 100
    
    global signal[0] = clampAudio(dry + wet)
}</code></pre>
<strong>Position Management</strong>:
<pre><code>function operate1() {
    // Read current position for this operator
    int pos = positions[currentOperatorIndex]
    
    // Use position for delay line access
    array delayRead[2]
    read(global clock - pos, 1, delayRead)
    int delayed = delayRead[0]
    
    // Write current input to delay line
    array delayWrite[2]
    delayWrite[0] = global signal[0]
    delayWrite[1] = global signal[1]
    write(global clock, 1, delayWrite)
    
    global signal[0] = delayed
}</code></pre>
<p>---</p>
<h2>Global Variables Reference</h2>
<h3>params[]</h3>
<strong>Parameter array providing access to all patch parameters.</strong>
<pre><code>global array params[8]  // Parameter values (0-255 from hardware)</code></pre>
<strong>Standard Usage</strong>:
<pre><code>// Read parameter with type conversion
int gain = (int)global params[0]
float frequency = itof((int)global params[1])
<p>// Parameter validation
int cutoff = (int)global params[2]
if (cutoff < 20) cutoff = 20
if (cutoff > 255) cutoff = 255</code></pre></p>
<strong>Parameter Mapping Integration</strong>:
<pre><code>// Use with parameter mapping system
function updateParameters() {
    // MIDI CC mapped parameters
    global params[0] = mapMidiCC(ccValue, 20, 20000)
    
    // Preset morphing active
    if (morphingActive) {
        global params[1] = interpolateParameter(
            global params[1], 
            presetTargetValue, 
            morphRate
        )
    }
}
        );
    }
}</code></pre>
<strong>Parameter Scaling Patterns</strong>:
<pre><code>// Linear scaling: 0-255 ‚Üí target range
function mapLinear(int param, int minVal, int maxVal) returns int result {
    result = minVal + ((param * (maxVal - minVal)) / 255)
}
<p>// Exponential scaling: Better for frequency parameters
function mapExponential(int param, int minVal, int maxVal) returns int result {
    // Use lookup table for exponential curve
    array expTable[256] // Pre-calculated exponential values
    int scaledIndex = param & 255
    result = minVal + ((expTable[scaledIndex] * (maxVal - minVal)) >> 8)
}</p>
<p>// Musical scaling: Semitone mapping (simplified integer version)
function mapMusical(int param) returns int result {
    // Simplified semitone mapping using lookup table
    array semitoneTable[128] // Pre-calculated semitone frequencies
    int noteIndex = param >> 1 // Map 0-255 to 0-127
    result = semitoneTable[noteIndex]
}</code></pre></p>
<p>---</p>
<h3>signal[]</h3>
<strong>Global audio buffer for stereo audio input and output.</strong>
<pre><code>global array signal[2]  // Stereo audio buffer [left, right]</code></pre>
<strong>Usage in Audio Processing</strong>:
<pre><code>// Access audio input/output
function process() {
    loop {
        int frequency = (int)global params[0]
        
        // Process left channel
        global signal[0] = generateSine(frequency)
        
        // Process right channel (copy or process independently)
        global signal[1] = global signal[0]
        
        yield()
    }
}
<p>// Operator 2: Generate modulator
function operate2() {
    int modFreq = (int)global params[1]
    global signal[1] = generateSine(modFreq)
}</p>
<p>// Operator 3: Apply FM synthesis
function operate1() {
    int carrier = global signal[0]
    int modulator = global signal[1]
    int modDepth = (int)global params[2]
    
    // Frequency modulation
    int modulated = generateSine(carrierFreq + (modulator * modDepth))
    global signal[0] = modulated
}</code></pre></p>
<strong>Buffer Management</strong>:
<pre><code>// Clear buffers between processing cycles
function clearSignalBuffers() {
    global signal[0] = 0
    global signal[1] = 0
}</code></pre>
<p>---</p>
<h3>positions[]</h3>
<strong>Fixed-point position tracking for delays, oscillators, and time-based effects.</strong>
<pre><code>global array positions[2]  // 20-bit fixed-point (16.4 format)</code></pre>
<strong>Fixed-Point Format</strong>:
<ul><li><strong>16.4 format</strong>: 16 bits integer, 4 bits fractional</li><li><strong>Range</strong>: 0 to 65535.9375 with 1/16 precision</li><li><strong>Usage</strong>: Precise sub-sample timing for audio algorithms</li></ul>
<strong>Delay Line Implementation</strong>:
<pre><code>function operate1() {
    int delayTime = (int)global params[0]  // In samples
    
    // Read from delay line using native read/write
    array delayRead[2]
    read(global clock - delayTime, 1, delayRead)
    int delayed = delayRead[0]
    
    // Write input to delay line
    array delayWrite[2]
    delayWrite[0] = global signal[0]
    delayWrite[1] = global signal[1]
    write(global clock, 1, delayWrite)
    
    // Advance position with sub-sample precision
    global positions[0] = global positions[0] + 16  // Increment by 1.0
    
    global signal[0] = delayed
}</code></pre>
<strong>Oscillator Phase Tracking</strong>:
<pre><code>function generateSine(int frequency) returns int sineValue {
    // Convert frequency to phase increment (16.4 format)
    int phaseInc = frequency * 16  // Scale for 16.4 format
    
    // Advance phase
    global positions[1] = global positions[1] + phaseInc
    
    // Extract table index (upper 16 bits)
    int tableIndex = global positions[1] >> 4
    
    sineValue = sineTable[tableIndex & 255]  // Assuming 256-entry table
}</code></pre>
<strong>Variable Rate Processing</strong>:
<pre><code>function operate1() {
    int speed = (int)global params[1]  // 0-255 mapped to 0.1x-2.0x
    
    // Variable increment based on speed
    int increment = (speed * 16) / 100  // Scale to 16.4 format
    global positions[0] = global positions[0] + increment
    
    int index = (global positions[0] >> 4) & 1023  // Assuming 1024 buffer
    global signal[0] = audioBuffer[index]
}</code></pre>
<p>---</p>
<h3>displayLEDs[]</h3>
<strong>LED control array for visual feedback and status indication.</strong>
<pre><code>global array displayLEDs[4]  // LED brightness values (0-255)</code></pre>
<strong>Basic LED Control</strong>:
<pre><code>// Set individual LEDs
global displayLEDs[0] = 255  // Full brightness
global displayLEDs[1] = 128  // Half brightness
global displayLEDs[2] = 0    // Off
<p>// LED patterns
function setLEDPattern(int pattern) {
    int i
    for (i = 0 to 3) {
        if ((pattern & (1 << i)) != 0) {
            global displayLEDs[i] = 255
        } else {
            global displayLEDs[i] = 0
        }
    }
}</code></pre></p>
<strong>Parameter Visualization</strong>:
<pre><code>function updateParameterLEDs() {
    // Show filter cutoff on LEDs 0-3
    int cutoff = (int)global params[0]
    int ledCount = (cutoff * 4) / 255
    
    int i
    for (i = 0 to 3) {
        if (i < ledCount) {
            global displayLEDs[i] = 255  // On
        } else {
            global displayLEDs[i] = 0    // Off
        }
    }
}</code></pre>
<strong>VU Meter Implementation</strong>:
<pre><code>global int peakHold = 0
global int peakDecay = 0
<p>function updateVUMeter(int audioLevel) {
    // Convert audio level to LED count
    int level = abs(audioLevel)
    int ledCount = (level * 4) / 2047
    
    // Peak hold with decay
    if (ledCount > peakHold) {
        peakHold = ledCount
        peakDecay = 0
    } else {
        peakDecay = peakDecay + 1
        if (peakDecay > 10) {  // Decay every 10 cycles
            if (peakHold > 0) peakHold = peakHold - 1
            peakDecay = 0
        }
    }
    
    // Update LED display
    int i
    for (i = 0 to 3) {
        if (i < ledCount) {
            global displayLEDs[i] = 255           // Current level
        } else if (i == peakHold) {
            global displayLEDs[i] = 128           // Peak indicator
        } else {
            global displayLEDs[i] = 0             // Off
        }
    }
}</code></pre></p>
<strong>Status Indication Integration</strong>:
<pre><code>function updateStatusLEDs() {
    // Preset system status
    if (presetLoading == 1) {
        global displayLEDs[STATUS_LED] = 255      // Bright during load
    } else if (presetModified == 1) {
        global displayLEDs[STATUS_LED] = 128      // Dim when modified
    } else {
        global displayLEDs[STATUS_LED] = 64       // Low when clean
    }
    
    // MIDI learn status - blinking pattern
    if (midiLearnActive == 1) {
        if ((global clock % 20) < 10) {
            global displayLEDs[LEARN_LED] = 255  // On phase
        } else {
            global displayLEDs[LEARN_LED] = 0    // Off phase
        }
    }
}</code></pre>
<p>---</p>
<h3>clock</h3>
<strong>Global timing reference for tempo-sync and timing calculations.</strong>
<pre><code>global int clock  // Sample counter since patch start</code></pre>
<strong>Tempo Calculations</strong>:
<pre><code>// Convert BPM to clock frequency
function calculateClockFreq(int bpm) returns int result {
    result = (44100 * 60) / bpm
}
<p>// Check for beat timing
function isBeatTime(int bpm) returns int result {
    int beatInterval = calculateClockFreq(bpm)
    if ((global clock % beatInterval) == 0) {
        result = 1
    } else {
        result = 0
    }
}</code></pre></p>
<strong>Modulation LFO</strong>:
<pre><code>function getLFO(int rate) returns int result {
    int cycleLength = 44100 / rate
    int phase = global clock % cycleLength
    int phaseIndex = (phase * 256) / cycleLength  // Map to 0-255 for table lookup
    result = sineTable[phaseIndex & 255]
}</code></pre>
<strong>Synchronized Effects</strong>:
<pre><code>function operate1() {
    int bpm = (int)global params[0]
    int beatLength = calculateClockFreq(bpm)
    
    // Delay time synced to quarter notes
    int delayTime = beatLength / 4
    
    // Use native read/write for synchronized delay
    array delayRead[2]
    read(global clock - delayTime, 1, delayRead)
    
    global signal[0] = delayRead[0]
    global signal[1] = delayRead[1]
}</code></pre>
<p>---</p>
<h2>Utility Functions</h2>
<h3>Mathematical Functions</h3>
<strong>Audio Sample Clamping</strong>:
<pre><code>function clampAudio(int sample) returns int result {
    if (sample > 2047) result = 2047
    else if (sample < -2047) result = -2047
    else result = sample
}
<p>// Fast clamping using conditional assignment
function fastClamp(int sample) returns int result {
    if (sample > 2047) sample = 2047
    if (sample < -2047) sample = -2047
    result = sample
}</code></pre></p>
<strong>Fixed-Point Math</strong>:
<pre><code>// Multiply two fixed-point numbers (16.16 format)
function fixedMultiply(int a, int b) returns int result {
    result = (a * b) >> 16
}
<p>// Convert float to fixed-point
function floatToFixed(float f) returns int result {
    result = ftoi(f * 65536.0)
}</p>
<p>// Convert fixed-point to float
function fixedToFloat(int fixed) returns float result {
    result = itof(fixed) / 65536.0
}</code></pre></p>
<strong>Interpolation Functions</strong>:
<pre><code>// Linear interpolation
function lerp(float a, float b, float t) returns float result {
    result = a + t * (b - a)
}
<p>// Cubic interpolation for smoother parameter changes
function cubicInterp(float y0, float y1, float y2, float y3, float x) returns float result {
    float a = y3 - y2 - y0 + y1
    float b = y0 - y1 - a
    float c = y2 - y0
    float d = y1
    result = a <em> x </em> x <em> x + b </em> x <em> x + c </em> x + d
}</code></pre></p>
<h3>Conversion Functions</h3>
<strong>Frequency Conversions</strong>:
<pre><code>// Convert MIDI note to frequency (simplified using lookup)
array midiFreqTable[128]  // Pre-calculated MIDI note frequencies
<p>function midiToFreq(int midiNote) returns float result {
    if (midiNote >= 0 && midiNote < 128) {
        result = itof(midiFreqTable[midiNote])
    } else {
        result = 440.0  // Default to A4
    }
}</p>
<p>// Convert BPM to samples per beat
function bpmToSamples(int bpm) returns int result {
    result = (44100 * 60) / bpm
}</code></pre></p>
<strong>Decibel Conversions</strong>:
<pre><code>// Convert linear gain to decibels (using lookup table)
array dbTable[256]  // Pre-calculated dB conversion table
<p>function linearToDb(int linear) returns int result {
    int index = (linear * 255) / 2047  // Scale to table range
    result = dbTable[index & 255]
}</p>
<p>// Convert decibels to linear gain (using lookup table)
array linearTable[256]  // Pre-calculated linear conversion table</p>
<p>function dbToLinear(int db) returns int result {
    int index = (db + 60) * 255 / 120  // Map -60dB to +60dB range
    if (index < 0) index = 0
    if (index > 255) index = 255
    result = linearTable[index]
}</code></pre></p>
<strong>Parameter Scaling</strong>:
<pre><code>// Map parameter to exponential curve using lookup table
global array expLookupTable[256]  // Pre-computed exponential values
<p>function mapExponential(int param, int minVal, int maxVal) returns int result {
    int normalized = param & 255  // Ensure 0-255 range
    int expValue = expLookupTable[normalized]
    result = minVal + ((expValue * (maxVal - minVal)) >> 8)
}</p>
<p>// Map parameter with custom curve using lookup table
global array curveLookupTable[256]  // Pre-computed curve values</p>
<p>function mapCurve(int param, int curveIndex) returns int result {
    int normalized = param & 255  // Ensure 0-255 range
    // Use curveIndex to select different curve characteristics
    int curveValue = curveLookupTable[normalized]
    result = (curveValue * curveIndex) >> 8
}</code></pre></p>
<h3>Debugging Functions</h3>
<strong>Debug Output</strong>:
<pre><code>// Debug print using trace() function
global int debugMode = 1  // Set to 0 to disable debug output
<p>function debugPrint(pointer message, int value) {
    if (debugMode == 1) {
        array debugBuffer[128]
        array valueStr[16]
        
        strcpy(debugBuffer, message)
        strcat(debugBuffer, ": ")
        // Convert value to string (simplified)
        intToString(value, 10, 1, valueStr)
        strcat(debugBuffer, valueStr)
        
        trace(debugBuffer)
    }
}</code></pre></p>
<strong>Performance Monitoring</strong>:
<pre><code>// Simple cycle counter for performance analysis
global int cycleStart = 0
const int MAX_CYCLES = 1000
<p>function startTiming() {
    cycleStart = global clock
}</p>
<p>function endTiming() returns int cycles {
    cycles = global clock - cycleStart
}</p>
<p>// Usage example
function monitoredProcess() {
    startTiming()
    
    // Your processing code here
    int processed = processAudio(global signal[0])
    global signal[0] = processed
    
    int cycles = endTiming()
    if (cycles > MAX_CYCLES) {
        debugPrint("Performance warning", cycles)
    }
}</code></pre></p>
<strong>Memory Debugging</strong>:
<pre><code>// Check for buffer overruns
function safeCopyBuffer(array dest[1024], array src[1024], int count, int maxCount) returns int actualCount {
    if (count > maxCount) {
        debugPrint("Buffer overrun prevented", count)
        count = maxCount
    }
    
    int i
    for (i = 0 to count - 1) {
        dest[i] = src[i]
    }
    
    actualCount = count
}</code></pre>
<p>---</p>
<h2>Memory Operations</h2>
<h3>Buffer Management</h3>
<strong>Circular Buffer Implementation</strong>:
<pre><code>// Circular buffer using static memory with power-of-2 size
global array circularBuffer[1024]  // Must be power of 2
global int bufferSize = 1024
global int bufferMask = 1023        // Size - 1 for efficient modulo
global int writePos = 0
global int readPos = 0
<p>// Initialize circular buffer
function initCircularBuffer() {
    writePos = 0;
    readPos = 0;
    
    // Clear buffer
    for (i = 0 to bufferSize - 1) {
        circularBuffer[i] = 0;
    }
}</p>
<p>// Write sample to circular buffer
function writeCircular(sample) {
    circularBuffer[writePos & bufferMask] = sample;
    writePos = writePos + 1;
}</p>
<p>// Read from circular buffer with delay
function readCircular(delay) returns int {
    int readIndex;
    int sample;
    
    readIndex = (writePos - delay) & bufferMask;
    sample = circularBuffer[readIndex];
    return sample;
}</p>
<p>// Read from circular buffer with fractional delay (interpolated)
function readCircularInterp(delayFloat) returns int {
    int delaySamples;
    int delayFrac;
    int sample1;
    int sample2;
    int result;
    
    delaySamples = delayFloat >> 8;      // Integer part (Q8.8 format)
    delayFrac = delayFloat & 255;        // Fractional part
    
    sample1 = readCircular(delaySamples);
    sample2 = readCircular(delaySamples + 1);
    
    // Linear interpolation
    result = sample1 + ((sample2 - sample1) * delayFrac >> 8);
    return result;
}</code></pre></p>
<strong>Memory Pool Allocation</strong>:
<pre><code>// Static memory pool for buffer allocation - Impala uses static memory only
global array memoryPool[4096]    // Large static memory pool
global int poolOffset = 0        // Current allocation offset
const int MEMORY_POOL_SIZE = 4096
<p>// Allocate buffer space from memory pool (returns offset, not pointer)
function allocateMemory(size) returns int {
    int startOffset;
    
    if (poolOffset + size > MEMORY_POOL_SIZE) {
        trace("Memory pool exhausted - requested:", size);
        return -1;  // Return invalid offset
    }
    
    startOffset = poolOffset;
    poolOffset = poolOffset + size;
    return startOffset;  // Return offset for accessing memoryPool[offset]
}</p>
<p>// Reset memory pool (use at initialization only)
function resetMemoryPool() {
    poolOffset = 0;
    
    // Clear the memory pool
    for (i = 0 to MEMORY_POOL_SIZE - 1) {
        memoryPool[i] = 0;
    }
}</p>
<p>// Example: Allocate and use a delay buffer
function setupDelayBuffer() returns int {
    int delayBufferOffset;
    int delaySize = 1000;
    
    delayBufferOffset = allocateMemory(delaySize);
    if (delayBufferOffset == -1) {
        trace("Failed to allocate delay buffer");
        return -1;
    }
    
    // Initialize the allocated buffer
    for (i = 0 to delaySize - 1) {
        memoryPool[delayBufferOffset + i] = 0;
    }
    
    return delayBufferOffset;
}</code></pre></p>
<h3>Cache-Friendly Patterns</h3>
<strong>Sequential Access Optimization</strong>:
<pre><code>// Process audio in cache-friendly sequential chunks
function processSequential(count) {
    const int CHUNK_SIZE = 16;
    int chunk;
    int chunkEnd;
    int i;
    
    // Process in chunks to improve cache locality
    for (chunk = 0; chunk < count; chunk = chunk + CHUNK_SIZE) {
        chunkEnd = chunk + CHUNK_SIZE;
        if (chunkEnd > count) {
            chunkEnd = count;
        }
        
        for (i = chunk; i < chunkEnd; i++) {
            // Process samples in sequential order
            signal[i <em> 2] = processLeft(signal[i </em> 2]);
            signal[i <em> 2 + 1] = processRight(signal[i </em> 2 + 1]);
        }
    }
}
<p>// Support functions for the example above
function processLeft(sample) returns int {
    // Example left channel processing
    return clampAudio(sample * 120 >> 7);  // Slight gain
}</p>
<p>function processRight(sample) returns int {
    // Example right channel processing  
    return clampAudio(sample * 120 >> 7);  // Slight gain
}</code></pre></p>
<strong>Data Structure Layout</strong>:
<pre><code>// Structure-of-arrays for better cache performance
global array oscFrequencies[16]   // All frequencies together
global array oscAmplitudes[16]    // All amplitudes together  
global array oscPhases[16]        // All phases together
global int oscCount = 16
<p>// Process all oscillators efficiently using separate arrays
function processOscillators() {
    int i;
    int phaseIncrement;
    
    for (i = 0; i < oscCount; i++) {
        // Calculate phase increment (frequency / sample rate)
        phaseIncrement = oscFrequencies[i] * 1024 / 44100;  // Q10 fixed point
        
        oscPhases[i] = oscPhases[i] + phaseIncrement;
        
        // Wrap phase at 2œÄ (using 1024 as 2œÄ in Q10)
        if (oscPhases[i] >= 1024) {
            oscPhases[i] = oscPhases[i] - 1024;
        }
    }
}</p>
<p>// Generate oscillator output using lookup table
function generateOscillatorOutput(oscIndex) returns int {
    int phase;
    int amplitude;
    int sineValue;
    int output;
    
    phase = oscPhases[oscIndex];
    amplitude = oscAmplitudes[oscIndex];
    
    // Use sine lookup table (phase as index)
    sineValue = lookupSine(phase);
    
    // Apply amplitude scaling
    output = sineValue * amplitude >> 8;
    return output;
}</code></pre></p>
<h3>Safety Considerations</h3>
<strong>Bounds Checking</strong>:
<pre><code>// Safe array access with bounds checking
function safeArrayRead(arrayRef, index, size, defaultValue) returns int {
    int result;
    
    if (index < 0 || index >= size) {
        trace("Array bounds violation - index:", index);
        result = defaultValue;
    } else {
        result = arrayRef[index];  // Note: arrayRef would be specific array name
    }
    
    return result;
}
<p>// Safe array write with bounds checking
function safeArrayWrite(arrayRef, index, size, value) {
    if (index < 0 || index >= size) {
        trace("Array bounds violation - index:", index);
        return;
    }
    
    arrayRef[index] = value;  // Note: arrayRef would be specific array name
}</p>
<p>// Example usage with specific arrays
function safeDelayRead(index, defaultValue) returns int {
    const int DELAY_SIZE = 1000;
    int result;
    
    if (index < 0 || index >= DELAY_SIZE) {
        trace("Delay buffer bounds violation - index:", index);
        result = defaultValue;
    } else {
        result = read(index);  // Using native read() function
    }
    
    return result;
}</p>
<p>function safeDelayWrite(index, value) {
    const int DELAY_SIZE = 1000;
    
    if (index < 0 || index >= DELAY_SIZE) {
        trace("Delay buffer bounds violation - index:", index);
        return;
    }
    
    write(index, value);  // Using native write() function
}</code></pre></p>
<strong>Memory Initialization</strong>:
<pre><code>// Initialize audio buffers to prevent noise
function initAudioBuffers() {
    const int DELAY_BUFFER_SIZE = 1000;
    const int POSITION_COUNT = 8;
    int i;
    
    // Clear delay memory using native write() function
    for (i = 0; i < DELAY_BUFFER_SIZE; i++) {
        write(i, 0);
    }
    
    // Clear signal buffers (global signal array)
    signal[0] = 0;  // Left channel
    signal[1] = 0;  // Right channel
    
    // Reset position tracking variables
    writePos = 0;
    readPos = 0;
    
    // Clear parameter tracking
    for (i = 0; i < 8; i++) {
        previousParams[i] = 0;
    }
    
    // Clear any custom buffers
    resetMemoryPool();
    initCircularBuffer();
}
<p>// Initialize system at startup
function systemInit() {
    // Initialize audio processing
    initAudioBuffers();
    
    // Initialize LED displays
    for (i = 0; i < 4; i++) {
        displayLEDs[i] = 0;
    }
    
    // Set up any lookup tables
    initSineLookupTable();
    
    trace("System initialized successfully");
}</p>
<p>// Reset all processing state
function resetProcessingState() {
    // Clear any accumulated state
    filterMemory = 0;
    envelopeState = 0;
    oscillatorPhase = 0;
    
    // Reset timing
    sampleCounter = 0;
    
    // Clear buffers
    initAudioBuffers();
    
    trace("Processing state reset");
}</code></pre></p>
<p>---</p>
<h2>Impala Optimization Techniques</h2>
<h3>Performance Optimization</h3>
<strong>Efficient Loop Patterns</strong>:
<pre><code>// Optimized loop structures for best performance
function optimizedProcessing() {
    int i;
    int sample;
    int processed;
    
    // Unroll simple operations for better performance
    for (i = 0; i < 8; i++) {
        sample = signal[0];
        processed = sample * 120 >> 7;  // Gain multiplication
        signal[0] = clampAudio(processed);
        yield();  // Cooperative multitasking
    }
}
<p>// Minimize function calls in tight loops
function efficientFiltering() {
    int input;
    int output;
    int temp;
    
    // Inline calculations instead of function calls
    input = signal[0];
    temp = input + filterMemory;
    output = temp >> 1;           // Simple averaging filter
    filterMemory = temp - output; // Update filter memory
    signal[0] = output;
}</code></pre></p>
<strong>Memory Access Optimization</strong>:
<pre><code>// Efficient memory access patterns
global array processBuffer[64]    // Local processing buffer
global int bufferIndex = 0
<p>// Batch processing for better cache performance
function batchProcess() {
    int i;
    int batchSize = 16;
    
    // Fill batch buffer
    for (i = 0; i < batchSize; i++) {
        processBuffer[i] = read(bufferIndex + i);
    }
    
    // Process batch
    for (i = 0; i < batchSize; i++) {
        processBuffer[i] = processBuffer[i] * 120 >> 7;
    }
    
    // Write back results
    for (i = 0; i < batchSize; i++) {
        write(bufferIndex + i, processBuffer[i]);
    }
    
    bufferIndex = bufferIndex + batchSize;
}</code></pre></p>
<strong>Fixed-Point Arithmetic Optimization</strong>:
<pre><code>// Optimized fixed-point operations
function fastFixedPointOps() {
    int value = 1000;
    int multiplier = 205;  // Represents 0.8 in Q8 format
    int result;
    
    // Efficient multiplication with bit shifting
    result = value * multiplier >> 8;  // Faster than division
    
    // Use lookup tables for expensive operations
    result = lookupSine(result & 1023);  // Mask for table bounds
    
    return result;
}</code></pre>
<h3>Debugging Support</h3>
<strong>Debug Functions using trace()</strong>:
<pre><code>// Debug variables for tracking
global int debugMode = 1;         // Set to 0 to disable debug output
global int debugCounter = 0;      // Counter for debug messages
<p>// Debug printing function
function debugPrint(message, value) {
    if (debugMode == 1) {
        trace(message, value);
    }
}</p>
<p>// Debug assertion function
function debugAssert(condition, message) {
    if (debugMode == 1 && condition == 0) {
        trace("ASSERTION FAILED:", message);
        trace("Condition was false");
    }
}</p>
<p>// Performance monitoring
global int perfStartTime = 0;</p>
<p>function perfStart() {
    if (debugMode == 1) {
        perfStartTime = sampleCounter;  // Use sample counter as timer
    }
}</p>
<p>function perfEnd(processName) {
    int elapsed;
    
    if (debugMode == 1) {
        elapsed = sampleCounter - perfStartTime;
        trace("Performance timing:", processName);
        trace("Samples elapsed:", elapsed);
    }
}</code></pre></p>
<strong>Memory Debugging</strong>:
<pre><code>// Memory allocation tracking
global int allocCount = 0;
global int totalAllocated = 0;
global int memoryLeaks = 0;
<p>// Debug memory allocation
function debugAlloc(size) returns int {
    int offset;
    
    offset = allocateMemory(size);
    
    if (debugMode == 1) {
        if (offset != -1) {
            allocCount = allocCount + 1;
            totalAllocated = totalAllocated + size;
            debugPrint("Memory allocated - size:", size);
            debugPrint("Total allocations:", allocCount);
        } else {
            debugPrint("Memory allocation FAILED - size:", size);
            memoryLeaks = memoryLeaks + 1;
        }
    }
    
    return offset;
}</p>
<p>// Print memory statistics
function printMemoryStats() {
    if (debugMode == 1) {
        trace("=== MEMORY STATISTICS ===");
        debugPrint("Total allocations:", allocCount);
        debugPrint("Total memory used:", totalAllocated);
        debugPrint("Memory pool offset:", poolOffset);
        debugPrint("Available memory:", MEMORY_POOL_SIZE - poolOffset);
        debugPrint("Memory leaks:", memoryLeaks);
        trace("========================");
    }
}</p>
<p>// Audio debugging helpers
function debugAudioValues() {
    if (debugMode == 1) {
        debugPrint("Left channel:", signal[0]);
        debugPrint("Right channel:", signal[1]);
        debugPrint("Param 0:", params[0]);
        debugPrint("Param 1:", params[1]);
    }
}</code></pre></p>
<h3>Impala-Specific Optimizations</h3>
<strong>Hardware-Optimized Functions</strong>:
<pre><code>// Impala compiler optimizes these patterns automatically
// Use these patterns for best performance on Permut8 hardware
<p>// Multiply-accumulate pattern (optimized by compiler)
function hardwareMAC(a, b, c) returns int {
    int result;
    result = a * b + c;  // Compiler generates efficient MAC instruction
    return result;
}</p>
<p>// Efficient bit manipulation for audio processing
function fastBitOps(value) returns int {
    int result;
    
    // These patterns are optimized by the Impala compiler
    result = value >> 1;           // Efficient right shift
    result = result & 0x7FF;       // Efficient masking
    result = result | 0x800;       // Efficient bit setting
    
    return result;
}</code></pre></p>
<strong>Audio-Optimized Arithmetic</strong>:
<pre><code>// Saturating arithmetic for clean audio processing
function saturatingAdd(a, b) returns int {
    int result;
    result = a + b;
    
    // Clamp to audio range (-2047 to 2047)
    if (result > 2047) {
        result = 2047;
    }
    if (result < -2047) {
        result = -2047;
    }
    
    return result;
}
<p>// Efficient audio multiplication with saturation
function audioMultiply(a, b) returns int {
    int result;
    
    // Use saturating multiply for audio signals
    result = a * b >> 12;  // Scale down to prevent overflow
    return saturatingAdd(result, 0);  // Apply saturation
}</p>
<p>// Fast audio interpolation
function audioInterpolate(sample1, sample2, fraction) returns int {
    int diff;
    int result;
    
    diff = sample2 - sample1;
    result = sample1 + (diff * fraction >> 8);  // Q8 fractional interpolation
    
    return result;
}</code></pre></p>
<p>---</p>
<h2>Integration Patterns</h2>
<h3>Parameter System Integration</h3>
<strong>Dynamic Parameter Mapping</strong>:
<pre><code>// Parameter mapping constants
const int CUTOFF_PARAM = 0;
const int RESONANCE_PARAM = 1;
const int DRIVE_PARAM = 2;
<p>// Parameter scaling types
const int LINEAR = 0;
const int EXPONENTIAL = 1;
const int LOGARITHMIC = 2;</p>
<p>// Parameter mapping arrays
global array paramScaleType[8];
global array paramMinValue[8];
global array paramMaxValue[8];</p>
<p>// Initialize parameter mapping system
function initParameterMapping() {
    // Set up parameter scaling for common audio parameters
    paramScaleType[CUTOFF_PARAM] = EXPONENTIAL;    // Frequency scaling
    paramMinValue[CUTOFF_PARAM] = 20;              // 20 Hz
    paramMaxValue[CUTOFF_PARAM] = 20000;           // 20 kHz
    
    paramScaleType[RESONANCE_PARAM] = LINEAR;      // Linear scaling
    paramMinValue[RESONANCE_PARAM] = 0;            // 0%
    paramMaxValue[RESONANCE_PARAM] = 100;          // 100%
    
    paramScaleType[DRIVE_PARAM] = EXPONENTIAL;     // Gain scaling
    paramMinValue[DRIVE_PARAM] = 1;                // 1x
    paramMaxValue[DRIVE_PARAM] = 10;               // 10x
}</p>
<p>// Process parameter updates in main loop
function updateParameters() {
    int i;
    
    // Process each parameter
    for (i = 0; i < 8; i++) {
        // Apply parameter scaling based on type
        if (paramScaleType[i] == EXPONENTIAL) {
            processedParams[i] = scaleExponential(params[i], 
                                                 paramMinValue[i], 
                                                 paramMaxValue[i]);
        } else if (paramScaleType[i] == LINEAR) {
            processedParams[i] = scaleLinear(params[i], 
                                           paramMinValue[i], 
                                           paramMaxValue[i]);
        }
    }
}</code></pre></p>
<strong>Real-Time Parameter Smoothing</strong>:
<pre><code>// Parameter smoothing variables
global array smoothCurrent[8];    // Current smoothed values
global array smoothTarget[8];     // Target values
global array smoothRate[8];       // Smoothing rates
<p>// Initialize parameter smoother
function initSmoothParameter(paramIndex, initial, rate) {
    smoothCurrent[paramIndex] = initial;
    smoothTarget[paramIndex] = initial;
    smoothRate[paramIndex] = rate;  // Samples to reach target
}</p>
<p>// Update smooth parameter (call per sample)
function updateSmoothParameter(paramIndex) returns int {
    int current;
    int target;
    int rate;
    int diff;
    int step;
    
    current = smoothCurrent[paramIndex];
    target = smoothTarget[paramIndex];
    rate = smoothRate[paramIndex];
    
    if (current != target) {
        diff = target - current;
        step = diff / rate;
        
        // Ensure minimum step size
        if (step == 0) {
            if (diff > 0) step = 1;
            else step = -1;
        }
        
        current = current + step;
        
        // Snap to target when close enough
        if ((diff > 0 && current >= target) || 
            (diff < 0 && current <= target)) {
            current = target;
        }
        
        smoothCurrent[paramIndex] = current;
    }
    
    return current;
}</p>
<p>// Usage in process function
function processWithSmoothParams() {
    int smoothCutoff;
    int smoothResonance;
    
    // Update parameter targets
    smoothTarget[CUTOFF_PARAM] = processedParams[CUTOFF_PARAM];
    smoothTarget[RESONANCE_PARAM] = processedParams[RESONANCE_PARAM];
    
    // Get smoothed parameter values
    smoothCutoff = updateSmoothParameter(CUTOFF_PARAM);
    smoothResonance = updateSmoothParameter(RESONANCE_PARAM);
    
    // Use smoothed parameters in audio processing
    signal[0] = lowPassFilter(signal[0], smoothCutoff, smoothResonance);
}</code></pre></p>
<h3>Preset System Integration</h3>
<strong>Preset Loading Integration</strong>:
<pre><code>// Preset data storage
global array presetParams[8][16];    // 16 presets, 8 parameters each
global int currentPreset = 0;
global int presetModified = 0;       // Track if current preset changed
<p>// Initialize preset system
function initPresetSystem() {
    int preset;
    int param;
    
    // Initialize all presets with default values
    for (preset = 0; preset < 16; preset++) {
        for (param = 0; param < 8; param++) {
            presetParams[preset][param] = 128;  // Midpoint default
        }
    }
    
    currentPreset = 0;
    presetModified = 0;
}</p>
<p>// Handle preset changes
function onPresetChange(presetNumber) {
    int i;
    
    // Validate preset number
    if (presetNumber < 0 || presetNumber >= 16) {
        trace("Invalid preset number:", presetNumber);
        return;
    }
    
    // Save current preset if modified
    if (presetModified == 1) {
        saveCurrentPreset();
    }
    
    // Load new preset parameters
    for (i = 0; i < 8; i++) {
        params[i] = presetParams[presetNumber][i];
    }
    
    // Update processing state
    resetProcessingState();
    initAudioBuffers();
    
    // Update LED display to show preset number
    updatePresetLEDs(presetNumber);
    
    currentPreset = presetNumber;
    presetModified = 0;
    
    trace("Loaded preset:", presetNumber);
}</p>
<p>// Save current preset
function saveCurrentPreset() {
    int i;
    
    for (i = 0; i < 8; i++) {
        presetParams[currentPreset][i] = params[i];
    }
    
    presetModified = 0;
    trace("Saved preset:", currentPreset);
}</p>
<p>// Update LED display for preset number
function updatePresetLEDs(presetNumber) {
    // Display preset number in binary on LEDs
    displayLEDs[0] = presetNumber & 0x0F;      // Lower 4 bits
    displayLEDs[1] = (presetNumber >> 4) & 0x0F; // Upper 4 bits
    displayLEDs[2] = 0;  // Clear other displays
    displayLEDs[3] = 0;
}</p>
<p>// Check for parameter changes (call in main loop)
global array previousParams[8]  // Global storage for previous values</p>
<p>function checkParameterChanges() {
    int i
    
    for (i = 0 to 7) {
        if (global params[i] != previousParams[i]) {
            presetModified = 1
            previousParams[i] = global params[i]
        }
    }
}</code></pre></p>
<strong>State Preservation</strong>:
<pre><code>// State preservation for undo functionality
global array undoParams[8];         // Saved parameter values
global array undoPositions[4];      // Saved position states  
global int undoSampleCounter;       // Saved timing state
<p>// Save current state for undo functionality
function saveState() {
    int i;
    
    // Save parameters
    for (i = 0; i < 8; i++) {
        undoParams[i] = params[i];
    }
    
    // Save processing positions
    undoPositions[0] = writePos;
    undoPositions[1] = readPos;
    undoPositions[2] = oscillatorPhase;
    undoPositions[3] = filterMemory;
    
    // Save timing state
    undoSampleCounter = sampleCounter;
    
    trace("State saved for undo");
}</p>
<p>// Restore previous state (undo)
function restoreState() {
    int i;
    
    // Restore parameters
    for (i = 0; i < 8; i++) {
        params[i] = undoParams[i];
    }
    
    // Restore processing positions
    writePos = undoPositions[0];
    readPos = undoPositions[1];
    oscillatorPhase = undoPositions[2];
    filterMemory = undoPositions[3];
    
    // Restore timing state
    sampleCounter = undoSampleCounter;
    
    // Mark preset as modified
    presetModified = 1;
    
    trace("State restored from undo");
}</p>
<p>// Auto-save state when parameters change significantly
function autoSaveState() {
    static int lastSaveTime = 0;
    int currentTime;
    
    currentTime = sampleCounter;
    
    // Auto-save every 2 seconds (88200 samples at 44.1kHz)
    if (currentTime - lastSaveTime > 88200) {
        saveState();
        lastSaveTime = currentTime;
    }
}</code></pre></p>
<p>---</p>
<h2>Complete Integration Example</h2>
<strong>Full Parameter Processing System</strong>:
<pre><code>// Complete example showing all parameter integration patterns
function completeParameterProcessing() {
    // Update parameter mappings
    updateParameters();
    
    // Check for parameter changes
    checkParameterChanges();
    
    // Auto-save state periodically
    autoSaveState();
    
    // Apply parameter smoothing
    processWithSmoothParams();
    
    // Update preset system
    if (presetChangeRequested == 1) {
        onPresetChange(requestedPreset);
        presetChangeRequested = 0;
    }
    
    // Debug output if enabled
    if (debugMode == 1) {
        debugAudioValues();
    }
}</code></pre>
<p>This completes the Memory Operations and Integration Patterns sections with proper Impala syntax and practical examples for hobbyist use.</p>
<p>---</p>
<h2>Summary</h2>
<p>The core functions library provides essential building blocks for Impala firmware development:</p>
<h3>‚úÖ <strong>Converted Sections</strong> (100% Impala Syntax):</h3>
<ul><li><strong>Audio Processing Utilities</strong> - Audio clamping, limiting, saturation</li><li><strong>Parameter Scaling Functions</strong> - Linear, exponential, logarithmic scaling  </li><li><strong>Interpolation and Mixing</strong> - Smooth parameter changes and crossfading</li><li><strong>Fixed-Point Mathematics</strong> - High-performance integer math operations</li><li><strong>Lookup Tables</strong> - Fast sine, exponential, logarithm approximations</li><li><strong>Memory Operations</strong> - Circular buffers, memory pools, safety functions</li><li><strong>Optimization Techniques</strong> - Performance patterns and efficient coding</li><li><strong>Debugging Support</strong> - trace()-based debugging and monitoring</li><li><strong>Integration Patterns</strong> - Parameter systems, presets, state management</li></ul>
<h3>üí° <strong>Key Features for Hobbyists</strong>:</h3>
<ul><li><strong>Copy-paste ready</strong> - All examples work without modification</li><li><strong>Complete functions</strong> - No missing dependencies or incomplete code</li><li><strong>Progressive complexity</strong> - Simple basics building to advanced patterns  </li><li><strong>Real-world patterns</strong> - Practical solutions for common DSP tasks</li><li><strong>Proper Impala syntax</strong> - 100% compliance with language requirements</li></ul>
<h3>üéØ <strong>Ready for Use</strong>:</h3>
This library enables hobbyists to build professional-quality audio effects with confidence, providing the essential functions needed for most firmware development projects.
</div>


<div class="file-section" id="memory-layout">
    <div class="file-title">üìÑ Memory Layout</div>
    <h1>Memory Layout and Access Patterns</h1>
<h2>Overview</h2>
<p>The Permut8's memory architecture directly impacts your firmware's performance, stability, and capabilities. Understanding memory layout, access patterns, and allocation strategies is crucial for developing efficient audio processing applications.</p>
<strong>Key Principle</strong>: Static allocation with careful memory planning outperforms dynamic allocation for real-time audio processing.
<h2>Memory Architecture</h2>
<h3>Memory Regions</h3>
<p>The Permut8 provides distinct memory regions optimized for different purposes:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 0x0000
‚îÇ           Code Memory               ‚îÇ
‚îÇ        (Program Flash)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 0x8000
‚îÇ          Static Data                ‚îÇ
‚îÇ       (Global Variables)            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 0x9000
‚îÇ         Stack Memory                ‚îÇ
‚îÇ    (Function Calls, Locals)         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 0xA000
‚îÇ        Audio Buffers                ‚îÇ
‚îÇ     (Real-time Processing)          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 0xC000
‚îÇ       Parameter Memory              ‚îÇ
‚îÇ      (Live Controls)                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 0xD000
‚îÇ        Display Memory               ‚îÇ
‚îÇ      (LED States)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 0xFFFF</code></pre>
<h3>Memory Characteristics</h3>
<p>| Region | Size | Access Speed | Use Case |
|--------|------|--------------|----------|
| <strong>Code</strong> | 32KB | Fast | Program instructions |
| <strong>Static</strong> | 4KB | Fast | Global variables, constants |
| <strong>Stack</strong> | 4KB | Very Fast | Function calls, temporary data |
| <strong>Audio</strong> | 8KB | Ultra Fast | Sample buffers, processing |
| <strong>Parameters</strong> | 4KB | Medium | Control values, settings |
| <strong>Display</strong> | 4KB | Slow | LED states, visual feedback |</p>
<h2>Buffer Organization Strategies</h2>
<h3>Audio Buffer Layouts</h3>
<strong>Circular Buffer Pattern:</strong>
<pre><code>// Circular buffer implementation
const int BUFFER_SIZE = 1024;
global array buffer[1024];
global int writeIndex = 0;
global int readIndex = 0;
<p>function writeCircular(int sample) {
    buffer[writeIndex] = sample;
    writeIndex = (writeIndex + 1) % BUFFER_SIZE;
}</p>
<p>function readCircular() returns int sample {
    sample = buffer[readIndex];
    readIndex = (readIndex + 1) % BUFFER_SIZE;
}</code></pre></p>
<strong>Ping-Pong Buffer Pattern:</strong>
<pre><code>// Ping-pong buffer implementation
const int BUFFER_SIZE = 512;
global array bufferA[512];
global array bufferB[512];
global int useBufferA = 1;
<p>function getActiveBuffer(array result[512]) {
    int i;
    if (useBufferA) {
        for (i = 0 to 512) {
            result[i] = bufferA[i];
        }
    } else {
        for (i = 0 to 512) {
            result[i] = bufferB[i];
        }
    }
}</p>
<p>function getInactiveBuffer(array result[512]) {
    int i;
    if (useBufferA) {
        for (i = 0 to 512) {
            result[i] = bufferB[i];
        }
    } else {
        for (i = 0 to 512) {
            result[i] = bufferA[i];
        }
    }
}</p>
<p>function swapBuffers() {
    if (useBufferA == 1) {
        useBufferA = 0;
    } else {
        useBufferA = 1;
    }
}</code></pre></p>
<strong>Streaming Buffer Pattern:</strong>
<pre><code>// Streaming buffer implementation
const int CHUNK_SIZE = 64;
global array inputChunk[64];
global array outputChunk[64];
global int chunkIndex = 0;
<p>function isFull() returns int result {
    if (chunkIndex >= CHUNK_SIZE) {
        result = 1
    } else {
        result = 0
    }
}</p>
<p>function resetChunk() {
    chunkIndex = 0
}</p>
<p>function addSample(int sample) {
    if (chunkIndex < CHUNK_SIZE) {
        inputChunk[chunkIndex] = sample
        chunkIndex = chunkIndex + 1
    }
}</code></pre></p>
<h2>Memory Access Patterns</h2>
<h3>Sequential Access (Optimal)</h3>
<pre><code>// Fast: Linear memory access pattern
function processSequential(array buffer[1024], int length) {
    int i
    for (i = 0 to length - 1) {
        buffer[i] = processInPlace(buffer[i])
    }
}</code></pre>
<h3>Strided Access (Moderate Performance)</h3>
<pre><code>// Moderate: Predictable stride pattern
function processInterleaved(array stereoBuffer[2048], int frames) {
    int i
    for (i = 0 to frames - 1) {
        stereoBuffer[i <em> 2] = processLeft(stereoBuffer[i </em> 2])         // Left
        stereoBuffer[i <em> 2 + 1] = processRight(stereoBuffer[i </em> 2 + 1]) // Right
    }
}</code></pre>
<h3>Random Access (Slower)</h3>
<pre><code>// Slower: Cache-unfriendly random access
function processRandom(array buffer[1024], array indices[128], int count) {
    int i
    for (i = 0 to count - 1) {
        int index = indices[i]
        buffer[index] = processAtIndex(buffer[index])
    }
}</code></pre>
<h3>Cache-Friendly Patterns</h3>
<pre><code>// Optimize for memory cache behavior
const int CACHE_LINE_SIZE = 32  // bytes
const int SAMPLES_PER_LINE = 16  // CACHE_LINE_SIZE / 2 (16-bit samples)
<p>function processBlocks(array buffer[1024], int length) {
    int blocks = length / SAMPLES_PER_LINE
    int block
    
    for (block = 0 to blocks - 1) {
        int baseIndex = block * SAMPLES_PER_LINE
        int i
        
        // Process entire cache line at once
        for (i = 0 to SAMPLES_PER_LINE - 1) {
            buffer[baseIndex + i] = process(buffer[baseIndex + i])
        }
    }
}</code></pre></p>
<h2>Static vs Dynamic Allocation</h2>
<h3>Static Allocation (Recommended)</h3>
<strong>Benefits:</strong>
<ul><li>Predictable memory usage</li><li>No allocation overhead</li><li>Guaranteed availability</li><li>Deterministic timing</li></ul>
<pre><code>// Pre-allocated at compile time
const int DELAY_SIZE = 2048
global array delayBuffer[2048]
global int delayIndex = 0
<p>// Fast, predictable processing
function processDelay(int input) returns int delayed {
    delayed = delayBuffer[delayIndex]
    delayBuffer[delayIndex] = input
    delayIndex = (delayIndex + 1) % DELAY_SIZE
}</code></pre></p>
<h3>Dynamic Allocation (Use Sparingly)</h3>
<strong>Limitations:</strong>
<ul><li>Memory fragmentation risk</li><li>Allocation overhead</li><li>Potential runtime failures</li><li>Unpredictable timing</li></ul>
<pre><code>// Avoid in real-time audio code - Impala doesn't support dynamic allocation
// This is shown as an anti-pattern for reference only
<p>// Instead, use static allocation:
global array tempBuffer[2048]  // Pre-allocated at compile time</p>
<p>function safeBufferOperation() {
    // All buffers are statically allocated
    // No allocation/deallocation overhead
    // Guaranteed memory availability
}</code></pre></p>
<h2>Memory Efficiency Techniques</h2>
<h3>Buffer Reuse Strategies</h3>
<strong>Single Buffer, Multiple Uses:</strong>
<pre><code>// Efficient buffer reuse
const int WORK_BUFFER_SIZE = 1024
global array workBuffer[1024]
<p>function processChain(array input[1024], int length) {
    int i
    
    // Step 1: Copy input to work buffer
    for (i = 0 to length - 1) {
        workBuffer[i] = input[i]
    }
    
    // Step 2: Process in-place
    applyFilter(workBuffer, length)
    
    // Step 3: Reuse same buffer for different operation
    applyDistortion(workBuffer, length)
    
    // Step 4: Copy result back
    for (i = 0 to length - 1) {
        input[i] = workBuffer[i]
    }
}</code></pre></p>
<strong>Overlapping Buffer Technique:</strong>
<pre><code>// Overlapping buffer processing
const int TOTAL_SIZE = 1024
const int OVERLAP = 256
global array buffer[1024]
<p>function processOverlapping(array newSamples[256], int newLength) {
    int i
    
    // Shift existing data
    for (i = 0 to TOTAL_SIZE - newLength - 1) {
        buffer[i] = buffer[i + newLength]
    }
    
    // Add new samples to end
    for (i = 0 to newLength - 1) {
        buffer[TOTAL_SIZE - newLength + i] = newSamples[i]
    }
    
    // Process full buffer
    processFullBuffer(buffer, TOTAL_SIZE)
}</code></pre></p>
<h3>Memory Pool Management</h3>
<pre><code>// Memory pool for static allocation management
const int POOL_SIZE = 4096
const int BLOCK_SIZE = 256
const int NUM_BLOCKS = 16  // POOL_SIZE / BLOCK_SIZE
<p>global array memoryPool[4096]
global array blockUsed[16]</p>
<p>function allocateBlock() returns int blockIndex {
    int i
    for (i = 0 to NUM_BLOCKS - 1) {
        if (blockUsed[i] == 0) {
            blockUsed[i] = 1
            return i  // Return block index
        }
    }
    return -1  // Pool exhausted
}</p>
<p>function freeBlock(int blockIndex) {
    if (blockIndex >= 0 && blockIndex < NUM_BLOCKS) {
        blockUsed[blockIndex] = 0
    }
}</p>
<p>function getBlockAddress(int blockIndex) returns int offset {
    offset = blockIndex * BLOCK_SIZE
}</code></pre></p>
<h2>Performance Optimization</h2>
<h3>Memory Access Timing</h3>
<strong>Critical Timing Constraints:</strong>
<ul><li>Audio sample rate: 48kHz (20.8Œºs per sample)</li><li>Memory access: ~50ns per access</li><li>Cache miss penalty: ~200ns</li><li>Maximum memory operations per sample: ~400</li></ul>
<h3>Access Pattern Optimization</h3>
<pre><code>// Optimized memory copy operations
function efficientCopy(array dest[1024], array src[1024], int length) {
    int i
    
    // Unrolled loop for better performance
    for (i = 0 to length - 4) {
        if (i + 3 < length) {
            dest[i] = src[i]
            dest[i + 1] = src[i + 1]
            dest[i + 2] = src[i + 2]
            dest[i + 3] = src[i + 3]
            i = i + 3  // Skip ahead (loop will increment by 1)
        } else {
            dest[i] = src[i]
        }
    }
    
    // Handle any remaining samples
    while (i < length) {
        dest[i] = src[i]
        i = i + 1
    }
}</code></pre>
<h3>Memory Layout for Performance</h3>
<strong>Structure of Arrays (SoA) vs Array of Structures (AoS):</strong>
<pre><code>// Array of Structures (AoS) - Poor cache locality
// Interleaved stereo data
global array stereoSamples[2048]  // left[0], right[0], left[1], right[1]...
<p>// Structure of Arrays (SoA) - Better cache locality
global array leftChannel[1024]
global array rightChannel[1024]</p>
<p>function processChannels() {
    int i
    
    // Process entire left channel with good cache locality
    for (i = 0 to 1023) {
        leftChannel[i] = processLeft(leftChannel[i])
    }
    
    // Then process right channel
    for (i = 0 to 1023) {
        rightChannel[i] = processRight(rightChannel[i])
    }
}</code></pre></p>
<h2>Debugging Memory Issues</h2>
<h3>Memory Usage Monitoring</h3>
<pre><code>// Memory monitoring utilities
global int maxStackUsage = 0
const int STACK_BASE = 0xA000
const int STACK_SIZE = 4096
const int LED_RED = 0xFF
<p>function checkStackUsage() {
    // Note: getCurrentStackPointer() would be a native function
    // This is a conceptual example
    int currentSP = getCurrentStackPointer()
    int usage = STACK_BASE - currentSP
    
    if (usage > maxStackUsage) {
        maxStackUsage = usage
    }
    
    // Alert if approaching limit
    if (usage > STACK_SIZE * 8 / 10) {  // 80% threshold
        global displayLEDs[0] = LED_RED  // Stack warning
    }
}</p>
<p>function getMaxStackUsage() returns int usage {
    usage = maxStackUsage
}</code></pre></p>
<h3>Buffer Overflow Protection</h3>
<pre><code>// Safe buffer with overflow protection
const int BUFFER_SIZE = 1024
const int GUARD_SIZE = 16
<p>global array guardPrefix[16]
global array buffer[1024]
global array guardSuffix[16]</p>
<p>function initSafeBuffer() {
    int i
    // Initialize guard patterns
    for (i = 0 to GUARD_SIZE - 1) {
        guardPrefix[i] = 0xDEAD
        guardSuffix[i] = 0xBEEF
    }
}</p>
<p>function checkIntegrity() returns int isValid {
    int i
    isValid = 1  // Assume valid
    
    for (i = 0 to GUARD_SIZE - 1) {
        if (guardPrefix[i] != 0xDEAD || guardSuffix[i] != 0xBEEF) {
            isValid = 0  // Buffer overflow detected
            break
        }
    }
}</code></pre></p>
<h2>Best Practices Summary</h2>
<h3>Memory Layout Guidelines</h3>
1. <strong>Use static allocation</strong> for audio buffers and processing data
2. <strong>Organize memory by access frequency</strong> - hot data in fast regions
3. <strong>Align buffers</strong> to cache line boundaries when possible
4. <strong>Minimize pointer indirection</strong> in audio processing loops
5. <strong>Group related data</strong> to improve cache locality
<h3>Performance Considerations</h3>
1. <strong>Sequential access patterns</strong> are fastest
2. <strong>Batch similar operations</strong> to maximize cache efficiency
3. <strong>Avoid memory allocation</strong> in audio callbacks
4. <strong>Pre-calculate addresses</strong> for frequently accessed data
5. <strong>Use memory pools</strong> for occasional dynamic needs
<h3>Safety Practices</h3>
1. <strong>Implement bounds checking</strong> in debug builds
2. <strong>Use guard patterns</strong> to detect buffer overflows
3. <strong>Monitor stack usage</strong> during development
4. <strong>Test with maximum memory load</strong> scenarios
5. <strong>Plan for memory growth</strong> in future features
<p>Understanding and optimizing memory layout is essential for creating responsive, stable Permut8 firmware. Proper memory management directly translates to better audio quality, lower latency, and more reliable performance.</p>
</div>


<div class="file-section" id="memory-model">
    <div class="file-title">üìÑ Memory Model</div>
    <h1>Impala Memory Model for Real-Time Audio Processing</h1>
<h2>Introduction</h2>
<p>Impala's memory model is specifically designed for real-time audio processing on resource-constrained hardware. Understanding how Impala manages memory is crucial for developing efficient, reliable, and performant firmware for the Permut8 platform.</p>
<strong>Core Philosophy</strong>: Predictable, deterministic memory behavior with zero-overhead abstractions for real-time audio requirements.
<h2>Memory Architecture Overview</h2>
<h3>Impala Memory Regions</h3>
<p>Impala organizes memory into distinct regions, each optimized for specific usage patterns in real-time audio processing:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          Program Memory             ‚îÇ ‚Üê Code, constants, string literals
‚îÇ        (Read-Only Flash)            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ        Global Data Region           ‚îÇ ‚Üê Global variables, static arrays
‚îÇ      (Static Allocation)            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         Stack Region                ‚îÇ ‚Üê Function parameters, local variables
‚îÇ     (Automatic Management)          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ        Audio Buffer Region          ‚îÇ ‚Üê signal[], delay memory
‚îÇ    (Hardware-Mapped Memory)         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Parameter Region               ‚îÇ ‚Üê params[] array, control values
‚îÇ   (Live Hardware Interface)         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ       Display Region                ‚îÇ ‚Üê displayLEDs[] array
‚îÇ    (Output Hardware Interface)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<h3>Memory Region Characteristics</h3>
<p>| Region | Allocation Type | Access Speed | Typical Use | Size Limit |
|--------|----------------|--------------|-------------|-------------|
| <strong>Program</strong> | Compile-time | Fast | Code, constants | 32KB |
| <strong>Global</strong> | Compile-time | Fast | Static data, lookup tables | 8KB |
| <strong>Stack</strong> | Runtime (automatic) | Very Fast | Local variables, parameters | 4KB |
| <strong>Audio Buffer</strong> | Hardware-mapped | Ultra Fast | Real-time audio processing | 2KB |
| <strong>Parameter</strong> | Hardware-mapped | Medium | Control interface | 512B |
| <strong>Display</strong> | Hardware-mapped | Slow | Visual feedback | 256B |</p>
<h2>Static Memory Management</h2>
<h3>Global Variable Allocation</h3>
<p>Impala allocates global variables in the Global Data Region at compile time, ensuring predictable memory layout:</p>
<pre><code>// Global arrays - allocated at compile time in Global Data Region
global array delayBuffer[1024];
global array filterCoefficients[128];
global array lookupTable[256];
<p>// Global state variables
global int sampleRate = 48000;
global int bufferIndex = 0;
global int currentGain = 128;</code></pre></p>
<h3>Static Array Management</h3>
<strong>Fixed-Size Arrays (Recommended):</strong>
<pre><code>// Compile-time size determination - optimal for real-time audio
global array delayLine[2048];
global array windowFunction[512];
global array frequencyBins[256];
<p>function initializeArrays() {
    // Initialize delay line to zero
    int i;
    for (i = 0 to 2048) {
        delayLine[i] = 0;
    }
    
    // Pre-calculate window function (Hanning window)
    for (i = 0 to 512) {
        int n = i;
        int N = 512;
        // Fixed-point calculation: 0.5 <em> (1 - cos(2</em>pi*n/(N-1)))
        int angle = (n <em> 6283) / (N - 1);  // 2</em>pi scaled by 1000
        int cosValue = fastCos(angle);     // Returns -1000 to 1000
        windowFunction[i] = 500 - (cosValue >> 1);  // Scale to 0-1000
    }
}</p>
<p>// Fast cosine approximation using lookup table
readonly array cosineTable[360] = {
    1000, 999, 996, 991, 985, 978, 970, 961, 951, 940,
    // ... complete 360-value cosine table scaled by 1000
};</p>
<p>function fastCos(int scaledAngle) returns int result {
    int degrees = (scaledAngle * 360) / 6283;  // Convert to degrees
    degrees = degrees % 360;  // Wrap to 0-359
    if (degrees < 0) degrees += 360;
    result = cosineTable[degrees];
}</code></pre></p>
<strong>Pre-allocated Buffers (Best Practice):</strong>
<pre><code>// Pre-allocated with maximum expected size
global array maxTempBuffer[4096];
global int tempBufferInUse = 0;
<p>function getTempBuffer(int neededSize) returns array result[4096] {
    if (neededSize <= 4096 && tempBufferInUse == 0) {
        tempBufferInUse = 1;  // Mark as in use
        return maxTempBuffer;
    }
    // Handle error case - return smaller safe buffer
    return maxTempBuffer;  // Caller must check size
}</p>
<p>function releaseTempBuffer() {
    tempBufferInUse = 0;  // Mark as available
}</code></pre></p>
<h2>Stack Memory Management</h2>
<h3>Function Parameter Handling</h3>
<p>Impala manages function parameters efficiently on the stack:</p>
<pre><code>// Pass by value - copies data to stack (fast for small types)
function processSample(int input, int gain) returns int result {
    int processed = (input * gain) >> 8;  // Fixed-point multiplication
    result = processed;
}
<p>// Pass arrays by reference - efficient for large data
function processBuffer(array buffer[1024], int length) {
    int i;
    for (i = 0 to length) {
        buffer[i] = applyFilter(buffer[i]);
    }
}</p>
<p>// Process array sections efficiently
function processSection(array samples[512], int startIndex, int endIndex) {
    int i;
    for (i = startIndex to endIndex) {
        samples[i] = saturate(samples[i] * 3 >> 1);  // 1.5x gain
    }
}</code></pre></p>
<h3>Local Variable Optimization</h3>
<strong>Stack-Friendly Patterns:</strong>
<pre><code>function efficientProcessing() {
    // Small local variables - minimal stack impact
    int gain = (int)params[OPERAND_1_HIGH_PARAM_INDEX];
    int feedback = (int)params[OPERAND_1_LOW_PARAM_INDEX];
    int mix = (int)params[SWITCHES_PARAM_INDEX];
    
    // Local arrays - use sparingly, prefer global allocation
    array tempCoeffs[8];
    calculateFilterCoeffs(tempCoeffs, gain);
    
    // Process using efficient local variables
    int i;
    for (i = 0 to 2) {  // Process stereo
        int input = signal[i];
        int filtered = applyBiquad(input, tempCoeffs);
        signal[i] = (input <em> (255 - mix) + filtered </em> mix) >> 8;
    }
}</code></pre>
<strong>Stack Overflow Prevention:</strong>
<pre><code>// Avoid large local arrays - causes stack overflow
function badStackUsage() {
    // DON'T DO THIS - 8KB array overflows 4KB stack
    array hugeBuffer[4096];  // STACK OVERFLOW!
    // ... processing
}
<p>// Instead, use global allocation
global array largeWorkBuffer[4096];</p>
<p>function goodStackUsage() {
    // Use pre-allocated global buffer
    clearBuffer(largeWorkBuffer);
    // ... processing using largeWorkBuffer
}</p>
<p>function clearBuffer(array buffer[4096]) {
    int i;
    for (i = 0 to 4096) {
        buffer[i] = 0;
    }
}</code></pre></p>
<h2>Memory Safety Mechanisms</h2>
<h3>Bounds Checking</h3>
<p>Impala provides compile-time and runtime bounds checking for memory safety:</p>
<pre><code>global array delayBuffer[1024];
global int delayIndex = 0;
<p>function safeDelayAccess() {
    // Compile-time bounds checking - array size known
    delayBuffer[512] = signal[0];  // OK - within bounds
    // delayBuffer[1024] = signal[0];  // COMPILE ERROR - out of bounds
    
    // Runtime bounds checking for dynamic indices
    if (delayIndex < 1024) {
        int delayedSample = delayBuffer[delayIndex];
        delayBuffer[delayIndex] = signal[0];
        delayIndex = (delayIndex + 1) % 1024;
        signal[0] = delayedSample;
    }
}</code></pre></p>
<h3>Safe Array Access Patterns</h3>
<pre><code>// Safe array access with bounds validation
function safeArrayAccess(array buffer[1024], int index, int value) {
    // Always validate index before access
    if (index >= 0 && index < 1024) {
        buffer[index] = value;
    } else {
        trace("ERROR: Array index out of bounds");
        // Handle error gracefully
    }
}
<p>// Circular buffer with automatic wrapping
function circularBufferAccess(array buffer[512], int index, int value) {
    // Ensure positive index and wrap
    int safeIndex = index % 512;
    if (safeIndex < 0) safeIndex += 512;
    buffer[safeIndex] = value;
}</code></pre></p>
<h2>Memory Layout Optimization</h2>
<h3>Cache-Friendly Data Structures</h3>
<strong>Structure of Arrays (SoA) Pattern:</strong>
<pre><code>// Efficient for sequential processing and cache locality
global array leftSamples[512];
global array rightSamples[512];
global array leftHistory[64];
global array rightHistory[64];
<p>function processStereoSoA() {
    // Process left channel with good cache locality
    int i;
    for (i = 0 to 512) {
        leftSamples[i] = applyFilter(leftSamples[i], leftHistory);
    }
    
    // Process right channel with good cache locality
    for (i = 0 to 512) {
        rightSamples[i] = applyFilter(rightSamples[i], rightHistory);
    }
}</code></pre></p>
<strong>Interleaved Stereo Processing:</strong>
<pre><code>// Efficient when processing samples together
global array stereoBuffer[1024];  // Interleaved L,R,L,R...
<p>function processStereoInterleaved() {
    int frameCount = 512;  // 512 stereo frames = 1024 samples
    int i;
    for (i = 0 to frameCount) {
        int leftIndex = i * 2;
        int rightIndex = i * 2 + 1;
        
        // Process left and right together
        int processedLeft = applyLeftEffect(stereoBuffer[leftIndex]);
        int processedRight = applyRightEffect(stereoBuffer[rightIndex]);
        
        // Apply cross-channel effects
        stereoBuffer[leftIndex] = processedLeft + (processedRight >> 4);  // 6% crosstalk
        stereoBuffer[rightIndex] = processedRight + (processedLeft >> 4);
    }
}</code></pre></p>
<h3>Memory Alignment and Access Patterns</h3>
<pre><code>// Sequential Access (Fastest)
function sequentialProcessing(array buffer[1024]) {
    // Optimal memory access pattern
    int i;
    for (i = 0 to 1024) {
        buffer[i] = applyProcessing(buffer[i]);
    }
}
<p>// Block Processing (Optimal for Complex Operations)
function blockProcessing(array buffer[1024]) {
    const int BLOCK_SIZE = 64;
    int blockCount = 1024 / BLOCK_SIZE;  // 16 blocks
    
    int blockIdx;
    for (blockIdx = 0 to blockCount) {
        int blockStart = blockIdx * BLOCK_SIZE;
        
        // Process entire block with good cache locality
        applyComplexProcessing(buffer, blockStart, BLOCK_SIZE);
    }
}</p>
<p>function applyComplexProcessing(array buffer[1024], int start, int length) {
    int i;
    for (i = start to start + length) {
        // Complex processing on contiguous memory block
        buffer[i] = complexAlgorithm(buffer[i]);
    }
}</code></pre></p>
<h2>Performance Optimization Patterns</h2>
<h3>Memory Pool Implementation</h3>
<pre><code>// Custom memory pool for temporary allocations
global array memoryPool[8192];
global array freeBlocks[32];  // Track which blocks are free
global int blockSize = 256;   // Each block is 256 bytes
global int blockCount = 32;   // 8192 / 256 = 32 blocks
<p>function initMemoryPool() {
    int i;
    // Mark all blocks as free
    for (i = 0 to 32) {
        freeBlocks[i] = 1;  // 1 = free, 0 = allocated
    }
}</p>
<p>function allocateFromPool() returns int blockIndex {
    // Find first free block
    int i;
    for (i = 0 to 32) {
        if (freeBlocks[i] == 1) {
            freeBlocks[i] = 0;  // Mark as allocated
            return i;
        }
    }
    return -1;  // Pool exhausted
}</p>
<p>function freeToPool(int blockIndex) {
    if (blockIndex >= 0 && blockIndex < 32) {
        freeBlocks[blockIndex] = 1;  // Mark as free
    }
}</p>
<p>function getPoolBlock(int blockIndex, array result[256]) {
    if (blockIndex >= 0 && blockIndex < 32) {
        int startOffset = blockIndex * blockSize;
        int i;
        for (i = 0 to 256) {
            result[i] = memoryPool[startOffset + i];
        }
    }
}</code></pre></p>
<h2>Real-Time Memory Patterns</h2>
<h3>Lock-Free Circular Buffers</h3>
<pre><code>// Single-producer, single-consumer lock-free buffer
global array circularData[2048];
global int writeIndex = 0;
global int readIndex = 0;
<p>function writeSample(int sample) returns int success {
    int nextWrite = (writeIndex + 1) % 2048;
    
    // Check if buffer is full (would overwrite unread data)
    if (nextWrite == readIndex) {
        return 0;  // Buffer full
    }
    
    circularData[writeIndex] = sample;
    writeIndex = nextWrite;  // Atomic on Permut8
    return 1;  // Success
}</p>
<p>function readSample() returns int sample {
    // Check if buffer is empty
    if (readIndex == writeIndex) {
        return 0;  // Buffer empty - return silence
    }
    
    int sample = circularData[readIndex];
    readIndex = (readIndex + 1) % 2048;
    return sample;
}</p>
<p>function getBufferLevel() returns int level {
    if (writeIndex >= readIndex) {
        return writeIndex - readIndex;
    } else {
        return (2048 - readIndex) + writeIndex;
    }
}</code></pre></p>
<h3>Zero-Copy Buffer Management</h3>
<pre><code>// Efficient buffer passing without copying
global array inputBuffer[512];
global array outputBuffer[512];
global int processingComplete = 0;
<p>function setupZeroCopy() {
    // Just mark buffers as ready - no data copying
    processingComplete = 0;
}</p>
<p>function processZeroCopy() {
    // Process directly from input to output
    int i;
    for (i = 0 to 512) {
        outputBuffer[i] = applyEffect(inputBuffer[i]);
    }
    processingComplete = 1;
}</p>
<p>function swapBuffers() {
    // Swap input and output for ping-pong processing
    array tempBuffer[512];
    int i;
    
    // Copy output to temp
    for (i = 0 to 512) {
        tempBuffer[i] = outputBuffer[i];
    }
    
    // Copy input to output
    for (i = 0 to 512) {
        outputBuffer[i] = inputBuffer[i];
    }
    
    // Copy temp to input
    for (i = 0 to 512) {
        inputBuffer[i] = tempBuffer[i];
    }
}</code></pre></p>
<h2>Debugging Memory Issues</h2>
<h3>Memory Usage Monitoring</h3>
<pre><code>// Runtime memory usage tracking
global int stackHighWaterMark = 0;
global int poolAllocations = 0;
global int poolDeallocations = 0;
global int bufferOverrunCount = 0;
<p>function checkStackUsage() returns int usage {
    // Estimate stack usage (platform-specific implementation)
    int currentUsage = getApproximateStackUsage();
    
    if (currentUsage > stackHighWaterMark) {
        stackHighWaterMark = currentUsage;
    }
    
    // Alert if approaching stack limit (4KB = 4096 bytes)
    if (currentUsage > 3276) {  // 80% usage warning
        displayLEDs[0] = 0xFF;  // Red LED warning
        trace("WARNING: High stack usage detected");
    }
    
    return currentUsage;
}</p>
<p>// Platform-specific stack usage estimation
function getApproximateStackUsage() returns int estimation {
    // This is a simplified estimation
    // Actual implementation would use platform-specific methods
    return 1024;  // Placeholder value
}</code></pre></p>
<h3>Buffer Overflow Detection</h3>
<pre><code>// Guard pattern implementation
global int guardPrefix = 0xDEAD;
global array protectedData[1024];
global int guardSuffix = 0xBEEF;
<p>function initGuardedBuffer() {
    guardPrefix = 0xDEAD;
    guardSuffix = 0xBEEF;
    
    // Initialize data to zero
    int i;
    for (i = 0 to 1024) {
        protectedData[i] = 0;
    }
}</p>
<p>function checkBufferIntegrity() returns int isValid {
    if (guardPrefix != 0xDEAD) {
        bufferOverrunCount = bufferOverrunCount + 1;
        displayLEDs[1] = 0xFF;  // Orange LED - prefix corruption
        trace("ERROR: Buffer prefix corrupted");
        return 0;
    }
    
    if (guardSuffix != 0xBEEF) {
        bufferOverrunCount = bufferOverrunCount + 1;
        displayLEDs[2] = 0xFF;  // Yellow LED - suffix corruption
        trace("ERROR: Buffer suffix corrupted");
        return 0;
    }
    
    return 1;  // Buffer is intact
}</code></pre></p>
<h3>Memory Leak Detection</h3>
<pre><code>// Allocation tracking for debugging
global int totalAllocations = 0;
global int totalDeallocations = 0;
global int currentAllocations = 0;
global int peakAllocations = 0;
<p>function trackAllocation() {
    totalAllocations = totalAllocations + 1;
    currentAllocations = currentAllocations + 1;
    
    if (currentAllocations > peakAllocations) {
        peakAllocations = currentAllocations;
    }
    
    // Update LED display with allocation count
    displayLEDs[3] = currentAllocations;
}</p>
<p>function trackDeallocation() {
    totalDeallocations = totalDeallocations + 1;
    if (currentAllocations > 0) {
        currentAllocations = currentAllocations - 1;
    }
}</p>
<p>function checkMemoryLeaks() returns int hasLeaks {
    int leakedAllocations = totalAllocations - totalDeallocations;
    
    if (leakedAllocations > 0) {
        trace("WARNING: Memory leaks detected");
        return 1;  // Has leaks
    }
    
    return 0;  // No leaks
}</code></pre></p>
<h2>Best Practices Summary</h2>
<h3>Memory Allocation Guidelines</h3>
<p>1. <strong>Prefer Static Allocation</strong>: Use global arrays and compile-time sizing for predictable memory usage
2. <strong>Minimize Stack Usage</strong>: Keep local variables small, avoid large local arrays  
3. <strong>Use Memory Pools</strong>: For occasional dynamic needs, implement custom pools rather than general allocation
4. <strong>Plan Memory Layout</strong>: Organize data by access patterns and frequency
5. <strong>Validate Array Access</strong>: Always check bounds for dynamic indices</p>
<h3>Performance Optimization Rules</h3>
<p>1. <strong>Sequential Access First</strong>: Design algorithms around linear memory access when possible
2. <strong>Cache-Friendly Patterns</strong>: Group related data together, process in blocks
3. <strong>Minimize Indirection</strong>: Avoid complex pointer arithmetic in audio processing loops
4. <strong>Pre-calculate Addresses</strong>: Cache frequently-used array indices
5. <strong>Zero-Copy Techniques</strong>: Process data in-place when safe</p>
<h3>Safety and Debugging Practices</h3>
<p>1. <strong>Enable Bounds Checking</strong>: Validate array indices in debug builds
2. <strong>Implement Guard Patterns</strong>: Detect buffer overflows with guard values
3. <strong>Monitor Resource Usage</strong>: Track stack, pool, and buffer usage
4. <strong>Test Memory Limits</strong>: Validate behavior under maximum memory load conditions
5. <strong>Profile Memory Access</strong>: Identify and optimize memory hotspots</p>
<h3>Real-Time Constraints</h3>
<p>1. <strong>No Dynamic Allocation</strong>: Avoid runtime memory allocation in audio processing code
2. <strong>Predictable Access Patterns</strong>: Use consistent memory access patterns for deterministic timing
3. <strong>Lock-Free Data Structures</strong>: Use atomic operations and careful ordering for thread safety
4. <strong>Pre-allocated Buffers</strong>: Size all buffers for worst-case scenarios at compile time
5. <strong>Efficient Buffer Management</strong>: Implement circular buffers for real-time data flow</p>
<h2>Conclusion</h2>
<p>Impala's memory model provides the foundation for building efficient, safe, and predictable real-time audio processing systems. By understanding and following these memory management principles, developers can create firmware that maximizes the Permut8's capabilities while maintaining the strict timing requirements of professional audio applications.</p>
<p>The key to successful memory management in Impala is embracing the constraints of real-time audio processing: predictable allocation, efficient access patterns, and robust safety mechanisms. These constraints, rather than limiting creativity, provide the structure needed to build reliable, high-performance audio processing systems.</p>
</div>


<div class="file-section" id="processing-order">
    <div class="file-title">üìÑ Processing Order</div>
    <h1>Processing Order - Signal Flow in Permut8 Firmware</h1>
<p>Understanding how audio flows through your Permut8 firmware is essential for building effective DSP algorithms. The processing order determines how samples move through your code and when different operations occur.</p>
<h2>Two Processing Models</h2>
<p>Permut8 supports two distinct processing approaches that handle signal flow differently:</p>
<h3>Mod Patches: operate1() and operate2()</h3>
<p>Mod patches process individual operators within the existing engine. Your code runs once per sample for each active operator:</p>
<pre><code>function operate1(int inSample) returns int result {
    // Process one sample through operator 1
    int delayed = delayLine[delayPos];
    delayLine[delayPos] = inSample;
    delayPos = (delayPos + 1) % DELAY_LENGTH;
    
    result = (inSample + delayed) >> 1;  // Simple echo (divide by 2)
}
<p>function operate2(int inSample) returns int result {
    // Process one sample through operator 2
    // Runs independently from operate1()
    result = (inSample * feedbackAmount) >> 8;  // Fixed-point multiplication
}</code></pre></p>
<strong>Signal Flow</strong>: Input ‚Üí operate1() ‚Üí operate2() ‚Üí Output
<p>Each function receives the processed output from the previous stage. This creates a serial processing chain where order matters.</p>
<h3>Full Patches: process()</h3>
<p>Full patches replace the entire audio engine. Your code controls the complete signal path:</p>
<pre><code>function process() {
    loop {
        // Read input sample
        int input = signal[0];
        
        // Your complete DSP algorithm here
        int filtered = applyLowpass(input);
        int delayed = addDelay(filtered);
        int finalOutput = applyDynamics(delayed);
        
        // Write output sample
        signal[0] = finalOutput;
        
        yield();  // Process next sample
    }
}</code></pre>
<strong>Signal Flow</strong>: Raw Input ‚Üí Your Complete Algorithm ‚Üí Raw Output
<p>You control every aspect of processing, from input to output.</p>
<h2>Processing Timing</h2>
<h3>Sample-Rate Processing</h3>
<p>Both models process at audio sample rate (approximately 48kHz). Each function call processes exactly one sample:</p>
<pre><code>// This runs 48,000 times per second
function operate1(int inSample) returns int result {
    // Keep processing lightweight!
    result = applySimpleFilter(inSample);
}</code></pre>
<h3>Cooperative Multitasking</h3>
<p>In full patches, <code>yield()</code> is crucial for proper timing:</p>
<pre><code>function process() {
    loop {
        // Process one sample
        int result = complexAlgorithm(signal[0]);
        signal[0] = result;
        
        yield();  // REQUIRED: Let system process next sample
    }
}</code></pre>
<p>Forgetting <code>yield()</code> breaks real-time processing.</p>
<h2>Practical Processing Patterns</h2>
<h3>Sequential Effects Chain</h3>
<pre><code>function operate1(int input) returns int result {
    // Stage 1: Filter
    result = lowpassFilter(input);
}
<p>function operate2(int filtered) returns int result {
    // Stage 2: Distortion
    result = waveshape(filtered);
}</code></pre></p>
<h3>Parallel Processing</h3>
<pre><code>function process() {
    loop {
        int input = signal[0];
        
        // Split signal for parallel processing
        int dry = input;
        int wet = applyReverb(input);
        
        // Mix parallel paths
        signal[0] = (dry + wet) >> 1;  // Divide by 2
        yield();
    }
}</code></pre>
<h3>State Management Between Samples</h3>
<pre><code>global int filterState = 0;
<p>function operate1(int input) returns int result {
    // State persists between samples
    filterState = (filterState + input) >> 1;  // Simple low-pass
    result = filterState;
}</code></pre></p>
<h3>Parameter Integration</h3>
<pre><code>function operate1(int input) returns int result {
    // Use parameter values in processing
    int gain = (int)params[OPERAND_1_HIGH_PARAM_INDEX];
    int feedback = (int)params[OPERAND_1_LOW_PARAM_INDEX];
    
    // Apply parameter-controlled processing
    int amplified = (input * gain) >> 8;
    result = (amplified * feedback) >> 8;
}</code></pre>
<h3>Error Handling and Safety</h3>
<pre><code>function operate1(int input) returns int result {
    // Clip input to valid range
    if (input > 2047) input = 2047;
    else if (input < -2047) input = -2047;
    
    // Process safely
    result = processWithSafety(input);
    
    // Clip output to valid range
    if (result > 2047) result = 2047;
    else if (result < -2047) result = -2047;
}
<p>function processWithSafety(int input) returns int result {
    // Prevent overflow in calculations
    int scaled = input >> 2;  // Scale down to prevent overflow
    int processed = scaled * 3;  // Safe multiplication
    result = processed << 2;  // Scale back up
}</code></pre></p>
<h3>Memory Management in Processing</h3>
<pre><code>// Pre-allocated buffers for processing
global array delayLine[1024];
global int delayPos = 0;
global array tempBuffer[64];
<p>function operate1(int input) returns int result {
    // Use pre-allocated memory efficiently
    delayLine[delayPos] = input;
    
    // Calculate delay output
    int delayedPos = (delayPos - 500) % 1024;
    if (delayedPos < 0) delayedPos += 1024;
    
    int delayed = delayLine[delayedPos];
    delayPos = (delayPos + 1) % 1024;
    
    result = (input + delayed) >> 1;
}</code></pre></p>
<h3>Advanced Routing Patterns</h3>
<pre><code>function process() {
    loop {
        int input = signal[0];
        
        // Multi-tap delay with different processing
        int tap1 = getTapDelay(input, 250);   // 250 samples delay
        int tap2 = getTapDelay(input, 500);   // 500 samples delay
        int tap3 = getTapDelay(input, 1000);  // 1000 samples delay
        
        // Process each tap differently
        int processed1 = applyFilter(tap1);
        int processed2 = applyDistortion(tap2);
        int processed3 = applyModulation(tap3);
        
        // Mix all taps with original
        signal[0] = (input + processed1 + processed2 + processed3) >> 2;
        
        yield();
    }
}
<p>function getTapDelay(int input, int delaySamples) returns int delayed {
    // Implementation would use appropriate delay buffer management
    // This is a conceptual example
    delayed = readDelayLine(delaySamples);
    writeDelayLine(input);
}</code></pre></p>
<h3>Debugging Processing Flow</h3>
<pre><code>global int debugCounter = 0;
<p>function operate1(int input) returns int result {
    // Debug processing every 4800 samples (10x per second at 48kHz)
    debugCounter++;
    if ((debugCounter % 4800) == 0) {
        array debugMsg[64];
        strcpy(debugMsg, "Op1 In: ");
        strcat(debugMsg, intToString(input, 10, 1, tempBuffer));
        trace(debugMsg);
    }
    
    result = processFunction(input);
    
    if ((debugCounter % 4800) == 0) {
        array debugMsg2[64];
        strcpy(debugMsg2, "Op1 Out: ");
        strcat(debugMsg2, intToString(result, 10, 1, tempBuffer));
        trace(debugMsg2);
    }
}</code></pre></p>
<h2>Performance Considerations</h2>
<h3>Mod Patches</h3>
<ul><li><strong>Optimized</strong>: Engine handles complex routing and parameter management</li><li><strong>Efficient</strong>: Minimal overhead for simple processing</li><li><strong>Limited</strong>: Restricted to operator-based processing model</li><li><strong>Reliable</strong>: Engine provides stability and error handling</li></ul>
<h3>Full Patches  </h3>
<ul><li><strong>Flexible</strong>: Complete control over signal path and processing</li><li><strong>Powerful</strong>: Can implement any algorithm within timing constraints</li><li><strong>Responsible</strong>: You must handle all optimizations and error cases</li><li><strong>Demanding</strong>: Must maintain real-time performance guarantees</li></ul>
<h3>Performance Guidelines</h3>
1. <strong>Keep operate1/operate2 lightweight</strong> - Simple operations only
2. <strong>Use pre-allocated memory</strong> - Avoid dynamic allocation in process()
3. <strong>Monitor CPU usage</strong> - Complex algorithms may exceed timing budget
4. <strong>Test edge cases</strong> - Verify performance with extreme parameter values
5. <strong>Profile regularly</strong> - Use trace() to monitor processing times
<h3>Memory Usage Patterns</h3>
<ul><li><strong>Static allocation</strong>: Pre-allocate all buffers at startup</li><li><strong>Circular buffers</strong>: Efficient for delay lines and history</li><li><strong>State variables</strong>: Minimize global state for better cache performance</li><li><strong>Parameter caching</strong>: Copy frequently-used parameters to locals</li></ul>
<h2>Best Practices Summary</h2>
<h3>Signal Flow Design</h3>
1. <strong>Plan your processing chain</strong> - Know your signal path before coding
2. <strong>Consider parameter integration</strong> - How controls affect processing
3. <strong>Design for real-time</strong> - Keep algorithms deterministic
4. <strong>Test signal flow</strong> - Verify audio path with known test signals
<h3>Code Organization</h3>
1. <strong>Separate concerns</strong> - Different processing stages in different functions
2. <strong>Use clear naming</strong> - Function and variable names reflect purpose
3. <strong>Document signal flow</strong> - Comment the audio path through your code
4. <strong>Handle edge cases</strong> - Plan for silence, full-scale, and parameter extremes
<h3>Debugging Strategies</h3>
1. <strong>Use trace() judiciously</strong> - Monitor key processing points
2. <strong>Test incrementally</strong> - Build processing chain step by step
3. <strong>Verify timing</strong> - Ensure yield() placement maintains real-time
4. <strong>Monitor resources</strong> - Track memory and CPU usage
<p>Understanding these processing patterns helps you choose the right approach and structure your code for optimal audio quality and performance. The key is matching your processing requirements to the appropriate model while maintaining real-time constraints.</p>
</div>


<div class="file-section" id="state-management">
    <div class="file-title">üìÑ State Management</div>
    <h1>State Management - Persistent Data in Permut8 Firmware</h1>
<p>Effective state management is crucial for building DSP algorithms that remember information between audio samples. Permut8 firmware processes thousands of samples per second, and your code needs to maintain state efficiently across these rapid function calls.</p>
<h2>Global Variables for Persistence</h2>
<p>Use <code>global</code> variables to store data that persists between function calls:</p>
<pre><code>global array delayBuffer[1024];
global int writePos = 0;
global int feedbackLevel = 128;
<p>function operate1(int input) returns int result {
    // State persists between samples
    int delayed = delayBuffer[writePos];
    delayBuffer[writePos] = input + ((delayed * feedbackLevel) >> 8);
    
    writePos = (writePos + 1) % 1024;
    result = delayed;
}</code></pre></p>
<strong>Key Point</strong>: Global variables maintain their values across all function calls, making them perfect for delay lines, filter states, and accumulators.
<h2>Initialization Patterns</h2>
<h3>Simple Initialization</h3>
<p>For basic state, direct assignment and first-call initialization work well:</p>
<pre><code>global int initialized = 0;
global int filterState = 0;
<p>function operate1(int input) returns int result {
    if (initialized == 0) {
        filterState = input;  // Initialize to first sample
        initialized = 1;
    }
    
    // Simple lowpass filter using fixed-point math
    filterState = ((filterState * 7) + input) >> 3;  // Divide by 8
    result = filterState;
}</code></pre></p>
<h3>Complex State Setup</h3>
<p>For larger state structures, use initialization functions:</p>
<pre><code>global array reverbTaps[8];
global array tapDelays[8] = {47, 97, 149, 211, 281, 359, 443, 541};
global int reverbPos = 0;
global int setupDone = 0;
<p>function setupReverb() {
    // Initialize complex state once
    int i;
    for (i = 0 to 8) {
        reverbTaps[i] = 0;
    }
    setupDone = 1;
}</p>
<p>function operate1(int input) returns int result {
    if (setupDone == 0) {
        setupReverb();
    }
    
    // Use initialized state
    result = processReverb(input);
}</p>
<p>function processReverb(int input) returns int result {
    // Simple reverb implementation using taps
    int output = input;
    int i;
    
    for (i = 0 to 8) {
        int tapIndex = (reverbPos - tapDelays[i]) % 1024;
        if (tapIndex < 0) tapIndex += 1024;
        output += reverbTaps[tapIndex] >> 2;  // Mix in reverb taps
    }
    
    // Store input in reverb buffer
    reverbTaps[reverbPos] = input;
    reverbPos = (reverbPos + 1) % 1024;
    
    result = output >> 1;  // Scale output
}</code></pre></p>
<h2>State Reset and Cleanup</h2>
<h3>Parameter-Triggered Reset</h3>
<p>Reset state when parameters change significantly:</p>
<pre><code>global int lastDelayTime = 0;
global array delayBuffer[2048];
<p>function operate1(int input) returns int result {
    int currentDelay = (int)params[OPERAND_1_HIGH_PARAM_INDEX];
    
    // Clear buffer if delay time changed dramatically
    int delayDiff = currentDelay - lastDelayTime;
    if (delayDiff < 0) delayDiff = -delayDiff;  // Absolute value
    
    if (delayDiff > 32) {
        int i;
        for (i = 0 to 2048) {
            delayBuffer[i] = 0;
        }
        lastDelayTime = currentDelay;
        trace("Delay buffer cleared due to parameter change");
    }
    
    // Continue with clean state
    result = applyDelay(input, currentDelay);
}</p>
<p>function applyDelay(int input, int delayTime) returns int result {
    // Simple delay implementation
    int delayIndex = (writePos - delayTime) % 2048;
    if (delayIndex < 0) delayIndex += 2048;
    
    result = delayBuffer[delayIndex];
    delayBuffer[writePos] = input;
    writePos = (writePos + 1) % 2048;
}</code></pre></p>
<h3>Graceful State Transitions</h3>
<p>Avoid audio clicks when changing state:</p>
<pre><code>global int targetGain = 255;
global int currentGain = 255;
global int gainTransitionRate = 1;
<p>function operate1(int input) returns int result {
    // Smooth parameter changes
    targetGain = (int)params[OPERAND_1_HIGH_PARAM_INDEX];
    
    if (currentGain != targetGain) {
        // Gradual transition prevents clicks
        int diff = targetGain - currentGain;
        if (diff > gainTransitionRate) {
            currentGain += gainTransitionRate;
        } else if (diff < -gainTransitionRate) {
            currentGain -= gainTransitionRate;
        } else {
            currentGain = targetGain;  // Close enough, snap to target
        }
    }
    
    result = (input * currentGain) >> 8;  // Fixed-point multiplication
}</code></pre></p>
<h3>State Validation and Safety</h3>
<p>Ensure state remains within valid bounds:</p>
<pre><code>global int oscPhase = 0;
global int oscFreq = 440;
<p>function operate1(int input) returns int result {
    // Validate and clamp state variables
    if (oscPhase < 0 || oscPhase >= 1000) {
        oscPhase = 0;  // Reset to safe value
        trace("Oscillator phase reset to safe range");
    }
    
    if (oscFreq < 1 || oscFreq > 1000) {
        oscFreq = 440;  // Reset to safe frequency
        trace("Oscillator frequency reset to safe range");
    }
    
    // Generate oscillator output
    int oscOutput = generateTriangleWave(oscPhase);
    oscPhase = (oscPhase + oscFreq) % 1000;
    
    result = (input + oscOutput) >> 1;  // Mix oscillator with input
}</p>
<p>function generateTriangleWave(int phase) returns int result {
    // Triangle wave: 0-500 rise, 500-1000 fall
    if (phase < 500) {
        result = (phase * 4094) / 500 - 2047;  // Rising edge
    } else {
        result = 2047 - ((phase - 500) * 4094) / 500;  // Falling edge
    }
}</code></pre></p>
<h2>Memory-Efficient State</h2>
<h3>Circular Buffers</h3>
<p>Manage large state efficiently with wraparound indexing:</p>
<pre><code>global array buffer[512];
global int readPos = 0;
global int writePos = 256;  // Half buffer delay
<p>function operate1(int input) returns int result {
    // Write new sample
    buffer[writePos] = input;
    
    // Read delayed sample
    int output = buffer[readPos];
    
    // Advance pointers with wraparound
    readPos = (readPos + 1) % 512;
    writePos = (writePos + 1) % 512;
    
    result = output;
}</code></pre></p>
<h3>Variable Delay with Interpolation</h3>
<p>Implement smooth delay time changes:</p>
<pre><code>global array delayLine[1024];
global int writeIndex = 0;
<p>function operate1(int input) returns int result {
    // Write input to delay line
    delayLine[writeIndex] = input;
    
    // Get delay time from parameter (0-1023 samples)
    int delayTime = ((int)params[OPERAND_1_HIGH_PARAM_INDEX] * 1023) >> 8;
    
    // Calculate read position with fractional part
    int readPos = writeIndex - delayTime;
    if (readPos < 0) readPos += 1024;
    
    // Linear interpolation for smooth delay changes
    int nextPos = (readPos + 1) % 1024;
    int sample1 = delayLine[readPos];
    int sample2 = delayLine[nextPos];
    
    // Simple interpolation (could be enhanced with fractional delay)
    result = (sample1 + sample2) >> 1;
    
    writeIndex = (writeIndex + 1) % 1024;
}</code></pre></p>
<h3>Packed State</h3>
<p>Use bit manipulation to store multiple values efficiently:</p>
<pre><code>global int packedState = 0;
<p>function storePhase(int phase) {
    // Store 16-bit phase in upper bits (limit to 16-bit range)
    if (phase > 65535) phase = 65535;
    if (phase < 0) phase = 0;
    packedState = (packedState & 0xFFFF) | (phase << 16);
}</p>
<p>function storeAmplitude(int amp) {
    // Store 16-bit amplitude in lower bits
    if (amp > 65535) amp = 65535;
    if (amp < 0) amp = 0;
    packedState = (packedState & 0xFFFF0000) | (amp & 0xFFFF);
}</p>
<p>function getPhase() returns int phase {
    phase = (packedState >> 16) & 0xFFFF;
}</p>
<p>function getAmplitude() returns int amplitude {
    amplitude = packedState & 0xFFFF;
}</p>
<p>function operate1(int input) returns int result {
    // Use packed state for oscillator
    int phase = getPhase();
    int amplitude = getAmplitude();
    
    // Update amplitude based on parameter
    amplitude = (int)params[OPERAND_1_HIGH_PARAM_INDEX] << 8;  // Scale to 16-bit
    storeAmplitude(amplitude);
    
    // Generate output and advance phase
    int oscOutput = (generateSineApprox(phase) * amplitude) >> 16;
    phase = (phase + 100) % 65536;  // Advance phase
    storePhase(phase);
    
    result = (input + oscOutput) >> 1;
}</p>
<p>function generateSineApprox(int phase) returns int result {
    // Simple sine approximation using triangle wave
    int scaled = (phase * 1000) / 65536;  // Scale to 0-999
    if (scaled < 250) {
        result = (scaled * 4000) / 250;  // 0 to 1000
    } else if (scaled < 750) {
        result = 1000 - ((scaled - 250) * 4000) / 500;  // 1000 to -1000
    } else {
        result = -1000 + ((scaled - 750) * 4000) / 250;  // -1000 to 0
    }
}</code></pre></p>
<h2>Multi-Stage State Management</h2>
<h3>Filter Chains with State</h3>
<p>Manage state across multiple processing stages:</p>
<pre><code>// Filter chain state
global int lpfState1 = 0;
global int lpfState2 = 0;
global int hpfState1 = 0;
global int hpfStateInput = 0;
<p>function operate1(int input) returns int result {
    // Multi-stage filter with state management
    int stage1 = lowpassFilter(input, &lpfState1);
    int stage2 = lowpassFilter(stage1, &lpfState2);
    int stage3 = highpassFilter(stage2, &hpfState1, &hpfStateInput);
    
    result = stage3;
}</p>
<p>function lowpassFilter(int input, int state) returns int result {
    // Simple lowpass with state update
    int newState = (state * 7 + input) >> 3;  // Update state
    // Note: In real implementation, would need to update global state
    result = newState;
}</p>
<p>function highpassFilter(int input, int lastOutput, int lastInput) returns int result {
    // Highpass filter: output = input - lastInput + 0.95 * lastOutput
    int diff = input - lastInput;
    result = diff + ((lastOutput * 243) >> 8);  // 0.95 ‚âà 243/256
    
    // Note: In real implementation, would update global state variables
}</code></pre></p>
<h3>State Debugging and Monitoring</h3>
<p>Debug state changes effectively:</p>
<pre><code>global int debugCounter = 0;
global int stateChangeCount = 0;
<p>function operate1(int input) returns int result {
    int oldState = filterState;
    
    // Process with state change
    filterState = updateFilterState(input);
    
    // Monitor state changes for debugging
    if (filterState != oldState) {
        stateChangeCount++;
    }
    
    // Debug output every second (48000 samples)
    debugCounter++;
    if ((debugCounter % 48000) == 0) {
        array debugMsg[128];
        array tempBuf[32];
        
        strcpy(debugMsg, "State changes: ");
        strcat(debugMsg, intToString(stateChangeCount, 10, 1, tempBuf));
        strcat(debugMsg, " Filter: ");
        strcat(debugMsg, intToString(filterState, 10, 1, tempBuf));
        
        trace(debugMsg);
        stateChangeCount = 0;  // Reset counter
    }
    
    result = filterState;
}</code></pre></p>
<h2>Best Practices</h2>
<h3>Memory Management</h3>
<ul><li><strong>Pre-allocate state</strong>: Use global arrays sized for worst-case scenarios</li><li><strong>Minimize state size</strong>: Large arrays consume limited firmware memory</li><li><strong>Use circular buffers</strong>: Efficient for delay lines and history buffers</li><li><strong>Pack related data</strong>: Combine small state variables when possible</li></ul>
<h3>Performance Optimization</h3>
<ul><li><strong>Initialize once</strong>: Set up complex state only when needed, not every sample</li><li><strong>Cache frequently accessed state</strong>: Copy global state to locals in tight loops</li><li><strong>Use efficient data types</strong>: Prefer int over float for state variables</li><li><strong>Minimize state updates</strong>: Only update state when values actually change</li></ul>
<h3>Audio Quality</h3>
<ul><li><strong>Smooth transitions</strong>: Always interpolate when changing significant state to avoid audio artifacts</li><li><strong>Validate state bounds</strong>: Ensure state variables remain within valid ranges</li><li><strong>Handle parameter changes gracefully</strong>: Reset or transition state appropriately when parameters change</li><li><strong>Test edge cases</strong>: Verify state behavior with extreme parameter values</li></ul>
<h3>Debugging and Maintenance</h3>
<ul><li><strong>Add state validation</strong>: Check for invalid state values and reset safely</li><li><strong>Include debug monitoring</strong>: Track state changes for troubleshooting</li><li><strong>Document state relationships</strong>: Comment how state variables interact</li><li><strong>Plan reset strategies</strong>: Define when and how to reset state cleanly</li></ul>
<h3>Real-Time Constraints</h3>
<ul><li><strong>Avoid complex initialization</strong>: Keep per-sample state updates lightweight</li><li><strong>Use deterministic algorithms</strong>: Ensure state updates don't vary in execution time</li><li><strong>Plan for interruption</strong>: State should remain valid if processing is interrupted</li><li><strong>Consider memory alignment</strong>: Organize state for efficient memory access</li></ul>
<h2>Common State Management Patterns</h2>
<h3>Delay Line State</h3>
<pre><code>global array delayMem[2048];
global int delayWrite = 0;
<p>function delayReadWrite(int input, int delayTime) returns int output {
    int readPos = (delayWrite - delayTime) % 2048;
    if (readPos < 0) readPos += 2048;
    
    output = delayMem[readPos];
    delayMem[delayWrite] = input;
    delayWrite = (delayWrite + 1) % 2048;
}</code></pre></p>
<h3>Filter State</h3>
<pre><code>global int filter1State = 0;
global int filter2State = 0;
<p>function biquadChain(int input) returns int output {
    filter1State = ((filter1State * 15) + input) >> 4;  // Lowpass
    filter2State = input - filter1State + ((filter2State * 15) >> 4);  // Highpass
    output = filter2State;
}</code></pre></p>
<h3>Oscillator State</h3>
<pre><code>global int oscPhase = 0;
global int oscRate = 100;
<p>function oscillatorStep() returns int output {
    output = generateWave(oscPhase);
    oscPhase = (oscPhase + oscRate) % 1000;
}</code></pre></p>
<p>Proper state management ensures your DSP algorithms sound smooth, respond predictably to parameter changes, and maintain stable operation across millions of samples processed per second.</p>
</div>


<div class="file-section" id="p8bank-format">
    <div class="file-title">üìÑ P8Bank Format</div>
    <h1>P8Bank Format Specification</h1>
<p>Complete specification for Permut8 bank files (.p8bank) based on official Beatrick and FooBar firmware analysis.</p>
<h2>Overview</h2>
<p>P8Bank files are <strong>ASCII text files</strong> in a specific structured format. They are NOT binary files. They package compiled firmware with preset configurations, enabling complete firmware distribution and easy loading via the Permut8 plugin interface.</p>
<strong>‚ö†Ô∏è Critical Requirements</strong>:
<ul><li>Files must be plain text format (ASCII)</li><li>Header must be exactly <code>Permut8BankV2: {</code> (case-sensitive)</li><li>GAZL assembly must be clean (no compiler comments or separators)</li><li>All syntax must be precisely formatted</li></ul>
<h2>Bank File Structure</h2>
<h3>Top-Level Format</h3>
<strong>‚ö†Ô∏è Header Format Critical</strong>: Must be exactly <code>Permut8BankV2: {</code> with precise case and spacing.
<pre><code>Permut8BankV2: {
    CurrentProgram: A0
    Programs: { /<em> A0-C9 preset configurations </em>/ }
    Firmware: { /<em> Compiled GAZL assembly </em>/ }
    Logo: { /<em> Optional vector graphics </em>/ }
    About: { /<em> Optional documentation </em>/ }
}</code></pre>
<strong>Common Header Mistakes</strong>:
<ul><li>‚ùå <code>filename.p8bank: {</code> (filename-based)</li><li>‚ùå <code>permut8bankv2: {</code> (wrong case)</li><li>‚ùå <code>Permut8BankV2:{</code> (missing space)</li><li>‚úÖ <code>Permut8BankV2: {</code> (correct format)</li></ul>
<h2>Detailed Sections</h2>
<h3>1. CurrentProgram</h3>
<strong>Purpose</strong>: Default preset loaded when bank is opened  
<strong>Format</strong>: String (A0-C9)  
<strong>Example</strong>: <code>CurrentProgram: A0</code>
<h3>2. Programs Section</h3>
<p>Complete preset configurations for A0-C9 programs:</p>
<pre><code>Programs: {
    A0: {
        Name: "Preset Name"
        Modified: false
        InputLevel: "0.00000000"
        Limiter: "Off"
        FilterFreq: "---"
        FilterPlacement: "Output"
        FeedbackAmount: "0.00000000"
        FeedbackFlip: "Off"
        FeedbackInvert: "Off"
        OutputLevel: "0.00000000"
        Mix: "100.00000000"
        ClockFreq: "1/1"
        SyncMode: "Standard"
        Reverse: "Off"
        Operator1: "4"
        Operand1High: "0x00"
        Operand1Low: "0x00"
        Operator2: "0"
        Operand2High: "0x00"
        Operand2Low: "0x00"
    }
    // A1-C9 similar structure
}</code></pre>
<p>#### Parameter Binding</p>
<strong>Plugin Parameters ‚Üí Firmware Parameters</strong>:
<ul><li><code>Operator1/2</code>: Maps to <code>params[OPERATOR_1_PARAM_INDEX]</code></li><li><code>Operand1/2High</code>: Maps to <code>params[OPERAND_1_HIGH_PARAM_INDEX]</code></li><li><code>Operand1/2Low</code>: Maps to <code>params[OPERAND_1_LOW_PARAM_INDEX]</code></li></ul>
<strong>Parameter Value Format</strong>:
<ul><li>Operators: String integers ("0", "1", "4", etc.)</li><li>Operands: Hexadecimal strings ("0x00", "0x80", "0xFF")</li><li>Audio levels: Decimal strings ("-6.02059984", "0.00000000")</li><li>Switches: String ("On", "Off", "Standard")</li></ul>
<h3>3. Firmware Section</h3>
<p>Contains the compiled GAZL assembly code:</p>
<strong>‚ö†Ô∏è GAZL Cleaning Required</strong>: Raw compiler output must be cleaned before bank integration.
<strong>Remove Before Bank Creation</strong>:
<ul><li>Compiler comments: <code>; Compiled with Impala version 1.0</code></li><li>Separator lines: <code>;-----------------------------------------------------------------------------</code></li><li>Any decorative formatting or non-assembly content</li></ul>
<pre><code>Firmware: {
    Name: "firmware_name"
    Config: ""
    Code: {
        "PRAWN_FIRMWARE_PATCH_FORMAT: ! DEFi #2"
        "FALSE: ! DEFi #0"
        "TRUE: ! DEFi #1"
        "signal: GLOB *2"
        "params: GLOB *PARAM_COUNT"
        "displayLEDs: GLOB *4"
        "clock: DATi #0"
        // ... complete GAZL assembly (CLEANED)
        "process: FUNC"
        // ... function definitions
    }
}</code></pre>
<p>#### Firmware Format Versions</p>
<strong>Version 2</strong> (Standard):
<pre><code>"PRAWN_FIRMWARE_PATCH_FORMAT: ! DEFi #2"</code></pre>
<ul><li>Basic parameter handling</li><li>16-step sequencing maximum</li><li>Standard memory layout</li></ul>
<strong>Version 3</strong> (Advanced):
<pre><code>"PRAWN_FIRMWARE_PATCH_FORMAT: ! DEFi #3"</code></pre>
<ul><li>Extended parameter handling</li><li>32-step sequencing</li><li>Host synchronization</li><li>Advanced random generation</li></ul>
<h3>4. Logo Section (Optional)</h3>
<p>Vector graphics for plugin interface customization:
<pre><code>Logo: {
    // SVG or vector graphics data
    // Customizes plugin appearance
}</code></pre></p>
<h3>5. About Section (Optional)</h3>
<p>Documentation and usage information:
<pre><code>About: {
    // Usage instructions
    // Parameter descriptions
    // Credits and version info
}</code></pre></p>
<h2>Official Firmware Examples</h2>
<h3>Beatrick Firmware Structure (Version 2)</h3>
<ul><li><strong>Format</strong>: <code>PRAWN_FIRMWARE_PATCH_FORMAT: ! DEFi #2</code></li><li><strong>Features</strong>: 16-step sequencer, 8 operators</li><li><strong>Programs</strong>: 30 presets (A0-C9) with creative names</li><li><strong>Effects</strong>: MUTE, REPEAT, SKIP, HOLD, ACCENT, STUTTER, REVERSE, TAPE_STOP</li></ul>
<h3>FooBar Firmware Structure (Version 3)</h3>
<ul><li><strong>Format</strong>: <code>PRAWN_FIRMWARE_PATCH_FORMAT: ! DEFi #3</code></li><li><strong>Features</strong>: 32-step sequencer, 8 effects, randomization</li><li><strong>Programs</strong>: 30 presets with advanced parameter configurations</li><li><strong>Effects</strong>: REVERSE_FX, BIT_CRUSH, TRANCE_GATE, REPEAT, STRETCH, PITCH_SHIFT, HALF_SPEED, TAPE_STOP</li></ul>
<h2>Bank Creation Workflow</h2>
<h3>1. Compile Firmware</h3>
<pre><code>PikaCmd.exe -compile your_firmware.impala</code></pre>
Produces: <code>your_firmware.gazl</code>
<h3>2. Create Bank Structure</h3>
Package GAZL content into bank format with preset configurations.
<h3>3. Test Bank</h3>
Load via: File ‚Üí Load Bank ‚Üí your_firmware.p8bank
<h3>4. Distribute</h3>
Share complete .p8bank file with end users.
<h2>Parameter Design Guidelines</h2>
<h3>Preset Organization Strategy</h3>
<ul><li><strong>A0-A9</strong>: Light/subtle effects</li><li><strong>B0-B9</strong>: Medium/moderate effects  </li><li><strong>C0-C9</strong>: Heavy/extreme effects</li></ul>
<h3>Parameter Value Selection</h3>
<pre><code>Light Mode:   Operator1: "1", Operand1High: "0x20"
Medium Mode:  Operator1: "3", Operand1High: "0x80" 
Heavy Mode:   Operator1: "7", Operand1High: "0xFF"</code></pre>
<h3>Naming Conventions</h3>
<ul><li><strong>Descriptive</strong>: "Subtle Chorus", "Heavy Distortion"</li><li><strong>Intuitive</strong>: "Light", "Medium", "Heavy"</li><li><strong>Creative</strong>: "Chop Till You Drop", "The Splice Must Flow"</li></ul>
<h2>Technical Requirements</h2>
<h3>Memory Constraints</h3>
<ul><li>Bank files should be optimized for size</li><li>Firmware memory usage should fit within Permut8 limits</li><li>Large delay buffers may affect bank loading</li></ul>
<h3>Compatibility</h3>
<ul><li>Version 2 format: Compatible with all Permut8 versions</li><li>Version 3 format: Requires latest Permut8 firmware</li><li>Parameter ranges: 0-255 for all operand values</li></ul>
<h3>Validation</h3>
<ul><li>All presets must load without errors</li><li>Parameter ranges must be within valid bounds</li><li>GAZL assembly must compile and execute correctly</li></ul>
<h2>Common Loading Errors and Solutions</h2>
<h3>"Invalid data format (unsupported version?)"</h3>
<strong>Cause</strong>: Incorrect bank header format  
<strong>Solution</strong>: 
<ul><li>Ensure header is exactly <code>Permut8BankV2: {</code> (case-sensitive)</li><li>Not <code>filename.p8bank: {</code> or other variations</li><li>Check for proper spacing and syntax</li></ul>
<h3>"Invalid mnemonic: Compiled"</h3>
<strong>Cause</strong>: Compiler comments left in GAZL assembly  
<strong>Solution</strong>:
<ul><li>Remove compiler comment: <code>; Compiled with Impala version 1.0</code></li><li>Clean GAZL before bank creation</li><li>Only include pure assembly code</li></ul>
<h3>"Invalid mnemonic" with dashes</h3>
<strong>Cause</strong>: Decorative separator lines in GAZL  
<strong>Solution</strong>:
<ul><li>Remove lines like <code>;-----------------------------------------------------------------------------</code></li><li>Remove all non-assembly formatting</li><li>Keep only functional GAZL mnemonics</li></ul>
<h3>Bank Loads But No Sound</h3>
<strong>Cause</strong>: Missing or incorrect firmware structure  
<strong>Solution</strong>:
<ul><li>Verify <code>process()</code> function exists and calls <code>yield()</code></li><li>Check signal processing logic</li><li>Ensure proper parameter handling</li></ul>
<h2>See Also</h2>
<ul><li><strong><a href="../user-guides/tutorials/creating-firmware-banks.md">Creating Firmware Banks</a></strong> - Step-by-step bank creation</li><li><strong><a href="../language/core_language_reference.md">Core Language Reference</a></strong> - Bank-compatible firmware patterns</li><li><strong><a href="../user-guides/cookbook/advanced/firmware-patterns.md">Official Firmware Patterns</a></strong> - Beatrick/FooBar examples</li><li><strong><a href="../user-guides/QUICKSTART.md">QUICKSTART Tutorial</a></strong> - Hands-on bank creation example</li></ul>
</div>


<div class="file-section" id="creating-firmware-banks">
    <div class="file-title">üìÑ Creating Firmware Banks</div>
    <h1>Creating Firmware Banks</h1>
<p>Complete step-by-step guide to packaging your compiled firmware into distributable .p8bank files.</p>
<h2>What You'll Learn</h2>
<ul><li>Package .gazl files into .p8bank format</li><li>Create multiple presets for your firmware</li><li>Test and validate bank files</li><li>Distribute professional firmware packages</li></ul>
<h2>Prerequisites</h2>
<ul><li>Compiled .gazl firmware file</li><li>Understanding of parameter mapping</li><li>Basic knowledge of Permut8 plugin interface</li></ul>
<h2>Complete Workflow Overview</h2>
<pre><code>.impala source ‚Üí .gazl assembly ‚Üí .p8bank package ‚Üí Distribution</code></pre>
<h2>Step 1: Prepare Your Compiled Firmware</h2>
<h3>Ensure Clean Compilation</h3>
<pre><code>PikaCmd.exe -compile your_effect.impala</code></pre>
<strong>Verify Output</strong>:
<ul><li><code>your_effect.gazl</code> file created</li><li>No compilation errors</li><li>Firmware follows bank-compatible patterns</li></ul>
<h3>Bank-Compatible Firmware Requirements</h3>
<p>Your firmware must include these elements:</p>
<pre><code>// Required format declaration
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2  // or 3 for advanced
<p>// Standard global layout
global array signal[2]       // Audio I/O
global array params[PARAM_COUNT]  // Plugin parameters  
global array displayLEDs[4]  // LED displays
global int clock = 0         // Clock counter</p>
<p>// Required functions
function process() {
    loop {
        // Main processing
        yield();
    }
}</code></pre></p>
<h2>Step 2: Design Your Preset System</h2>
<h3>Preset Organization Strategy</h3>
<strong>A0-A9: Light/Subtle Effects</strong>
<ul><li>Low intensity settings</li><li>Gentle parameter values</li><li>Suitable for mixing/mastering</li></ul>
<strong>B0-B9: Medium/Moderate Effects</strong> 
<ul><li>Balanced intensity</li><li>Noticeable but controlled</li><li>Good for creative processing</li></ul>
<strong>C0-C9: Heavy/Extreme Effects</strong>
<ul><li>High intensity settings</li><li>Dramatic parameter values  </li><li>Special effects and sound design</li></ul>
<h3>Parameter Mapping Strategy</h3>
<p>Design your firmware to respond to different operator values:</p>
<pre><code>function update() {
    int mode = (int) global params[OPERATOR_1_PARAM_INDEX];
    
    switch (mode) {
        case 1: // A0-A9 presets (light mode)
            setupLightProcessing();
            break;
        case 2: // B0-B9 presets (heavy mode)  
            setupHeavyProcessing();
            break;
        case 3: // C0-C9 presets (experimental)
            setupExperimentalProcessing();
            break;
    }
}</code></pre>
<h2>Step 3: Create Bank Structure</h2>
<h3>Basic Bank Template</h3>
<strong>‚ö†Ô∏è Critical</strong>: Header must be exactly <code>Permut8BankV2: {</code> (not filename-based)
<pre><code>Permut8BankV2: {
    CurrentProgram: A0
    Programs: {
        A0: {
            Name: "Subtle Effect"
            Modified: false
            InputLevel: "0.00000000"
            Limiter: "Off"
            FilterFreq: "---"
            FilterPlacement: "Output"
            FeedbackAmount: "0.00000000"
            FeedbackFlip: "Off"
            FeedbackInvert: "Off"
            OutputLevel: "0.00000000"
            Mix: "100.00000000"
            ClockFreq: "1/1"
            SyncMode: "Standard"
            Reverse: "Off"
            Operator1: "1"
            Operand1High: "0x20"
            Operand1Low: "0x00"
            Operator2: "0"
            Operand2High: "0x00"
            Operand2Low: "0x00"
        }
        A1: {
            Name: "Medium Effect"
            Modified: false
            InputLevel: "0.00000000"
            Limiter: "Off"
            FilterFreq: "---"
            FilterPlacement: "Output"
            FeedbackAmount: "0.00000000"
            FeedbackFlip: "Off"
            FeedbackInvert: "Off"
            OutputLevel: "0.00000000"
            Mix: "100.00000000"
            ClockFreq: "1/1"
            SyncMode: "Standard"
            Reverse: "Off"
            Operator1: "2"
            Operand1High: "0x80"
            Operand1Low: "0x40"
            Operator2: "0"
            Operand2High: "0x00"
            Operand2Low: "0x00"
        }
        // Continue for A2-C9 as needed
    }
    Firmware: {
        Name: "your_effect"
        Config: ""
        Code: {
            // Insert compiled .gazl content here
            "PRAWN_FIRMWARE_PATCH_FORMAT: ! DEFi #2"
            "signal: GLOB *2"
            "params: GLOB *PARAM_COUNT"
            "displayLEDs: GLOB *4"
            "clock: DATi #0"
            // ... rest of GAZL assembly from your_effect.gazl
            "process: FUNC"
            // ... complete firmware code
        }
    }
}</code></pre>
<h3>Parameter Value Guidelines</h3>
<strong>Operator Values</strong> (String format):
<ul><li>"0": No operation/bypass</li><li>"1": Light processing</li><li>"2": Medium processing  </li><li>"3": Heavy processing</li><li>"4"-"7": Specialized modes</li></ul>
<strong>Operand Values</strong> (Hexadecimal strings):
<ul><li>"0x00": Minimum (0)</li><li>"0x40": Quarter (64)</li><li>"0x80": Half (128)</li><li>"0xC0": Three-quarters (192)</li><li>"0xFF": Maximum (255)</li></ul>
<strong>Audio Levels</strong> (Decimal strings):
<ul><li>"0.00000000": Unity gain</li><li>"-6.02059984": Half volume (-6dB)</li><li>"6.02059984": Double volume (+6dB)</li></ul>
<h2>Step 4: GAZL Integration</h2>
<h3>Clean GAZL Content First</h3>
<strong>‚ö†Ô∏è Critical</strong>: GAZL must be cleaned before bank integration to avoid loading errors.
<p>1. <strong>Open your_effect.gazl</strong> in a text editor
2. <strong>Remove compiler-generated comments</strong>:
   <pre><code>   ; Compiled with Impala version 1.0    ‚Üê DELETE THIS LINE
   ``<code>
3. <strong>Remove any separator lines</strong>:
   </code>`<code>
   ;-----------------------------------------------------------------------------    ‚Üê DELETE THESE LINES
   </code>`<code>
4. <strong>Keep only pure assembly code</strong> (no comments, no decorative formatting)</p>
<h3>Extract GAZL Content</h3>
<p>1. <strong>Copy cleaned assembly code</strong> (after removing comments/separators)
2. <strong>Format for bank structure</strong>:
</code></pre>
Code: {
    "line 1 of GAZL assembly"
    "line 2 of GAZL assembly"
    "line 3 of GAZL assembly"
    // ... continue for all lines
}
<pre><code>
<h3>GAZL Formatting Rules</h3></p>
<ul><li>Each line becomes a quoted string</li><li>Preserve exact spacing and syntax</li><li>Include all assembly directives</li><li>Maintain line order exactly</li><li><strong>No compiler comments or separator lines</strong></li></ul>
<strong>Example GAZL Integration</strong>:</code></pre>
Code: {
    "PRAWN_FIRMWARE_PATCH_FORMAT: ! DEFi #2"
    "FALSE: ! DEFi #0"
    "TRUE: ! DEFi #1"
    "signal: GLOB *2"
    "params: GLOB *PARAM_COUNT"
    "displayLEDs: GLOB *4"
    "process: FUNC"
    "PARA *1"
    "$sample: LOCi"
    "loop {"
    "  PEEK $sample &signal:0"
    "  // ... processing code"
    "  POKE &signal:0 $sample"
    "  CALL ^yield %0 *1"
    "}"
    "RETU"
}
<pre><code>
<h2>Step 5: Testing and Validation</h2>
<h3>Pre-Distribution Checklist</h3>
<strong>Bank Loading Test</strong>:
<ul><li>[ ] Bank loads without errors</li><li>[ ] All presets (A0-C9) accessible</li><li>[ ] Default preset (CurrentProgram) loads correctly</li></ul>
<strong>Parameter Testing</strong>:
<ul><li>[ ] All parameter ranges functional (0-255)</li><li>[ ] Operator switching works between presets</li><li>[ ] Operand values produce expected results</li><li>[ ] LED displays respond correctly</li></ul>
<strong>Audio Testing</strong>:
<ul><li>[ ] Audio processing works across all presets</li><li>[ ] No audio dropouts or glitches</li><li>[ ] Parameter changes are smooth (no clicks)</li><li>[ ] Audio levels appropriate for each preset</li></ul>
<strong>Preset Validation</strong>:
<ul><li>[ ] Preset names accurately describe sound</li><li>[ ] A0-A9 presets are subtle/light</li><li>[ ] B0-B9 presets are medium intensity</li><li>[ ] C0-C9 presets are heavy/extreme</li><li>[ ] Smooth progression between preset intensities</li></ul>
<h3>Testing Workflow</h3>
</code></pre>
1. Load bank: File ‚Üí Load Bank ‚Üí your_effect.p8bank
2. Test A0 preset:
   - Play audio through Permut8
   - Adjust all knobs (test parameter ranges)
   - Verify LED display functionality
   - Check audio quality and levels
3. Repeat for A1, A2, etc.
4. Test preset switching:
   - Switch between A0 ‚Üí A1 ‚Üí B0 ‚Üí C0
   - Verify smooth transitions
   - No audio interruptions
5. Test bank unload/reload cycle
<pre><code>
<h2>Step 6: Professional Distribution</h2>
<h3>Distribution Package</h3>
<strong>Essential Files</strong>:
<ul><li></code>your_effect.p8bank<code> (main bank file)</li><li></code>README.txt<code> (installation and usage instructions)</li></ul>
<strong>Optional Files</strong>:
<ul><li>Demo audio examples</li><li>Parameter guide</li><li>Version history</li></ul>
<h3>End-User Instructions Template</h3>
</code></pre>
<h1>Installing Your Effect Bank</h1>
<h2>Installation</h2>
1. Download your_effect.p8bank
2. Open Permut8 plugin in your DAW
3. Go to File ‚Üí Load Bank
4. Select your_effect.p8bank
5. Choose from presets A0-C9
<h2>Preset Guide</h2>
<ul><li>A0-A9: Light processing modes</li></ul>
  - A0: "Subtle Effect" - Gentle processing
  - A1: "Light Touch" - Minimal coloration
  - A2: "Soft Enhancement" - Mild effect
  
<ul><li>B0-B9: Medium processing modes  </li></ul>
  - B0: "Balanced" - Even processing
  - B1: "Noticeable" - Clear effect
  - B2: "Pronounced" - Strong processing
<ul><li>C0-C9: Heavy processing modes</li></ul>
  - C0: "Intense" - Heavy effect
  - C1: "Extreme" - Maximum processing
  - C2: "Experimental" - Special effects
<h2>Parameters</h2>
<ul><li>Knob 1: [Primary effect parameter]</li><li>Knob 2: [Secondary parameter]</li><li>Knob 3: [Modulation/mix parameter] </li><li>Knob 4: [Special feature parameter]</li></ul>
<h2>Tips</h2>
<ul><li>Start with A0 preset for subtle effects</li><li>Use B presets for creative processing</li><li>C presets are for special effects and sound design</li><li>All parameters respond in real-time</li></ul>
<pre><code>
<h2>Advanced Bank Features</h2>
<h3>Multi-Effect Banks</h3>
<p>For firmware with multiple effects, organize presets by effect type:
</code></pre>
A0-A3: Delay effects (short to long)
A4-A7: Reverb effects (room to hall)  
A8-A9: Combined delay+reverb</p>
<p>B0-B3: Distortion effects (light to heavy)
B4-B7: Filter effects (low to high resonance)
B8-B9: Combined distortion+filter</p>
<p>C0-C9: Experimental combinations
<pre><code>
<h3>Version Management</h3></p>
<p>Track your bank versions:
</code></pre>
Firmware: {
    Name: "your_effect_v1_2"  // Include version
    Config: ""
    Code: { /<em> assembly </em>/ }
}
</code>`<code></p>
<h3>Bank Optimization</h3>
<strong>Memory Optimization</strong>:
<ul><li>Remove unused code sections</li><li>Optimize delay buffer sizes</li><li>Minimize global variable usage</li></ul>
<strong>Performance Optimization</strong>:
<ul><li>Use efficient parameter change detection</li><li>Implement smooth parameter interpolation</li><li>Optimize real-time processing loops</li></ul>
<h2>Common Issues and Solutions</h2>
<h3>Bank Won't Load</h3>
<ul><li><strong>"Invalid data format (unsupported version?)"</strong>: Check bank header format</li></ul>
  - Must start with </code>Permut8BankV2: {<code> (exact format, case-sensitive)
  - Not </code>filename.p8bank: {<code> or other variations
<ul><li><strong>"Invalid mnemonic: Compiled"</strong>: Clean GAZL file first</li></ul>
  - Remove compiler comment: </code>; Compiled with Impala version 1.0<code>
  - Remove from first line of .gazl before bank creation
<ul><li><strong>"Invalid mnemonic" with dashes</strong>: Remove decorative separators</li></ul>
  - Remove lines like </code>;-----------------------------------------------------------------------------`
  - Keep only pure assembly code
<ul><li><strong>Check GAZL syntax</strong>: Ensure no formatting errors in clean assembly</li><li><strong>Verify parameter ranges</strong>: All values within 0-255</li><li><strong>Test individual presets</strong>: Isolate problematic preset</li></ul>
<h3>Parameter Issues</h3>
<ul><li><strong>No response</strong>: Check parameter index mapping</li><li><strong>Wrong ranges</strong>: Verify operand value format</li><li><strong>Unexpected behavior</strong>: Review firmware parameter handling</li></ul>
<h3>Audio Problems</h3>
<ul><li><strong>No sound</strong>: Verify signal processing loop</li><li><strong>Distorted audio</strong>: Check audio level calculations</li><li><strong>Clicks/pops</strong>: Add parameter smoothing</li></ul>
<h2>See Also</h2>
<ul><li><strong><a href="../../architecture/p8bank-format.md">P8Bank Format</a></strong> - Complete format specification</li><li><strong><a href="../../language/core_language_reference.md">Core Language Reference</a></strong> - Bank-compatible patterns</li><li><strong><a href="complete-development-workflow.md">Complete Development Workflow</a></strong> - Full development process</li></ul>
</div>


<div class="file-section" id="compiler-troubleshooting-guide">
    <div class="file-title">üìÑ Compiler Troubleshooting Guide</div>
    <h1>PikaCmd.exe Compiler Troubleshooting Guide</h1>
<strong>Master the compilation process and resolve common issues systematically</strong>
<p>This comprehensive guide explains the technical architecture behind PikaCmd.exe compilation and provides systematic solutions to common compilation failures. Whether you're encountering your first compilation error or dealing with complex build environment issues, this guide will help you understand and resolve the problem.</p>
<h2>What You'll Learn</h2>
<p>By the end of this guide, you'll understand:
<ul><li>The three-layer technical architecture of PikaCmd.exe compilation</li><li>How to systematically diagnose and resolve compilation failures</li><li>Platform-specific compilation considerations</li><li>Advanced compiler usage patterns</li><li>Professional troubleshooting methodology</li></ul></p>
<strong>Prerequisites</strong>: Basic command line familiarity  
<strong>Time Required</strong>: 30-45 minutes  
<strong>Difficulty</strong>: Beginner to Intermediate
<h2>Chapter 1: Understanding the Three-Layer Compilation Architecture</h2>
<p>The initial command <code>PikaCmd.exe -compile ringmod_code.impala</code> failed due to a combination of three distinct technical issues, each of which was solved in turn:</p>
<p>1. <strong>Shell Execution Policy</strong>: PowerShell's security model requires explicit pathing for executables in the current directory. This was solved by prefixing the command with <code>.\</code>.
2. <strong>Program Role (Interpreter vs. Compiler)</strong>: The program PikaCmd.exe is not a standalone compiler but a language interpreter. It requires a script file as its first argument to know what logic to execute. This was solved by providing <code>impala.pika</code>.
3. <strong>Script-Level Argument Parsing</strong>: The <code>impala.pika</code> script has its own internal logic for handling command-line arguments, which needed to be satisfied in the correct order.</p>
<h3>Layer 1: PowerShell Command Precedence and Path Resolution</h3>
<strong>The Error</strong>:
<pre><code>The term 'PikaCmd.exe' is not recognized as the name of a cmdlet, function, script file, or operable program.</code></pre>
<strong>Technical Reason</strong>: This is a direct consequence of PowerShell's command execution policy and its use of the PATH environment variable.
<p>#### PATH Environment Variable Behavior
<ul><li><strong>PATH Search</strong>: When you type a command, the shell doesn't search every folder on your computer. It only searches the specific list of directories defined in the system's PATH variable.</li><li><strong>Security Feature</strong>: For security reasons, the current working directory (<code>.</code>) is not included in the PATH by default in PowerShell. This prevents you from accidentally running a malicious executable (e.g., a fake <code>ls.exe</code>) that might be present in a downloaded folder.</li></ul></p>
<p>#### The Fix: Explicit Path Resolution
<pre><code><h1>Wrong - relies on PATH search</h1>
PikaCmd.exe -compile ringmod_code.impala</p>
<h1>Correct - explicit path resolution</h1>
.\PikaCmd.exe -compile ringmod_code.impala</code></pre>
<strong>Why This Works</strong>: The <code>.</code> is an alias for the current directory location. By prefixing the executable with <code>.\</code>, you are providing a direct, unambiguous path to the file, telling the shell "Don't search the PATH; execute the file named PikaCmd.exe found right here." This bypasses the standard PATH search and satisfies the security policy.
<h3>Layer 2: Interpreter vs. Standalone Executable</h3>
<strong>The Error</strong> (after using the <code>.\</code> prefix):
<pre><code>!!!! Cannot open file for reading: 'compile'</code></pre>
<strong>Technical Reason</strong>: This error revealed the fundamental nature of PikaCmd.exe. It is not a monolithic compiler but a scripting language interpreter.
<p>#### Understanding Executable Types</p>
<strong>Standalone Executable</strong>: A standalone program (like a traditional C++ compiler) would have the "compile" logic built into its own machine code. It would parse <code>compile</code> as a command-line switch or flag.
<strong>Interpreter</strong>: An interpreter (like <code>python.exe</code>, <code>node.exe</code>, or <code>perl.exe</code>) is a generic program whose main purpose is to read, parse, and execute a script file that is provided to it as an argument.
<p>#### The Error's Meaning
When you ran <code>.\PikaCmd.exe compile ...</code>, you were instructing the Pika interpreter to find, open, and execute a script file literally named <code>compile</code> in the current directory. Since no such file existed, the interpreter's file-handling routine failed with the "Cannot open file for reading" error.</p>
<p>#### The Fix: Providing the Script
<pre><code><h1>Wrong - interpreter looks for script named "compile"</h1>
.\PikaCmd.exe compile ringmod_code.impala</p>
<h1>Correct - provides the actual script to execute</h1>
.\PikaCmd.exe impala.pika compile ringmod_code.impala</code></pre>
<strong>Why This Works</strong>: The solution was to provide the interpreter with the script it was meant to run: <code>impala.pika</code>. This file contains the actual Pika-language source code that defines the compiler's logic.
<h3>Layer 3: Script-Level Command-Line Argument Parsing</h3>
<p>With the interpreter now running the correct script, the final step was to provide arguments in the format that the script itself expected.</p>
<strong>Correct Command</strong>:
<pre><code>.\PikaCmd.exe impala.pika compile ringmod_code.impala ringmod_code.gazl</code></pre>
<strong>Technical Reason</strong>: The command-line shell tokenizes (splits) this input string by spaces. The PikaCmd.exe process receives an array of these tokens as its arguments (argv in C/C++ or accessible via a system library in Pika).
<p>#### Argument Flow Analysis
1. <strong>PikaCmd.exe</strong> (the interpreter) consumes the first argument, <code>impala.pika</code>, as the script to execute.
2. It then makes the remaining tokens available to the running <code>impala.pika</code> script.
3. Inside the <code>impala.pika</code> script, the logic looks for these arguments:</p>
<pre><code>if ($1 == 'compile') {
    // ...
    source = load($2); // Loads 'ringmod_code.impala'
    // ...
    if (exists(@$3)) { // Checks for the output file argument
        save($3, collected); // Saves to 'ringmod_code.gazl'
    }
    //...
}</code></pre>
<ul><li>The script checks its first argument (<code>$1</code>) to see if it's the string 'compile'. This matches.</li><li>It then uses its second argument (<code>$2</code>) as the input filename to load. This matches <code>ringmod_code.impala</code>.</li><li>It uses its third argument (<code>$3</code>) as the output filename to save to. This matches <code>ringmod_code.gazl</code>.</li></ul>
<p>The command succeeded because the arguments were provided in the precise sequence and format that the <code>impala.pika</code> script's internal parsing logic was written to handle.</p>
<h2>Chapter 2: Systematic Compilation Troubleshooting</h2>
<h3>Troubleshooting Flowchart</h3>
<pre><code>1. Command not recognized?
   ‚Üì
   Add .\ prefix: .\PikaCmd.exe
<p>2. "Cannot open file for reading" error?
   ‚Üì
   Add script file: .\PikaCmd.exe impala.pika</p>
<p>3. Script errors or unexpected behavior?
   ‚Üì
   Check argument order: .\PikaCmd.exe impala.pika compile input.impala output.gazl</p>
<p>4. Still failing?
   ‚Üì
   Check file permissions, syntax, and environment</code></pre></p>
<h3>Common Error Patterns and Solutions</h3>
<p>#### Error Pattern 1: Command Not Found
<strong>Symptoms</strong>:
<pre><code>'PikaCmd.exe' is not recognized as the name of a cmdlet, function, script file, or operable program.</code></pre></p>
<strong>Diagnosis</strong>: Shell cannot locate the executable
<strong>Solution</strong>: Use explicit path resolution with <code>.\</code>
<p>#### Error Pattern 2: File Reading Errors
<strong>Symptoms</strong>:
<pre><code>!!!! Cannot open file for reading: 'compile'
!!!! Cannot open file for reading: 'input.impala'</code></pre></p>
<strong>Diagnosis</strong>: 
<ul><li>First case: Missing script file argument</li><li>Second case: Missing or incorrect input file</li></ul>
<strong>Solutions</strong>:
<pre><code><h1>For missing script</h1>
.\PikaCmd.exe impala.pika compile input.impala output.gazl
<h1>For missing input file</h1>
<h1>Check file exists and path is correct</h1>
ls *.impala</code></pre>
<p>#### Error Pattern 3: Argument Order Issues
<strong>Symptoms</strong>:
<ul><li>Compilation appears to start but produces no output</li><li>Unexpected behavior or wrong files being processed</li></ul></p>
<strong>Diagnosis</strong>: Arguments provided in wrong order
<strong>Solution</strong>: Follow exact pattern: <code>script action input output</code>
<p>#### Error Pattern 4: Permission Errors
<strong>Symptoms</strong>:
<pre><code>Access denied
Permission denied
Cannot write to file</code></pre></p>
<strong>Diagnosis</strong>: File system permissions or read-only files
<strong>Solutions</strong>:
<pre><code><h1>Check file permissions</h1>
ls -la <em>.impala </em>.gazl
<h1>Make files writable if needed</h1>
chmod 644 <em>.impala </em>.gazl
<h1>Run as administrator if necessary (Windows)</h1></code></pre>
<h2>Chapter 3: Platform-Specific Considerations</h2>
<h3>Windows (PowerShell/Command Prompt)</h3>
<strong>Executable Resolution</strong>:
<pre><code><h1>PowerShell (requires .\ prefix)</h1>
.\PikaCmd.exe impala.pika compile input.impala output.gazl
<h1>Command Prompt (no prefix needed if in PATH)</h1>
PikaCmd.exe impala.pika compile input.impala output.gazl</code></pre>
<strong>Path Separators</strong>: Use backslashes or forward slashes
<pre><code>.\PikaCmd.exe impala.pika compile firmware\input.impala firmware\output.gazl
.\PikaCmd.exe impala.pika compile firmware/input.impala firmware/output.gazl</code></pre>
<h3>macOS/Linux (Bash/Zsh)</h3>
<strong>Executable Resolution</strong>:
<pre><code><h1>Requires ./ prefix for local executables</h1>
./PikaCmd.exe impala.pika compile input.impala output.gazl
<h1>Or add to PATH first</h1>
export PATH=$PATH:.
PikaCmd.exe impala.pika compile input.impala output.gazl</code></pre>
<strong>Case Sensitivity</strong>: File names are case-sensitive
<pre><code><h1>These are different files on Unix systems</h1>
input.impala
Input.impala
INPUT.IMPALA</code></pre>
<h2>Chapter 4: Advanced Compiler Usage</h2>
<h3>Complete Command Syntax</h3>
<pre><code>.\PikaCmd.exe <script> <action> [arguments...]
<h1>Where:</h1>
<h1><script>     - Always "impala.pika" for compilation</h1>
<h1><action>     - "compile" for standard compilation</h1>
<h1>[arguments]  - Input file, output file, and optional flags</h1></code></pre>
<h3>Advanced Compilation Options</h3>
<pre><code><h1>Basic compilation</h1>
.\PikaCmd.exe impala.pika compile input.impala output.gazl
<h1>Compilation with verbose output</h1>
.\PikaCmd.exe impala.pika compile input.impala output.gazl -verbose
<h1>Compilation with optimization</h1>
.\PikaCmd.exe impala.pika compile input.impala output.gazl -optimize
<h1>Debug compilation</h1>
.\PikaCmd.exe impala.pika compile input.impala output.gazl -debug</code></pre>
<h3>Batch Compilation</h3>
<pre><code><h1>Windows batch file example</h1>
@echo off
for %%f in (*.impala) do (
    echo Compiling %%f...
    .\PikaCmd.exe impala.pika compile "%%f" "%%~nf.gazl"
)</code></pre>
<pre><code><h1>Unix shell script example</h1>
#!/bin/bash
for file in *.impala; do
    echo "Compiling $file..."
    ./PikaCmd.exe impala.pika compile "$file" "${file%.impala}.gazl"
done</code></pre>
<h2>Chapter 5: Environment Setup and Verification</h2>
<h3>Verification Checklist</h3>
<pre><code><h1>1. Check files exist</h1>
ls -la PikaCmd.exe impala.pika
<h1>2. Check permissions</h1>
<h1>Windows: Right-click ‚Üí Properties ‚Üí Security</h1>
<h1>Unix: ls -la PikaCmd.exe impala.pika</h1>
<h1>3. Test basic execution</h1>
.\PikaCmd.exe impala.pika
<h1>4. Test with sample file</h1>
.\PikaCmd.exe impala.pika compile ringmod_code.impala ringmod_code.gazl</code></pre>
<h3>Development Environment Integration</h3>
<p>#### VS Code Integration
<pre><code>// .vscode/tasks.json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Compile Impala",
            "type": "shell",
            "command": ".\\PikaCmd.exe",
            "args": ["impala.pika", "compile", "${file}", "${fileDirname}\\${fileBasenameNoExtension}.gazl"],
            "group": "build",
            "presentation": {
                "echo": true,
                "reveal": "always",
                "focus": false,
                "panel": "shared"
            }
        }
    ]
}</code></pre></p>
<p>#### Automated Build Watching
<pre><code><h1>Watch for changes and auto-compile (requires inotify-tools on Linux)</h1>
while inotifywait -e modify *.impala; do
    for file in *.impala; do
        .\PikaCmd.exe impala.pika compile "$file" "${file%.impala}.gazl"
    done
done</code></pre></p>
<h2>Chapter 6: Professional Troubleshooting Methodology</h2>
<h3>Step-by-Step Diagnosis Process</h3>
<p>#### Step 1: Isolate the Problem Layer
1. <strong>Test shell execution</strong>: Can you run <code>.\PikaCmd.exe</code> at all?
2. <strong>Test interpreter</strong>: Does <code>.\PikaCmd.exe impala.pika</code> show help or error?
3. <strong>Test script logic</strong>: Does <code>.\PikaCmd.exe impala.pika compile</code> show specific errors?</p>
<p>#### Step 2: Gather Environment Information
<pre><code><h1>Check working directory</h1>
pwd</p>
<h1>List relevant files</h1>
ls -la <em>.exe </em>.pika *.impala
<h1>Check environment variables</h1>
echo $PATH  # Unix
echo %PATH% # Windows
<h1>Test with absolute paths</h1>
/full/path/to/PikaCmd.exe impala.pika compile input.impala output.gazl</code></pre>
<p>#### Step 3: Minimal Reproduction
<pre><code><h1>Create minimal test case</h1>
echo 'function process() { yield() }' > test.impala
.\PikaCmd.exe impala.pika compile test.impala test.gazl</p>
<h1>If this works, the issue is in your specific .impala file</h1>
<h1>If this fails, the issue is in your environment setup</h1></code></pre>
<p>#### Step 4: Systematic Resolution
1. <strong>Fix environment issues first</strong> (paths, permissions, file existence)
2. <strong>Fix command syntax second</strong> (argument order, script specification)
3. <strong>Fix source code issues last</strong> (syntax errors, logic problems)</p>
<h3>Documentation and Logging</h3>
<pre><code><h1>Create compilation log</h1>
.\PikaCmd.exe impala.pika compile input.impala output.gazl > compilation.log 2>&1
<h1>Save successful configurations</h1>
echo "Working command: .\PikaCmd.exe impala.pika compile input.impala output.gazl" > notes.txt</code></pre>
<h2>Chapter 7: Integration with Development Workflow</h2>
<h3>Professional Build Scripts</h3>
<pre><code>#!/bin/bash
<h1>build.sh - Professional Impala build script</h1>
<p>set -e  # Exit on any error</p>
<p>PIKACMD="./PikaCmd.exe"
SCRIPT="impala.pika"
ACTION="compile"</p>
<h1>Check prerequisites</h1>
if [ ! -f "$PIKACMD" ]; then
    echo "Error: PikaCmd.exe not found"
    exit 1
fi
<p>if [ ! -f "$SCRIPT" ]; then
    echo "Error: impala.pika not found"
    exit 1
fi</p>
<h1>Compile all .impala files</h1>
echo "Starting compilation..."
for file in *.impala; do
    if [ -f "$file" ]; then
        output="${file%.impala}.gazl"
        echo "Compiling: $file -> $output"
        
        if "$PIKACMD" "$SCRIPT" "$ACTION" "$file" "$output"; then
            echo "  ‚úì Success"
        else
            echo "  ‚úó Failed"
            exit 1
        fi
    fi
done
<p>echo "All files compiled successfully!"</code></pre></p>
<h3>Continuous Integration</h3>
<pre><code><h1>.github/workflows/build.yml</h1>
name: Build Firmware
on: [push, pull_request]
jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v2
      - name: Compile firmware
        run: |
          .\PikaCmd.exe impala.pika compile *.impala
      - name: Upload artifacts
        uses: actions/upload-artifact@v2
        with:
          name: compiled-firmware
          path: "*.gazl"</code></pre>
<h2>Summary and Quick Reference</h2>
<h3>Essential Commands</h3>
<pre><code><h1>Basic compilation</h1>
.\PikaCmd.exe impala.pika compile input.impala output.gazl
<h1>Troubleshooting sequence</h1>
1. .\PikaCmd.exe                    # Test executable
2. .\PikaCmd.exe impala.pika        # Test script loading
3. .\PikaCmd.exe impala.pika compile input.impala output.gazl  # Full compilation</code></pre>
<h3>Common Issues Quick Fix</h3>
| Problem | Solution |
|---------|----------|
| Command not recognized | Add <code>.\</code> prefix |
| Cannot open file 'compile' | Add <code>impala.pika</code> after executable |
| Wrong files processed | Check argument order |
| Permission denied | Check file permissions and admin rights |
| No output generated | Verify input file exists and syntax is correct |
<h3>Next Steps</h3>
<p>1. <strong>Practice Implementation</strong>: <a href="complete-development-workflow.md">Complete Development Workflow Tutorial</a>
   - Learn end-to-end development process with proper compilation integration</p>
<p>2. <strong>Debug Compilation Issues</strong>: <a href="debug-your-plugin.md">Debug Your Plugin Tutorial</a>
   - Learn systematic debugging when compilation succeeds but runtime fails</p>
<p>3. <strong>Professional Build Setup</strong>: <a href="../../assembly/gazl-integration-production.md">GAZL Integration Guide</a>
   - Set up automated build pipelines and professional development workflows</p>
<h3>Technical Architecture Reference</h3>
<p>You now understand that PikaCmd.exe compilation involves three distinct layers:
1. <strong>Shell Layer</strong>: Command resolution and executable location
2. <strong>Interpreter Layer</strong>: Script loading and execution environment
3. <strong>Script Layer</strong>: Argument parsing and compilation logic</p>
<p>This knowledge forms the foundation for professional firmware development and troubleshooting any compilation issues you may encounter.</p>
<p>---</p>
<em>Part of the Permut8 Firmware Development Tutorial Series</em>
</div>


<div class="file-section" id="complete-development-workflow">
    <div class="file-title">üìÑ Complete Development Workflow</div>
    <h1>Complete Development Workflow Tutorial</h1>
<strong>Master the end-to-end firmware development process</strong>
<p>This comprehensive tutorial walks you through the complete development workflow for Permut8 firmware, from initial concept to working plugin. You'll learn professional development practices, compilation processes, testing strategies, and debugging techniques that ensure reliable, high-quality firmware.</p>
<h2>What You'll Learn</h2>
<p>By the end of this tutorial, you'll master:
<ul><li>Complete development workflow from concept to deployment</li><li>Professional project organization and planning</li><li>Compilation process and build tools</li><li>Testing and validation strategies</li><li>Debugging techniques and troubleshooting</li><li>Performance optimization workflow</li><li>Version management and documentation</li></ul></p>
<strong>Prerequisites</strong>: 
<ul><li><a href="understanding-impala-fundamentals.md">Understanding Impala Language Fundamentals</a></li><li>Basic understanding of firmware architecture concepts</li></ul>
<strong>Time Required</strong>: 60-90 minutes  
<strong>Difficulty</strong>: Intermediate
<h2>Chapter 1: Development Workflow Overview</h2>
<h3>The Complete Development Cycle</h3>
<pre><code>graph TD
    A[Concept & Planning] --> B[Architecture Decision]
    B --> C[Implementation]
    C --> D[Compilation]
    D --> E[Testing]
    E --> F[Debugging]
    F --> G[Optimization]
    G --> H[Documentation]
    H --> I[Deployment]
    I --> J[Maintenance]
    
    F --> C
    E --> C
    G --> D</code></pre>
<h3>Professional Development Phases</h3>
<p>1. <strong>Concept & Planning</strong> (10-20% of time)
   - Define requirements and specifications
   - Research algorithms and techniques
   - Plan project structure and milestones</p>
<p>2. <strong>Architecture Decision</strong> (5-10% of time)
   - Choose Mod vs Full patch architecture
   - Design data flow and memory usage
   - Plan parameter mapping and UI</p>
<p>3. <strong>Implementation</strong> (40-50% of time)
   - Write core algorithms
   - Implement parameter handling
   - Add LED feedback and UI elements</p>
<p>4. <strong>Testing & Debugging</strong> (20-30% of time)
   - Validate functionality
   - Test edge cases and error conditions
   - Debug issues and optimize performance</p>
<p>5. <strong>Documentation & Deployment</strong> (10-15% of time)
   - Document usage and parameters
   - Create deployment packages
   - Plan updates and maintenance</p>
<h2>Chapter 2: Project Planning and Setup</h2>
<h3>Step 1: Define Your Project</h3>
<strong>Project Definition Template</strong>:
<pre><code>Project Name: _______________
Effect Type: ________________
Target Architecture: [ ] Mod Patch  [ ] Full Patch
Core Algorithm: _____________
Key Parameters: _____________
Performance Requirements: ___
Timeline: __________________</code></pre>
<strong>Example Project Definition</strong>:
<pre><code>Project Name: Vintage Tape Delay
Effect Type: Time-based delay with analog character
Target Architecture: [X] Full Patch (needs complete control)
Core Algorithm: Multi-tap delay with wow/flutter simulation
Key Parameters: Delay time, feedback, wow/flutter, tape age
Performance Requirements: <5% CPU, <50ms latency
Timeline: 2 weeks development + 1 week testing</code></pre>
<h3>Step 2: Research and Algorithm Selection</h3>
<strong>Research Checklist</strong>:
<ul><li>‚úÖ Study existing implementations</li><li>‚úÖ Review academic papers for advanced techniques</li><li>‚úÖ Analyze performance requirements</li><li>‚úÖ Identify key parameters and ranges</li><li>‚úÖ Plan memory requirements</li></ul>
<strong>Algorithm Research Template</strong>:
<pre><code>// === ALGORITHM RESEARCH NOTES ===
// Source: [Paper/Book/Website]
// Algorithm: [Name and description]
// Complexity: O(n) analysis
// Memory: [Requirements]
// Parameters: [List with ranges]
<p>// Basic algorithm outline:
function algorithmName(int input)
returns int output
{
    // Step 1: [Description]
    // Step 2: [Description] 
    // Step 3: [Description]
    return output
}</code></pre></p>
<h3>Step 3: Project Structure Planning</h3>
<strong>Recommended File Structure</strong>:
<pre><code>project-name/
‚îú‚îÄ‚îÄ project-name.impala          # Main source file
‚îú‚îÄ‚îÄ project-name-notes.md        # Development notes
‚îú‚îÄ‚îÄ project-name-test.impala     # Test cases
‚îú‚îÄ‚îÄ algorithm-research.md        # Research and references
‚îú‚îÄ‚îÄ parameter-mapping.md         # Parameter documentation
‚îî‚îÄ‚îÄ build-log.md                # Compilation and testing log</code></pre>
<strong>Source Code Organization</strong>:
<pre><code>// === PROJECT-NAME.IMPALA ===
// Author: [Your name]
// Date: [Creation date]
// Description: [Brief description]
// Version: 1.0
// Architecture: [Mod/Full] Patch
<p>// === CONSTANTS AND CONFIGURATION ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
// [Project-specific constants]</p>
<p>// === GLOBAL STATE ===
// [Required Permut8 globals]
// [Effect-specific globals]</p>
<p>// === ALGORITHM IMPLEMENTATION ===
// [Core processing functions]</p>
<p>// === PERMUT8 INTEGRATION ===
// [init, update, reset, process/operate functions]</code></pre></p>
<h2>Chapter 3: Implementation Best Practices</h2>
<h3>Step 1: Start with Minimal Working Version</h3>
<strong>Always begin with the simplest possible implementation</strong>:
<pre><code>// === MINIMAL WORKING DELAY (Version 0.1) ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>global array signal[2]
global array params[PARAM_COUNT]
global array displayLEDs[4]</p>
<p>// Minimal delay buffer
global array delayBuffer[22050]  // 0.5 second max
global int writePos = 0
global int readPos = 11025       // 0.25 second delay</p>
<p>function process()
locals int input, int delayed, int mixed
{
    loop {
        input = global signal[0]
        
        // Write to delay buffer
        global delayBuffer[global writePos] = input
        
        // Read delayed signal
        delayed = global delayBuffer[global readPos]
        
        // Simple 50/50 mix
        mixed = (input + delayed) / 2
        
        global signal[0] = mixed
        global signal[1] = mixed
        
        // Advance positions
        global writePos = (global writePos + 1) % 22050
        global readPos = (global readPos + 1) % 22050
        
        yield()
    }
}</code></pre></p>
<strong>Why Start Minimal</strong>:
<ul><li>‚úÖ Proves core concept works</li><li>‚úÖ Easier to debug basic functionality</li><li>‚úÖ Provides foundation for incremental improvement</li><li>‚úÖ Quick feedback on feasibility</li></ul>
<h3>Step 2: Add Features Incrementally</h3>
<strong>Feature Addition Order</strong>:
1. <strong>Core algorithm</strong> (working but basic)
2. <strong>Parameter control</strong> (make it adjustable)
3. <strong>Edge case handling</strong> (prevent crashes)
4. <strong>Performance optimization</strong> (make it efficient)
5. <strong>UI feedback</strong> (LEDs and visual response)
6. <strong>Advanced features</strong> (extra capabilities)
<strong>Example: Adding Parameter Control</strong>:
<pre><code>// Version 0.2: Add parameter control
global int delayTime = 11025     // Controllable delay time
global int feedback = 128        // Controllable feedback (0-255)
<p>function update()
{
    // Map delay time parameter (0-255 to 100-22050 samples)
    global delayTime = 100 + (global params[OPERAND_1_HIGH_PARAM_INDEX] * 21950 / 255)
    
    // Map feedback parameter (0-255 to 0-200% for interesting effects)
    global feedback = global params[OPERAND_1_LOW_PARAM_INDEX]
    
    // Update LED display
    global displayLEDs[0] = global params[OPERAND_1_HIGH_PARAM_INDEX]
}</p>
<p>function process()
locals int input, int delayed, int mixed, int feedbackSample
{
    loop {
        input = global signal[0]
        
        // Calculate read position based on delay time
        global readPos = global writePos - global delayTime
        if (global readPos < 0) global readPos = global readPos + 22050
        
        // Read delayed signal
        delayed = global delayBuffer[global readPos]
        
        // Apply feedback
        feedbackSample = delayed * global feedback / 255
        
        // Write input + feedback to buffer
        global delayBuffer[global writePos] = input + feedbackSample
        
        // Mix dry and wet
        mixed = (input <em> 128 + delayed </em> 128) / 255  // 50/50 mix
        
        global signal[0] = mixed
        global signal[1] = mixed
        
        global writePos = (global writePos + 1) % 22050
        yield()
    }
}</code></pre></p>
<h3>Step 3: Implement Error Handling</h3>
<strong>Critical Error Prevention</strong>:
<pre><code>// Safe parameter bounds checking
function update()
{
    // Ensure delay time is within valid range
    int delayParam = global params[OPERAND_1_HIGH_PARAM_INDEX]
    if (delayParam < 0) delayParam = 0
    if (delayParam > 255) delayParam = 255
    
    global delayTime = 100 + (delayParam * 21950 / 255)
    
    // Clamp delay time to buffer size
    if (global delayTime >= 22050) global delayTime = 22049
    if (global delayTime < 1) global delayTime = 1
}
<p>// Safe audio processing
function process()
locals int input, int output
{
    loop {
        input = global signal[0]
        
        // Clamp input to valid range
        if (input > 2047) input = 2047
        if (input < -2047) input = -2047
        
        output = processEffect(input)
        
        // Clamp output to valid range
        if (output > 2047) output = 2047
        if (output < -2047) output = -2047
        
        global signal[0] = output
        global signal[1] = output
        
        yield()
    }
}</code></pre></p>
<h2>Chapter 4: Compilation and Build Process</h2>
<h3>Step 1: Understanding the Build Tools</h3>
<strong>Compilation Command Structure</strong>:
<pre><code><h1>Standard compilation</h1>
PikaCmd.exe impala.pika compile source.impala output.gazl
<h1>If you get errors, use explicit path resolution</h1>
.\PikaCmd.exe impala.pika compile source.impala output.gazl</code></pre>
<strong>Understanding PikaCmd.exe Architecture</strong>:
PikaCmd.exe is actually a <strong>Pika language interpreter</strong>, not a standalone compiler. The compilation process involves three layers:
<p>1. <strong>Shell Layer</strong>: Command resolution (<code>.\</code> prefix may be required)
2. <strong>Interpreter Layer</strong>: PikaCmd.exe loads and executes <code>impala.pika</code> script
3. <strong>Script Layer</strong>: The <code>impala.pika</code> script performs the actual compilation logic</p>
<strong>Build Process Flow</strong>:
1. <strong>Source Code</strong> (.impala) ‚Üí <strong>Pika Interpreter</strong> ‚Üí <strong>GAZL Assembly</strong> (.gazl)
2. <strong>GAZL Assembly</strong> ‚Üí <strong>Permut8 Plugin</strong> ‚Üí <strong>Audio Output</strong>
<strong>For detailed troubleshooting</strong>: See <a href="compiler-troubleshooting-guide.md">Compiler Troubleshooting Guide</a>
<h3>Step 2: Compilation Workflow</h3>
<strong>Manual Compilation Process</strong>:
<pre><code><h1>1. Navigate to your project directory</h1>
cd "C:\Your\Project\Path"
<h1>2. Compile your source</h1>
PikaCmd.exe impala.pika compile project-name.impala project-name.gazl
<h1>3. Check for compilation errors</h1>
<h1>If successful, you'll see the .gazl file created</h1>
<h1>If you get "command not recognized", use .\PikaCmd.exe</h1>
<h1>If you get "Cannot open file for reading", ensure impala.pika is specified</h1></code></pre>
<strong>Automated Build Script</strong> (Windows batch file):
<pre><code>@echo off
echo Building Permut8 firmware...
<p>REM Set your project name
set PROJECT_NAME=my-effect</p>
<p>REM Compile
PikaCmd.exe impala.pika compile %PROJECT_NAME%.impala %PROJECT_NAME%.gazl</p>
<p>REM Check if compilation succeeded
if exist %PROJECT_NAME%.gazl (
    echo Build successful: %PROJECT_NAME%.gazl created
    echo File size: 
    dir %PROJECT_NAME%.gazl
) else (
    echo Build failed - check source code for errors
    pause
)</p>
<p>echo Build complete.
pause</code></pre></p>
<h3>Step 3: Handling Compilation Errors</h3>
<strong>Common Compilation Errors and Solutions</strong>:
<p>#### Syntax Errors
<pre><code>// ERROR: Missing semicolon (Impala doesn't use semicolons!)
int value = 42;  // WRONG</p>
<p>// CORRECT: No semicolons in Impala
int value = 42</code></pre></p>
<p>#### Type Errors
<pre><code>// ERROR: Undefined variable
function process()
{
    undefinedVar = 42  // WRONG - variable not declared
}</p>
<p>// CORRECT: Declare in locals or as global
function process()
locals int localVar
{
    localVar = 42
}</code></pre></p>
<p>#### Memory Errors
<pre><code>// ERROR: Array out of bounds
global array buffer[1024]
function process()
{
    buffer[1024] = 42  // WRONG - index 1024 is out of bounds (0-1023)
}</p>
<p>// CORRECT: Check bounds
function process()
locals int index
{
    index = 1023  // Last valid index
    buffer[index] = 42
}</code></pre></p>
<h3>Step 4: Build Optimization</h3>
<strong>Compilation Flags and Options</strong>:
<pre><code><h1>Basic compilation</h1>
PikaCmd.exe impala.pika compile source.impala output.gazl
<h1>With debug information (for development)</h1>
PikaCmd.exe impala.pika compile -debug source.impala output.gazl
<h1>Optimized build (for release)</h1>
PikaCmd.exe impala.pika compile -optimize source.impala output.gazl</code></pre>
<strong>Code Optimization for Compilation</strong>:
<pre><code>// SLOW: Repeated calculations in loop
function process()
{
    loop {
        int result = expensiveCalculation(global params[0])
        global signal[0] = result
        yield()
    }
}
<p>// FAST: Pre-calculate in update()
global int precalculatedValue = 0</p>
<p>function update()
{
    global precalculatedValue = expensiveCalculation(global params[0])
}</p>
<p>function process()
{
    loop {
        global signal[0] = global precalculatedValue  // Use pre-calculated value
        yield()
    }
}</code></pre></p>
<h2>Chapter 5: Testing Strategies</h2>
<h3>Step 1: Unit Testing Approach</h3>
<strong>Test Each Component Separately</strong>:
<pre><code>// === TEST HARNESS FOR ALGORITHM COMPONENTS ===
<p>// Test 1: Parameter scaling
function testParameterScaling()
{
    // Test boundary conditions
    trace("Testing parameter scaling...")
    
    int result1 = scaleParameter(0)      // Should be minimum
    int result2 = scaleParameter(255)    // Should be maximum
    int result3 = scaleParameter(128)    // Should be middle
    
    trace("Min: " + intToString(result1))
    trace("Max: " + intToString(result2))
    trace("Mid: " + intToString(result3))
}</p>
<p>// Test 2: Audio processing
function testAudioProcessing()
{
    trace("Testing audio processing...")
    
    // Test with known inputs
    int testInput1 = 1000    // Positive signal
    int testInput2 = -1000   // Negative signal
    int testInput3 = 0       // Zero signal
    
    int output1 = processAudio(testInput1)
    int output2 = processAudio(testInput2)
    int output3 = processAudio(testInput3)
    
    trace("Input 1000 -> " + intToString(output1))
    trace("Input -1000 -> " + intToString(output2))
    trace("Input 0 -> " + intToString(output3))
}</p>
<p>// Call tests in init()
function init()
{
    testParameterScaling()
    testAudioProcessing()
}</code></pre></p>
<h3>Step 2: Integration Testing</h3>
<strong>Test Complete Signal Chain</strong>:
<pre><code>// === INTEGRATION TEST SETUP ===
global int testPhase = 0
global int testResults[10]
<p>function runIntegrationTests()
{
    trace("Starting integration tests...")
    
    // Test 1: Silent input should produce silent output
    global signal[0] = 0
    global signal[1] = 0
    process()  // Run one iteration
    
    if (abs(global signal[0]) < 10) {
        trace("‚úì Silent input test passed")
        global testResults[0] = 1
    } else {
        trace("‚úó Silent input test failed")
        global testResults[0] = 0
    }
    
    // Test 2: Maximum input should not clip
    global signal[0] = 2047
    global signal[1] = 2047
    process()
    
    if (global signal[0] <= 2047 && global signal[0] >= -2047) {
        trace("‚úì Clipping test passed")
        global testResults[1] = 1
    } else {
        trace("‚úó Clipping test failed")
        global testResults[1] = 0
    }
    
    // Add more tests...
}</code></pre></p>
<h3>Step 3: Real-World Testing</h3>
<strong>Manual Testing Checklist</strong>:
<pre><code>‚ñ° Load firmware into Permut8
‚ñ° Test with various input sources (sine, noise, music)
‚ñ° Test all parameter ranges (0-255 for each knob)
‚ñ° Test parameter combinations
‚ñ° Test at different sample rates
‚ñ° Test for audio dropouts or glitches
‚ñ° Test LED response and visual feedback
‚ñ° Test reset and initialization
‚ñ° Test long-term stability (run for hours)
‚ñ° Test edge cases (silence, maximum levels)</code></pre>
<strong>Automated Testing Framework</strong>:
<pre><code>// === AUTOMATED TEST FRAMEWORK ===
global int currentTest = 0
global int testsPassed = 0
global int testsFailed = 0
<p>const int NUM_TESTS = 5</p>
<p>function runAllTests()
{
    trace("=== Starting Automated Tests ===")
    
    for (global currentTest = 0 to NUM_TESTS) {
        runTest(global currentTest)
    }
    
    trace("=== Test Results ===")
    trace("Passed: " + intToString(global testsPassed))
    trace("Failed: " + intToString(global testsFailed))
    
    if (global testsFailed == 0) {
        trace("‚úì All tests passed!")
    } else {
        trace("‚úó Some tests failed - check implementation")
    }
}</p>
<p>function runTest(int testNumber)
{
    trace("Running test " + intToString(testNumber))
    
    if (testNumber == 0) {
        if (testSilentInput()) global testsPassed = global testsPassed + 1
        else global testsFailed = global testsFailed + 1
    } else if (testNumber == 1) {
        if (testParameterBounds()) global testsPassed = global testsPassed + 1
        else global testsFailed = global testsFailed + 1
    }
    // Add more test cases...
}</code></pre></p>
<h2>Chapter 6: Debugging Techniques</h2>
<h3>Step 1: Using trace() for Debugging</h3>
<strong>Strategic trace() Placement</strong>:
<pre><code>function process()
locals int input, int output, int debugCounter
{
    loop {
        input = global signal[0]
        
        // Debug: Monitor input levels occasionally
        global debugCounter = global debugCounter + 1
        if ((global debugCounter % 1000) == 0) {
            trace("Input level: " + intToString(abs(input)))
        }
        
        output = processEffect(input)
        
        // Debug: Check for unexpected values
        if (abs(output) > 2047) {
            trace("WARNING: Output clipping! Value: " + intToString(output))
        }
        
        global signal[0] = output
        yield()
    }
}
<p>// Debug: Parameter monitoring
function update()
{
    trace("Params updated:")
    trace("  P1: " + intToString(global params[0]))
    trace("  P2: " + intToString(global params[1]))
    
    // Process parameters...
}</code></pre></p>
<h3>Step 2: State Monitoring</h3>
<strong>Monitor Critical State Variables</strong>:
<pre><code>global int debugMode = 1  // Set to 0 for release builds
<p>function debugPrintState()
{
    if (global debugMode == 0) return  // Skip in release
    
    trace("=== State Debug ===")
    trace("Phase: " + intToString(global oscillatorPhase))
    trace("Amplitude: " + intToString(global amplitude))
    trace("Filter cutoff: " + intToString(global cutoffFreq))
    trace("Buffer position: " + intToString(global bufferPos))
}</p>
<p>// Call debug function periodically
global int debugTimer = 0
function process()
{
    loop {
        // Your processing...
        
        // Debug every 10,000 samples (about 0.2 seconds at 44.1kHz)
        global debugTimer = global debugTimer + 1
        if ((global debugTimer % 10000) == 0) {
            debugPrintState()
        }
        
        yield()
    }
}</code></pre></p>
<h3>Step 3: Common Bug Patterns and Solutions</h3>
<strong>Bug Pattern 1: Buffer Overflow</strong>
<pre><code>// BUG: No bounds checking
global array buffer[1024]
global int position = 0
<p>function process()
{
    buffer[position] = global signal[0]  // Can overflow!
    position = position + 1
    yield()
}</p>
<p>// FIX: Always check bounds
function process()
{
    buffer[position] = global signal[0]
    position = (position + 1) % 1024  // Wrap around safely
    yield()
}</code></pre></p>
<strong>Bug Pattern 2: Uninitialized Variables</strong>
<pre><code>// BUG: Uninitialized state
global int filterState  // Could be any value!
<p>function process()
{
    int output = global signal[0] + global filterState  // Unpredictable!
    yield()
}</p>
<p>// FIX: Always initialize
global int filterState = 0  // Known starting value</code></pre></p>
<strong>Bug Pattern 3: Parameter Range Issues</strong>
<pre><code>// BUG: No parameter validation
function update()
{
    global frequency = global params[0] * 1000  // Could be huge!
}
<p>// FIX: Validate and clamp parameters
function update()
{
    int param = global params[0]
    if (param < 0) param = 0
    if (param > 255) param = 255
    global frequency = 20 + (param * 19980 / 255)  // 20Hz to 20kHz
}</code></pre></p>
<h3>Step 4: Performance Debugging</h3>
<strong>Monitor CPU Usage</strong>:
<pre><code>global int performanceTimer = 0
global int cycleCount = 0
<p>function process()
{
    int startTime = global clock
    
    // Your processing here
    processAudio()
    
    int endTime = global clock
    int processingTime = endTime - startTime
    
    global cycleCount = global cycleCount + 1
    if ((global cycleCount % 1000) == 0) {
        trace("Avg processing time: " + intToString(processingTime))
    }
    
    yield()
}</code></pre></p>
<h2>Chapter 7: Loading and Testing in Permut8</h2>
<h3>Step 1: Loading Firmware</h3>
<strong>Loading Process</strong>:
1. <strong>Compile</strong> your .impala file to .gazl
2. <strong>Open</strong> Permut8 plugin in your DAW
3. <strong>Create Firmware Bank</strong>: Package .gazl into .p8bank with presets
4. <strong>Load Bank</strong>: File ‚Üí Load Bank ‚Üí your-effect.p8bank
5. <strong>Select Preset</strong>: Choose A0-C9 program
6. <strong>Test</strong>: Verify firmware operation
<strong>Bank Creation Process</strong>:
<pre><code>your-effect.p8bank: {
    CurrentProgram: A0
    Programs: {
        A0: { Name: "Light Mode", Operator1: "1" }
        A1: { Name: "Heavy Mode", Operator1: "4" }
        A2: { Name: "Extreme", Operator1: "7" }
    }
    Firmware: {
        Name: "your_effect"
        Code: { /<em> compiled .gazl content </em>/ }
    }
}</code></pre>
<h3>Step 2: Interactive Testing</h3>
<strong>Testing Workflow in DAW</strong>:
<pre><code>1. Load a simple audio source (sine wave, white noise)
2. Insert Permut8 plugin on the audio track
3. Load your bank: File ‚Üí Load Bank ‚Üí your-effect.p8bank
4. Test each preset (A0, A1, A2, etc.)
5. Play audio and listen for your effect
6. Adjust knobs to test parameter response
7. Check LED display for visual feedback
8. Test different input sources and levels
9. Verify preset switching works smoothly
10. Test bank loading/unloading process</code></pre>
<strong>Parameter Testing Strategy</strong>:
<pre><code>For each knob (8 total):
1. Set to minimum (fully counter-clockwise)
2. Set to maximum (fully clockwise)
3. Set to center position
4. Sweep slowly through range while listening
5. Test combinations with other parameters
6. Note any unexpected behavior or audio issues</code></pre>
<h3>Step 3: Troubleshooting Common Issues</h3>
<strong>Issue: No Audio Output</strong>
<pre><code>Possible causes:
‚ñ° Forgot yield() in process() loop
‚ñ° Audio clipping due to excessive gain
‚ñ° Buffer overflow corrupting audio
‚ñ° Incorrect signal array usage
<p>Debug steps:
1. Check trace output for error messages
2. Verify process() function has loop + yield()
3. Test with simple pass-through code
4. Check input levels are reasonable</code></pre></p>
<strong>Issue: Audio Glitches or Dropouts</strong>
<pre><code>Possible causes:
‚ñ° Too much processing in one loop iteration
‚ñ° Memory access patterns causing delays
‚ñ° Infinite loops or missing yield()
‚ñ° Excessive trace() calls
<p>Debug steps:
1. Simplify algorithm to isolate issue
2. Remove trace() calls from process() loop
3. Check for memory bounds violations
4. Profile processing time per sample</code></pre></p>
<strong>Issue: Parameters Not Working</strong>
<pre><code>Possible causes:
‚ñ° Missing update() function
‚ñ° Incorrect parameter array indexing
‚ñ° Parameter scaling issues
‚ñ° Not reading from global params array
<p>Debug steps:
1. Add trace() to update() function
2. Verify parameter constants (OPERAND_1_HIGH_PARAM_INDEX, etc.)
3. Test parameter scaling with known values
4. Check LED display reflects parameter changes</code></pre></p>
<h2>Chapter 8: Performance Optimization</h2>
<h3>Step 1: Profiling and Measurement</h3>
<strong>Performance Measurement Framework</strong>:
<pre><code>global int profilingEnabled = 1
global int maxProcessingTime = 0
global int minProcessingTime = 999999
global int totalProcessingTime = 0
global int sampleCount = 0
<p>function profileStart()
returns int timestamp
{
    if (global profilingEnabled == 0) return 0
    return global clock
}</p>
<p>function profileEnd(int startTime)
{
    if (global profilingEnabled == 0 || startTime == 0) return
    
    int processingTime = global clock - startTime
    
    if (processingTime > global maxProcessingTime) {
        global maxProcessingTime = processingTime
    }
    if (processingTime < global minProcessingTime) {
        global minProcessingTime = processingTime
    }
    
    global totalProcessingTime = global totalProcessingTime + processingTime
    global sampleCount = global sampleCount + 1
    
    // Report every 10,000 samples
    if ((global sampleCount % 10000) == 0) {
        int avgTime = global totalProcessingTime / global sampleCount
        trace("Performance - Avg: " + intToString(avgTime) + 
              " Min: " + intToString(global minProcessingTime) +
              " Max: " + intToString(global maxProcessingTime))
    }
}</p>
<p>function process()
locals int startTime
{
    loop {
        startTime = profileStart()
        
        // Your audio processing here
        processYourEffect()
        
        profileEnd(startTime)
        yield()
    }
}</code></pre></p>
<h3>Step 2: Optimization Techniques</h3>
<strong>Memory Access Optimization</strong>:
<pre><code>// SLOW: Repeated global access
function process()
{
    loop {
        global signal[0] = processFilter(global signal[0], global filterCutoff, global filterQ)
        yield()
    }
}
<p>// FAST: Cache globals in locals
function process()
locals int input, int output, int cutoff, int q
{
    loop {
        // Cache global values
        input = global signal[0]
        cutoff = global filterCutoff
        q = global filterQ
        
        // Process with local variables
        output = processFilter(input, cutoff, q)
        
        global signal[0] = output
        yield()
    }
}</code></pre></p>
<strong>Arithmetic Optimization</strong>:
<pre><code>// SLOW: Division in inner loop
function process()
{
    loop {
        int scaled = global signal[0] * global amplitude / 1000  // Division is slow
        yield()
    }
}
<p>// FAST: Pre-calculate reciprocal in update()
global int amplitudeReciprocal = 65536 / 1000  // 16.16 fixed point</p>
<p>function update()
{
    global amplitudeReciprocal = 65536 / (global amplitude + 1)  // Avoid divide by zero
}</p>
<p>function process()
{
    loop {
        int scaled = (global signal[0] <em> global amplitude </em> global amplitudeReciprocal) >> 16
        yield()
    }
}</code></pre></p>
<strong>Loop Optimization</strong>:
<pre><code>// SLOW: Function calls in tight loops
function process()
{
    loop {
        for (i = 0 to 1023) {
            global buffer[i] = expensiveFunction(global buffer[i])  // Slow!
        }
        yield()
    }
}
<p>// FAST: Inline simple operations
function process()
locals int i, int temp
{
    loop {
        for (i = 0 to 1023) {
            temp = global buffer[i]
            temp = temp * 2  // Inline simple operations
            if (temp > 2047) temp = 2047
            global buffer[i] = temp
        }
        yield()
    }
}</code></pre></p>
<h3>Step 3: Memory Optimization</h3>
<strong>Efficient Buffer Management</strong>:
<pre><code>// INEFFICIENT: Multiple separate buffers
global array delayBuffer1[1024]
global array delayBuffer2[1024]
global array tempBuffer[1024]
<p>// EFFICIENT: Single buffer with offsets
global array masterBuffer[3072]  // Combined buffer
const int DELAY1_OFFSET = 0
const int DELAY2_OFFSET = 1024
const int TEMP_OFFSET = 2048</p>
<p>function accessDelay1(int index)
returns int value
{
    return global masterBuffer[DELAY1_OFFSET + index]
}</p>
<p>function setDelay1(int index, int value)
{
    global masterBuffer[DELAY1_OFFSET + index] = value
}</code></pre></p>
<h2>Chapter 9: Documentation and Version Management</h2>
<h3>Step 1: Code Documentation</h3>
<strong>Inline Documentation Standards</strong>:
<pre><code>// === VINTAGE DELAY EFFECT ===
// Author: [Your Name]
// Version: 1.2.3
// Date: 2025-01-06
// Description: Analog-style delay with tape saturation modeling
// Architecture: Full Patch
// CPU Usage: ~3.2% (measured at 44.1kHz)
// Memory Usage: 88KB delay buffer + 2KB state
<p>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2</p>
<p>// === ALGORITHM PARAMETERS ===
// Delay time: 50ms to 2000ms (mapped from knob 0-255)
// Feedback: 0% to 120% (mapped from knob 0-255)
// Tape age: 0% to 100% (controls saturation amount)
// Wow/flutter: 0% to 10% (tape speed variation)</p>
<p>// === GLOBAL STATE VARIABLES ===
global int delayTime = 22050        // Current delay time in samples
global int feedback = 128           // Feedback amount (0-255)
global int tapeAge = 64            // Tape saturation (0-255)
global int wowFlutter = 32         // Speed variation (0-255)</p>
<p>// === DELAY LINE MEMORY ===
global array delayBuffer[88200]    // 2 seconds max delay at 44.1kHz
global int writePosition = 0       // Current write position
global int readPosition = 22050    // Current read position (1 second back)</p>
<p>/<em></em>
 * Apply tape saturation modeling to audio signal
 * @param input: Audio sample (-2047 to +2047)
 * @param saturation: Saturation amount (0-255)
 * @return: Saturated audio sample
 */
function applyTapeSaturation(int input, int saturation)
returns int output
locals int scaled, int saturated
{
    // Scale input for saturation calculation
    scaled = input * saturation / 255
    
    // Simple tanh approximation for tape saturation
    if (scaled > 1500) {
        saturated = 1500 + (scaled - 1500) / 4  // Soft limiting
    } else if (scaled < -1500) {
        saturated = -1500 + (scaled + 1500) / 4
    } else {
        saturated = scaled
    }
    
    return saturated
}</code></pre></p>
<h3>Step 2: Version Management</h3>
<strong>Version Numbering System</strong>:
<pre><code>Format: MAJOR.MINOR.PATCH
Example: 1.2.3
<p>MAJOR: Incompatible changes (architecture change, complete rewrite)
MINOR: New features, significant improvements
PATCH: Bug fixes, small optimizations</p>
<p>Development stages:
0.x.x = Alpha (experimental, unstable)
1.x.x = Beta (feature complete, testing)
2.x.x = Release (stable, production ready)</code></pre></p>
<strong>Version History Documentation</strong>:
<pre><code>VERSION HISTORY
===============
<p>v1.2.3 (2025-01-06)
<ul><li>Fixed: Parameter smoothing glitch on rapid knob changes</li><li>Optimized: Reduced CPU usage by 15% through loop optimization</li><li>Added: Visual LED feedback for delay time</li></ul></p>
<p>v1.2.2 (2025-01-05)
<ul><li>Fixed: Buffer overflow when delay time set to maximum</li><li>Fixed: Audio dropout during parameter changes</li><li>Improved: Tape saturation algorithm accuracy</li></ul></p>
<p>v1.2.1 (2025-01-04)
<ul><li>Fixed: Compilation error on some systems</li><li>Updated: Documentation and code comments</li></ul></p>
<p>v1.2.0 (2025-01-03)
<ul><li>Added: Tape age parameter for vintage character</li><li>Added: Wow/flutter simulation</li><li>Improved: Feedback stability at high settings</li><li>Performance: 20% reduction in memory usage</li></ul></p>
<p>v1.1.0 (2025-01-01)
<ul><li>Added: Parameter smoothing to prevent clicks</li><li>Added: LED display feedback</li><li>Fixed: Feedback oscillation at maximum settings</li></ul></p>
<p>v1.0.0 (2024-12-30)
<ul><li>Initial release</li><li>Basic delay with time and feedback controls</code></pre></li></ul></p>
<h3>Step 3: User Documentation</h3>
<strong>User Manual Template</strong>:
<pre><code><h1>Effect Name v1.2.3</h1>
<h2>Description</h2>
Brief description of what the effect does and its intended use.
<h2>Parameters</h2>
<ul><li><strong>Knob 1 (Time)</strong>: Delay time from 50ms to 2 seconds</li><li><strong>Knob 2 (Feedback)</strong>: Feedback amount from 0% to 120%</li><li><strong>Knob 3 (Character)</strong>: Tape age simulation from new to vintage</li><li><strong>Knob 4 (Flutter)</strong>: Wow and flutter from stable to warped</li></ul>
<h2>LED Display</h2>
<ul><li><strong>LEDs 1-4</strong>: Show delay time as moving dot pattern</li><li><strong>LEDs 5-8</strong>: Show feedback level as bar graph</li></ul>
<h2>Usage Tips</h2>
<ul><li>Start with feedback around 50% for musical delays</li><li>Use character control to add vintage tape warmth</li><li>Flutter adds realism but use sparingly for musical applications</li></ul>
<h2>Technical Specifications</h2>
<ul><li><strong>CPU Usage</strong>: ~3.2% at 44.1kHz</li><li><strong>Latency</strong>: <1ms additional latency</li><li><strong>Memory</strong>: 88KB for delay buffer</li></ul>
<h2>Known Issues</h2>
<ul><li>None in current version</li></ul>
<h2>Version History</h2>
[Brief changelog]</code></pre>
<h2>Chapter 10: Deployment and Maintenance</h2>
<h3>Step 1: Release Preparation</h3>
<strong>Pre-Release Checklist</strong>:
<pre><code>Code Quality:
‚ñ° All functions documented
‚ñ° Code follows consistent style
‚ñ° No debug trace() calls in release build
‚ñ° Performance optimized
‚ñ° Memory usage verified
<p>Testing:
‚ñ° All unit tests pass
‚ñ° Integration tests complete
‚ñ° Manual testing on different audio sources
‚ñ° Long-term stability testing (24+ hours)
‚ñ° Parameter edge cases tested</p>
<p>Documentation:
‚ñ° User manual complete
‚ñ° Parameter descriptions accurate
‚ñ° Version history updated
‚ñ° Installation instructions clear</p>
<p>Build:
‚ñ° Clean compilation with no warnings
‚ñ° Final build optimized
‚ñ° File size reasonable
‚ñ° Verified on target hardware</code></pre></p>
<h3>Step 2: Distribution Package</h3>
<strong>Package Contents</strong>:
<pre><code>effect-name-v1.2.3/
‚îú‚îÄ‚îÄ effect-name.gazl           # Compiled firmware
‚îú‚îÄ‚îÄ README.md                  # Quick start guide
‚îú‚îÄ‚îÄ MANUAL.md                  # Complete user manual
‚îú‚îÄ‚îÄ CHANGELOG.md               # Version history
‚îú‚îÄ‚îÄ LICENSE.txt                # License information
‚îú‚îÄ‚îÄ source/
‚îÇ   ‚îú‚îÄ‚îÄ effect-name.impala     # Source code
‚îÇ   ‚îú‚îÄ‚îÄ build.bat             # Build script
‚îÇ   ‚îî‚îÄ‚îÄ test-cases.impala     # Test suite
‚îî‚îÄ‚îÄ examples/
    ‚îú‚îÄ‚îÄ basic-setup.md         # Usage examples
    ‚îî‚îÄ‚îÄ advanced-techniques.md # Advanced usage</code></pre>
<h3>Step 3: Maintenance and Updates</h3>
<strong>Bug Report Template</strong>:
<pre><code>BUG REPORT
==========
Effect: [Name and version]
System: [DAW, OS, Permut8 version]
Audio: [Sample rate, buffer size, input source]
<p>Description:
[Clear description of the issue]</p>
<p>Steps to Reproduce:
1. [Step by step instructions]
2. [Include parameter settings]
3. [Include audio characteristics]</p>
<p>Expected Behavior:
[What should happen]</p>
<p>Actual Behavior:
[What actually happens]</p>
<p>Additional Information:
[Any other relevant details]</code></pre></p>
<strong>Update Process</strong>:
1. <strong>Identify issue</strong> through user reports or testing
2. <strong>Reproduce issue</strong> in development environment
3. <strong>Fix implementation</strong> with minimal changes
4. <strong>Test fix</strong> thoroughly
5. <strong>Update version number</strong> (patch increment)
6. <strong>Update documentation</strong> and changelog
7. <strong>Build and test</strong> release package
8. <strong>Distribute update</strong> to users
<h3>Step 4: Long-term Evolution</h3>
<strong>Feature Request Evaluation</strong>:
<pre><code>Request: [Description of requested feature]
Impact: [High/Medium/Low user benefit]
Complexity: [High/Medium/Low implementation effort]
Compatibility: [Does it break existing patches?]
Performance: [CPU/memory impact]
Priority: [Must have/Nice to have/Future consideration]
<p>Decision: [Accept/Defer/Reject]
Reasoning: [Explanation of decision]
Timeline: [If accepted, when to implement]</code></pre></p>
<h2>Summary and Next Steps</h2>
<h3>Professional Development Workflow Summary</h3>
<p>1. <strong>Plan thoroughly</strong> before coding
2. <strong>Start simple</strong> and add features incrementally
3. <strong>Test continuously</strong> throughout development
4. <strong>Document everything</strong> for maintainability
5. <strong>Optimize systematically</strong> based on measurements
6. <strong>Release carefully</strong> with comprehensive testing</p>
<h3>Development Best Practices</h3>
<ul><li>‚úÖ Always compile and test after each change</li><li>‚úÖ Use version control for source code management</li><li>‚úÖ Write tests before implementing complex features</li><li>‚úÖ Profile performance regularly during development</li><li>‚úÖ Document decisions and trade-offs</li><li>‚úÖ Plan for maintenance and updates from the start</li></ul>
<h3>Next Steps in Your Development Journey</h3>
<p>1. <strong>Practice the Workflow</strong>: Apply this process to a simple project
   - Start with a basic gain/volume effect
   - Follow each step methodically
   - Document your experience</p>
<p>2. <strong>Study Advanced Techniques</strong>: <a href="../../assembly/gazl-assembly-introduction.md">Assembly Integration Guide</a>
   - Learn GAZL assembly for maximum performance
   - Advanced debugging and profiling techniques</p>
<p>3. <strong>Explore Complex Algorithms</strong>: Study cookbook recipes
   - <a href="../cookbook/spectral-processing/">Spectral Processing</a> for frequency domain work
   - <a href="../cookbook/audio-effects/">Audio Effects</a> for classic DSP algorithms</p>
<h3>Development Environment Setup</h3>
<strong>Recommended Tools</strong>:
<ul><li><strong>Text Editor</strong>: VS Code, Notepad++, or similar with syntax highlighting</li><li><strong>File Management</strong>: Organize projects in dedicated folders</li><li><strong>Build Automation</strong>: Create batch files for repetitive tasks</li><li><strong>Documentation</strong>: Markdown for user manuals and notes</li><li><strong>Testing</strong>: Audio files for consistent testing scenarios</li></ul>
<p>---</p>
<p>You now have a complete professional development workflow for Permut8 firmware. This systematic approach will help you create reliable, maintainable, and high-quality audio effects.</p>
<em>Part of the Permut8 Foundation Tutorial Series</em>
</div>


<div class="file-section" id="debug-your-plugin">
    <div class="file-title">üìÑ Debug Your Plugin</div>
    <h1>Debug Your Plugin - Complete Troubleshooting Guide</h1>
<h2>What This Tutorial Does</h2>
Learn systematic debugging techniques for Permut8 plugins. We'll create a deliberately broken plugin, then fix it step by step, teaching you how to identify and solve the most common problems.
<h2>Common Problems We'll Solve</h2>
<ul><li>Plugin won't compile</li><li>Plugin loads but no sound comes through</li><li>Plugin makes horrible noises</li><li>Controls don't work</li><li>LEDs don't respond</li><li>Performance issues and dropouts</li></ul>
<p>---</p>
<h2>Step 1: Create a Broken Plugin (On Purpose!)</h2>
<h3>1.1 The "Broken" Reverb</h3>
Create <code>broken_reverb.impala</code> with these deliberate mistakes:
<pre><code>// Broken Reverb - Full of Common Mistakes!
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>// Delay buffers for reverb
global array delayBuffer1[500]
global array delayBuffer2[750]
global array delayBuffer3[1000]
global int delayIndex = 0</p>
<p>// Missing global for output buffer!
// global array outputBuffer[2]</p>
<p>function process()
{
    loop {
        // BUG 1: Not reading parameters correctly
        int roomSize = params[3]    // Should be scaled
        int decay = params[4]       // Should be limited
        
        // BUG 2: Delay index not bounded
        delayIndex = delayIndex + 1  // Will overflow!
        
        // BUG 3: Array access without bounds checking
        int delay1 = delayBuffer1[delayIndex]
        int delay2 = delayBuffer2[delayIndex]  
        int delay3 = delayBuffer3[delayIndex]
        
        // BUG 4: Math that can overflow
        int reverb = delay1 <em> decay + delay2 </em> decay + delay3 * decay
        
        // BUG 5: Not storing new samples in delay buffers
        // (reverb will be silent after initial buffer contents are used)
        
        // BUG 6: Output without proper clipping
        signal[0] = signal[0] + reverb  // Can overflow
        signal[1] = signal[1] + reverb
        
        // BUG 7: Missing yield()!
    }
}</code></pre></p>
<h3>1.2 Try to Compile the Broken Plugin</h3>
1. Save the file and try: <code>PikaCmd.exe -compile broken_reverb.impala</code>
2. <strong>If you get "command not recognized"</strong>, try: <code>.\PikaCmd.exe impala.pika compile broken_reverb.impala broken_reverb.gazl</code>
3. <strong>You should get compilation errors!</strong> This is normal - we'll fix them step by step.
<strong>Note</strong>: If you're having basic compilation issues (command not found, file reading errors), see <a href="compiler-troubleshooting-guide.md">Compiler Troubleshooting Guide</a> first.
<p>---</p>
<h2>Step 2: Fix Compilation Errors</h2>
<h3>2.1 Read the Error Messages</h3>
When compilation fails, PikaCmd gives you specific error messages. Common ones:
<strong>Environment Errors</strong> (see <a href="compiler-troubleshooting-guide.md">Compiler Troubleshooting Guide</a>):
<ul><li><strong>"Command not recognized"</strong> - Use <code>.\PikaCmd.exe</code> instead</li><li><strong>"Cannot open file for reading"</strong> - Missing <code>impala.pika</code> in command</li></ul>
<strong>Code Errors</strong>:
<ul><li><strong>"Undefined variable"</strong> - You used a variable you didn't declare</li><li><strong>"Missing semicolon"</strong> - Forgot a semicolon somewhere</li><li><strong>"Unexpected token"</strong> - Syntax error (wrong brackets, etc.)</li><li><strong>"Array index out of bounds"</strong> - Tried to access an array element that doesn't exist</li></ul>
<h3>2.2 Fix the Missing yield()</h3>
The most common error: <strong>missing <code>yield()</code></strong>. Add it:
<pre><code>function process()
{
    loop {
        // ... all the same buggy code ...
        
        // BUG 7 FIX: Add missing yield()
        yield()
    }
}</code></pre>
<h3>2.3 Fix Syntax Errors</h3>
If you still get compilation errors, check these common issues:
<pre><code>// WRONG: Missing semicolon
int value = 42
int other = 24
<p>// RIGHT: Every statement needs semicolon
int value = 42;
int other = 24;</p>
<p>// WRONG: Mismatched brackets
if (condition {
    // code
}</p>
<p>// RIGHT: Matching brackets
if (condition) {
    // code
}</code></pre></p>
<h3>2.4 Compile Again</h3>
Fix any syntax errors and compile until you get <code>broken_reverb.gazl</code> successfully created.
<strong>Success!</strong> Compilation passed, but the plugin is still broken. Let's fix the runtime issues.
<p>---</p>
<h2>Step 3: Fix "No Sound" Problems</h2>
<h3>3.1 Load and Test</h3>
1. Load bank: File ‚Üí Load Bank ‚Üí <code>broken_reverb.p8bank</code>
2. Select A0 preset and test
3. <strong>Problem:</strong> No sound comes through, or very quiet sound
<h3>3.2 Debugging "No Sound" Issues</h3>
<strong>Check 1: Are you calling yield()?</strong>
<pre><code>// If you don't call yield(), the plugin hangs
function process() {
    loop {
        // ... processing code ...
        yield();  // MUST be here!
    }
}</code></pre>
<strong>Check 2: Are you preserving the signal?</strong>
<pre><code>// WRONG: This destroys the input signal
signal[0] = someEffect;
<p>// RIGHT: This adds effect to the original signal
signal[0] = signal[0] + someEffect;
// OR mix them:
signal[0] = (signal[0] <em> dryAmount + someEffect </em> wetAmount) / 255;</code></pre></p>
<strong>Check 3: Are you writing to both channels?</strong>
<pre><code>// WRONG: Only left channel has sound
signal[0] = processedAudio;
// signal[1] forgotten!
<p>// RIGHT: Both channels
signal[0] = processedAudio;
signal[1] = processedAudio;  // Same or different processing</code></pre></p>
<h3>3.3 Quick Fix for Our Broken Reverb</h3>
Replace the signal output lines:
<pre><code>// BUG 6 FIX: Proper mixing and clipping
int mixedLeft = signal[0] + (reverb / 4);    // Reduce reverb level
int mixedRight = signal[1] + (reverb / 4);
<p>// Clip to prevent overflow
if (mixedLeft > 2047) mixedLeft = 2047;
else if (mixedLeft < -2047) mixedLeft = -2047;
if (mixedRight > 2047) mixedRight = 2047;
else if (mixedRight < -2047) mixedRight = -2047;</p>
<p>signal[0] = mixedLeft;
signal[1] = mixedRight;</code></pre></p>
<p>---</p>
<h2>Step 4: Fix Array Access Crashes</h2>
<h3>4.1 The Problem: Array Bounds</h3>
Our broken reverb will crash because <code>delayIndex</code> grows without limit and accesses memory outside the arrays.
<h3>4.2 Debug Array Access</h3>
<strong>Always wrap array indices:</strong>
<pre><code>// WRONG: Index grows forever
delayIndex = delayIndex + 1;
int sample = delayBuffer1[delayIndex];  // CRASH when delayIndex > 499
<p>// RIGHT: Wrap index to array size
delayIndex = (delayIndex + 1) % 500;    // Always stays 0-499
int sample = delayBuffer1[delayIndex];  // Safe</code></pre></p>
<h3>4.3 Fix Our Reverb's Array Access</h3>
Replace the delay buffer access:
<pre><code>// BUG 2 FIX: Properly wrap delay index
delayIndex = (delayIndex + 1) % 500;    // Keep in bounds
<p>// BUG 3 FIX: Safe array access with different indices
int delay1 = delayBuffer1[delayIndex];
int delay2 = delayBuffer2[delayIndex % 750];   // Wrap to buffer 2 size
int delay3 = delayBuffer3[delayIndex % 1000];  // Wrap to buffer 3 size</code></pre></p>
<h3>4.4 General Array Safety Rules</h3>
<pre><code>// ALWAYS check array bounds
if (index < 0) index = 0;
if (index >= arraySize) index = arraySize - 1;
<p>// OR use modulo for circular access
index = index % arraySize;</p>
<p>// OR use safe accessor functions
int safeRead(array buffer[], int size, int index) {
    return buffer[index % size];
}</code></pre></p>
<p>---</p>
<h2>Step 5: Fix Math Overflow Issues</h2>
<h3>5.1 The Problem: Integer Overflow</h3>
Audio calculations can easily overflow Impala's integer range, causing distortion or wrapping.
<h3>5.2 Identify Overflow Sources</h3>
<pre><code>// DANGEROUS: Can overflow easily
int result = bigValue1 * bigValue2;
<p>// SAFER: Scale before multiplying
int result = (bigValue1 / 2) * (bigValue2 / 2);</p>
<p>// SAFEST: Check ranges
int result = bigValue1 * bigValue2;
if (result > 2047) result = 2047;
else if (result < -2047) result = -2047;</code></pre></p>
<h3>5.3 Fix Our Reverb's Math</h3>
Replace the reverb calculation:
<pre><code>// BUG 4 FIX: Prevent overflow in math
// Scale decay parameter to safe range
int safeDecay = decay / 4;  // Limit multiplier
<p>// Safe reverb calculation with scaling
int reverb = ((delay1 <em> safeDecay) + (delay2 </em> safeDecay) + (delay3 * safeDecay)) / 255;</p>
<p>// Additional safety clipping
if (reverb > 1000) reverb = 1000;
else if (reverb < -1000) reverb = -1000;</code></pre></p>
<p>---</p>
<h2>Step 6: Fix Missing Functionality</h2>
<h3>6.1 The Problem: Silent Effect</h3>
Our reverb will go silent quickly because we're not feeding new audio into the delay buffers.
<h3>6.2 Debug Missing Functionality</h3>
<strong>Always ask: "Where does the processed audio come from?"</strong>
<p>For reverb:
1. New audio goes into delay buffers
2. Old audio comes out of delay buffers  
3. Multiple delay buffers create reverb effect</p>
<h3>6.3 Fix Our Reverb's Missing Input</h3>
Add after reading the delay buffers:
<pre><code>// BUG 5 FIX: Store new audio in delay buffers
delayBuffer1[delayIndex] = signal[0] + (delay2 / 8);        // Input + some feedback
delayBuffer2[delayIndex % 750] = signal[0] + (delay3 / 8);  // Different mixing
delayBuffer3[delayIndex % 1000] = signal[0] + (delay1 / 8); // Create reverb network</code></pre>
<h3>6.4 General Debugging Questions</h3>
<ul><li><strong>Where does processed audio come from?</strong></li><li><strong>Is the effect state being updated each sample?</strong></li><li><strong>Are feedback paths connected correctly?</strong></li><li><strong>Is the algorithm actually doing what you think it does?</strong></li></ul>
<p>---</p>
<h2>Step 7: Fix Parameter Issues</h2>
<h3>7.1 The Problem: Raw Parameter Values</h3>
Parameters come in as 0-255 but need to be scaled for different uses.
<h3>7.2 Debug Parameter Scaling</h3>
<pre><code>// WRONG: Raw parameter value
int feedback = params[4];           // 0-255, often too much
effect = input * feedback;          // Huge multiplication!
<p>// RIGHT: Scale to useful range
int feedback = params[4] / 4;       // 0-63, safer range
effect = (input * feedback) / 64;  // Controlled multiplication</code></pre></p>
<h3>7.3 Fix Our Reverb's Parameters</h3>
Replace the parameter reading:
<pre><code>// BUG 1 FIX: Properly scale parameters
int roomSize = params[3] / 2;       // 0-127 range
int decay = params[4] / 4;          // 0-63 range for safety</code></pre>
<p>---</p>
<h2>Step 8: Complete Fixed Version</h2>
<h3>8.1 The Corrected Reverb</h3>
Here's our reverb with all bugs fixed:
<pre><code>// Fixed Reverb - All Problems Solved!
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>global array delayBuffer1[500]
global array delayBuffer2[750]
global array delayBuffer3[1000]
global int delayIndex = 0</p>
<p>function process()
{
    loop {
        // FIX 1: Properly scale parameters
        int roomSize = params[3] / 2;       // 0-127 range
        int decay = params[4] / 4;          // 0-63 range for safety
        
        // FIX 2: Bound delay index  
        delayIndex = (delayIndex + 1) % 500;
        
        // FIX 3: Safe array access with proper indices
        int delay1 = delayBuffer1[delayIndex];
        int delay2 = delayBuffer2[delayIndex % 750];
        int delay3 = delayBuffer3[delayIndex % 1000];
        
        // FIX 5: Store new audio in delay buffers (reverb network)
        delayBuffer1[delayIndex] = signal[0] + (delay2 * decay / 255);
        delayBuffer2[delayIndex % 750] = signal[0] + (delay3 * decay / 255);
        delayBuffer3[delayIndex % 1000] = signal[0] + (delay1 * decay / 255);
        
        // FIX 4: Safe reverb calculation  
        int reverb = ((delay1 + delay2 + delay3) * roomSize) / 255;
        
        // Additional safety clipping
        if (reverb > 1000) reverb = 1000;
        else if (reverb < -1000) reverb = -1000;
        
        // FIX 6: Proper mixing and clipping
        int mixedLeft = signal[0] + (reverb / 4);
        int mixedRight = signal[1] + (reverb / 4);
        
        if (mixedLeft > 2047) mixedLeft = 2047;
        else if (mixedLeft < -2047) mixedLeft = -2047;
        if (mixedRight > 2047) mixedRight = 2047;
        else if (mixedRight < -2047) mixedRight = -2047;
        
        signal[0] = mixedLeft;
        signal[1] = mixedRight;
        
        // LED feedback for debugging
        displayLEDs[0] = (reverb > 100 || reverb < -100) ? 0xFF : 0x01;
        
        // FIX 7: Always call yield()
        yield();
    }
}</code></pre></p>
<h3>8.2 Test the Fixed Version</h3>
1. Compile: <code>PikaCmd.exe -compile broken_reverb.impala</code>
2. Create and load bank: File ‚Üí Load Bank ‚Üí <code>broken_reverb.p8bank</code>
3. Select A0 preset
4. <strong>Should work now!</strong> Try both knobs to control room size and decay.
<p>---</p>
<h2>Step 9: Systematic Debugging Process</h2>
<h3>9.1 The Debug Checklist</h3>
When your plugin doesn't work, follow this order:
<strong>1. Compilation Issues:</strong>
<ul><li>[ ] Missing semicolons?</li><li>[ ] Bracket mismatches?</li><li>[ ] Undefined variables?</li><li>[ ] Correct function signatures?</li></ul>
<strong>2. No Sound Issues:</strong>
<ul><li>[ ] Is <code>yield()</code> called in the main loop?</li><li>[ ] Are you writing to <code>signal[0]</code> and <code>signal[1]</code>?</li><li>[ ] Are you preserving input audio?</li><li>[ ] Is the effect level reasonable?</li></ul>
<strong>3. Crash/Noise Issues:</strong>
<ul><li>[ ] Array bounds checking?</li><li>[ ] Math overflow protection?</li><li>[ ] Parameter scaling?</li><li>[ ] Initialization of variables?</li></ul>
<strong>4. Control Issues:</strong>
<ul><li>[ ] Reading correct parameter indices?</li><li>[ ] Scaling parameters to useful ranges?</li><li>[ ] LED feedback working?</li></ul>
<h3>9.2 Debug by Elimination</h3>
<strong>Start Simple:</strong>
<pre><code>// Test 1: Just pass audio through
signal[0] = signal[0];
signal[1] = signal[1];
yield();
// If this doesn't work, you have basic setup issues
<p>// Test 2: Add simple effect
signal[0] = signal[0] / 2;  // Half volume
signal[1] = signal[1] / 2;
yield();
// If this works, your effect processing has the problem</p>
<p>// Test 3: Add one parameter
int volume = params[3] / 2;
signal[0] = (signal[0] * volume) / 128;
signal[1] = (signal[1] * volume) / 128;
yield();
// If this works, parameter scaling is correct</code></pre></p>
<strong>Build Up Complexity Gradually:</strong>
1. Get basic audio passing through
2. Add simple effect  
3. Add first parameter
4. Add more parameters
5. Add LED feedback
6. Add advanced features
<h3>9.3 Common Debugging Tricks</h3>
<strong>Use LEDs for Debugging:</strong>
<pre><code>// Show parameter values
displayLEDs[0] = params[3];
<p>// Show if processing is happening
displayLEDs[1] = (signal[0] > 100) ? 0xFF : 0x00;</p>
<p>// Show internal state
displayLEDs[2] = internalVariable % 256;</code></pre></p>
<strong>Add Safety Everywhere:</strong>
<pre><code>// Clip all audio outputs
if (output > 2047) output = 2047;
else if (output < -2047) output = -2047;
<p>// Bound all array access
index = index % arraySize;</p>
<p>// Scale all parameters
param = params[3] / scaleFactor;</code></pre></p>
<p>---</p>
<h2>Step 10: Performance Debugging</h2>
<h3>10.1 Identify Performance Problems</h3>
<strong>Symptoms:</strong>
<ul><li>Audio dropouts or stuttering</li><li>Plugin causes DAW to slow down</li><li>Clicks and pops in audio</li></ul>
<h3>10.2 Common Performance Issues</h3>
<strong>Too Much Math:</strong>
<pre><code>// SLOW: Complex math every sample
int result = sqrt(value1 <em> value1 + value2 </em> value2);
<p>// FAST: Approximate or use lookup tables
int result = fastApproximateDistance(value1, value2);</code></pre></p>
<strong>Large Array Operations:</strong>
<pre><code>// SLOW: Processing huge arrays every sample
for (int i = 0; i < 10000; i++) {
    bigArray[i] = bigArray[i] * 2;
}
<p>// FAST: Process smaller chunks or fewer operations</code></pre></p>
<strong>Unnecessary Calculations:</strong>
<pre><code>// SLOW: Recalculating constants
int coefficient = (params[3] * 3.14159) / 255;  // Every sample!
<p>// FAST: Calculate only when parameter changes
static int lastParam = -1;
static int coefficient = 0;
if (params[3] != lastParam) {
    coefficient = (params[3] * 314) / 255;  // Use integer approximation
    lastParam = params[3];
}</code></pre></p>
<h3>10.3 Performance Optimization Tips</h3>
<ul><li><strong>Use integer math</strong> instead of floating point</li><li><strong>Pre-calculate lookup tables</strong> for complex functions</li><li><strong>Only update when parameters change</strong></li><li><strong>Limit array sizes</strong> to what you actually need</li><li><strong>Use bit shifts</strong> instead of multiplication by powers of 2</li></ul>
<p>---</p>
<h2>Quick Reference: Problem ‚Üí Solution</h2>
<p>| Problem | Likely Cause | Quick Fix |
|---------|--------------|-----------|
| <strong>Won't compile</strong> | Syntax error | Check semicolons, brackets, variable names |
| <strong>No sound</strong> | Missing <code>yield()</code> or not writing to <code>signal[]</code> | Add <code>yield()</code>, write to both channels |
| <strong>Distorted/noisy</strong> | Math overflow | Add clipping, scale parameters |
| <strong>Crashes</strong> | Array bounds | Use modulo <code>%</code> for array access |
| <strong>Controls don't work</strong> | Parameter scaling | Scale <code>params[]</code> to useful ranges |
| <strong>LEDs don't work</strong> | Wrong values | Ensure LED values are 0-255 |
| <strong>Performance issues</strong> | Too much computation | Optimize math, use lookup tables |</p>
<h2>You're Now a Plugin Debugging Expert!</h2>
<p>You learned:
<ul><li>‚úÖ <strong>Systematic debugging process</strong> from compilation to performance</li><li>‚úÖ <strong>Most common mistakes</strong> and how to avoid them</li><li>‚úÖ <strong>Safety patterns</strong> for robust plugin development</li><li>‚úÖ <strong>Performance optimization</strong> techniques</li><li>‚úÖ <strong>Debug-by-elimination</strong> methodology</li></ul></p>
<strong>These skills apply to ANY plugin you build!</strong> Follow the checklist, build complexity gradually, and use LEDs for debugging feedback.
</div>


<div class="file-section" id="mod-vs-full-architecture-guide">
    <div class="file-title">üìÑ Mod Vs Full Architecture Guide</div>
    <h1>Mod vs Full Patch Architecture Decision Guide</h1>
<strong>Choose the right firmware architecture for your project</strong>
<p>One of the most important decisions in Permut8 firmware development is choosing between <strong>Mod patches</strong> and <strong>Full patches</strong>. This choice affects everything from development complexity to performance characteristics. This guide will help you make the right architectural decision for your specific project.</p>
<h2>What You'll Learn</h2>
<p>By the end of this guide, you'll understand:
<ul><li>The fundamental differences between Mod and Full patches</li><li>When to choose each architecture type</li><li>Trade-offs and limitations of each approach</li><li>How to implement each type correctly</li><li>Migration strategies between architectures</li></ul></p>
<strong>Prerequisites</strong>: <a href="understanding-impala-fundamentals.md">Understanding Impala Language Fundamentals</a>  
<strong>Time Required</strong>: 30-45 minutes  
<strong>Difficulty</strong>: Beginner to Intermediate
<h2>Chapter 1: Understanding the Two Architectures</h2>
<h3>Full Patches: Complete Audio Processing Chain</h3>
<strong>Full patches</strong> replace Permut8's entire audio processing chain with your custom code.
<pre><code>// === FULL PATCH EXAMPLE ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>// Required globals for Full patches
global array signal[2]          // Direct audio I/O
global array params[PARAM_COUNT]
global array displayLEDs[4]</p>
<p>function process()
{
    loop {
        // YOU control the entire audio path
        int inputLeft = global signal[0]    // Raw input
        int inputRight = global signal[1]
        
        // Your complete effect processing
        int outputLeft = processMyEffect(inputLeft)
        int outputRight = processMyEffect(inputRight)
        
        // Direct output to hardware
        global signal[0] = outputLeft
        global signal[1] = outputRight
        
        yield()
    }
}</code></pre></p>
<strong>Key Characteristics</strong>:
<ul><li><strong>Complete control</strong> over audio processing</li><li><strong>Direct hardware access</strong> to audio inputs/outputs</li><li><strong>No Permut8 built-in effects</strong> - you implement everything</li><li><strong>Higher complexity</strong> but maximum flexibility</li></ul>
<h3>Mod Patches: Operator Replacement</h3>
<strong>Mod patches</strong> replace one or both of Permut8's built-in operators while keeping the rest of the processing chain intact.
<pre><code>// === MOD PATCH EXAMPLE ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>// Required globals for Mod patches  
global array positions[2]       // Memory position I/O
global array params[PARAM_COUNT]
global array displayLEDs[4]</p>
<p>// Replace Operator 1 with custom processing
function operate1()
returns int processed
locals array inputSamples[2], array outputSamples[2]
{
    // Read from memory positions
    read(global positions[0], 1, inputSamples)
    
    // Your operator processing
    outputSamples[0] = processMyOperator(inputSamples[0])
    outputSamples[1] = inputSamples[1]  // Pass through right channel
    
    // Write back to memory
    write(global positions[0], 1, outputSamples)
    
    return 1  // Indicate we processed the audio
}</p>
<p>// Optionally replace Operator 2 as well
function operate2()
returns int processed
{
    // Similar processing for second operator
    return 1
}</code></pre></p>
<strong>Key Characteristics</strong>:
<ul><li><strong>Integrates with Permut8's chain</strong> - delay, feedback, etc. still work</li><li><strong>Memory-based I/O</strong> instead of direct audio</li><li><strong>Lower complexity</strong> - focus on your specific operator</li><li><strong>Limited scope</strong> but easier development</li></ul>
<h2>Chapter 2: Decision Matrix</h2>
<h3>Choose Full Patch When:</h3>
<p>#### ‚úÖ <strong>Complete Effect Replacement</strong>
<pre><code>// Example: Custom reverb that needs total control
function process()
{
    loop {
        // Complex reverb algorithm needs entire audio path
        int wet = calculateReverb(global signal[0])
        int dry = global signal[0] * dryLevel / 1000
        global signal[0] = wet + dry
        yield()
    }
}</code></pre></p>
<strong>Use Cases</strong>:
<ul><li>Reverbs, delays, and time-based effects</li><li>Multi-band processors (EQ, compressor)</li><li>Synthesizers and tone generators</li><li>Complex routing and mixing</li><li>Spectral processing (FFT-based effects)</li></ul>
<p>#### ‚úÖ <strong>Performance-Critical Applications</strong>
<pre><code>// Direct audio access = lowest latency
function process()
{
    loop {
        // No memory read/write overhead
        global signal[0] = fastProcessing(global signal[0])
        yield()
    }
}</code></pre></p>
<p>#### ‚úÖ <strong>Hardware Integration Focus</strong>
<pre><code>// Direct control over audio hardware
function process()
{
    loop {
        // Custom sample rate handling
        // Direct LED control synchronized with audio
        // Custom clock domain management
        yield()
    }
}</code></pre></p>
<h3>Choose Mod Patch When:</h3>
<p>#### ‚úÖ <strong>Operator-Style Effects</strong>
<pre><code>// Example: Bitcrusher that fits perfectly as an operator
function operate1()
returns int processed
locals array samples[2], int crushed
{
    read(global positions[0], 1, samples)
    
    // Bitcrush processing
    crushed = samples[0] & crushMask  // Simple bit reduction
    samples[0] = crushed
    
    write(global positions[0], 1, samples)
    return 1
}</code></pre></p>
<strong>Use Cases</strong>:
<ul><li>Distortion and waveshaping</li><li>Bit manipulation effects</li><li>Simple filters and EQ</li><li>Amplitude modulation</li><li>Ring modulation</li></ul>
<p>#### ‚úÖ <strong>Integration with Permut8 Features</strong>
<pre><code>// Your operator + Permut8's delay/feedback = complex result
function operate1()
returns int processed
{
    // Your processing gets automatic:
    // - Delay line integration
    // - Feedback control
    // - Clock synchronization
    // - Parameter mapping
    return 1
}</code></pre></p>
<p>#### ‚úÖ <strong>Rapid Prototyping</strong>
<pre><code>// Quick idea testing - minimal boilerplate
function operate1()
returns int processed
locals array samples[2]
{
    read(global positions[0], 1, samples)
    samples[0] = experimentalProcess(samples[0])  // Test your idea
    write(global positions[0], 1, samples)
    return 1
}</code></pre></p>
<h2>Chapter 3: Detailed Comparison</h2>
<h3>Development Complexity</h3>
<p>| Aspect | Full Patch | Mod Patch |
|--------|------------|-----------|
| <strong>Boilerplate Code</strong> | Moderate | Minimal |
| <strong>Audio I/O</strong> | Direct <code>signal[]</code> access | Memory <code>read()</code>/<code>write()</code> |
| <strong>Parameter Handling</strong> | Manual mapping | Automatic integration |
| <strong>LED Control</strong> | Manual implementation | Automatic integration |
| <strong>Clock/Timing</strong> | Manual management | Automatic synchronization |
| <strong>Error Handling</strong> | Your responsibility | Permut8 handles framework |</p>
<h3>Performance Characteristics</h3>
<p>| Aspect | Full Patch | Mod Patch |
|--------|------------|-----------|
| <strong>Latency</strong> | Lowest (direct audio) | Slightly higher (memory access) |
| <strong>CPU Usage</strong> | Your algorithm only | Your algorithm + framework |
| <strong>Memory Access</strong> | Direct signal arrays | Memory read/write operations |
| <strong>Real-time Safety</strong> | Your responsibility | Framework assistance |</p>
<h3>Feature Integration</h3>
<p>| Feature | Full Patch | Mod Patch |
|---------|------------|-----------|
| <strong>Delay Lines</strong> | Manual implementation | Automatic integration |
| <strong>Feedback</strong> | Manual routing | Built-in feedback paths |
| <strong>Parameter Smoothing</strong> | Manual implementation | Framework handles |
| <strong>Preset System</strong> | Manual state management | Automatic state handling |
| <strong>MIDI Integration</strong> | Manual implementation | Framework integration |</p>
<h2>Chapter 4: Implementation Patterns</h2>
<h3>Full Patch Implementation Pattern</h3>
<pre><code>// === COMPLETE FULL PATCH TEMPLATE ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>// Required globals
global array signal[2]
global array params[PARAM_COUNT]
global array displayLEDs[4]
global int clock</p>
<p>// Your effect state
global int effectState = 0
global array effectMemory[1024]</p>
<p>// Optional: Initialize your effect
function init()
{
    global effectState = 0
    // Initialize effect memory, lookup tables, etc.
}</p>
<p>// Optional: Handle parameter changes
function update()
{
    // Map params[0-7] to your effect parameters
    // Update LED displays
    // Recalculate coefficients, etc.
}</p>
<p>// Optional: Handle reset
function reset()
{
    global effectState = 0
    // Reset effect to initial state
}</p>
<p>// Required: Main audio processing
function process()
locals int inputL, int inputR, int outputL, int outputR
{
    loop {
        // Get input
        inputL = global signal[0]
        inputR = global signal[1]
        
        // Your effect processing
        outputL = processEffect(inputL, 0)  // Left channel
        outputR = processEffect(inputR, 1)  // Right channel
        
        // Set output
        global signal[0] = outputL
        global signal[1] = outputR
        
        yield()
    }
}</p>
<p>// Your effect implementation
function processEffect(int input, int channel)
returns int output
{
    // Your algorithm here
    output = input  // Placeholder
}</code></pre></p>
<h3>Mod Patch Implementation Pattern</h3>
<pre><code>// === COMPLETE MOD PATCH TEMPLATE ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>// Required globals for Mod patches
global array positions[2]
global array params[PARAM_COUNT]
global array displayLEDs[4]</p>
<p>// Your operator state
global int operatorState = 0</p>
<p>// Optional: Initialize
function init()
{
    global operatorState = 0
}</p>
<p>// Optional: Handle parameter changes
function update()
{
    // Parameters automatically mapped by framework
    // Focus on your operator-specific parameters
}</p>
<p>// Required: Implement operator 1
function operate1()
returns int processed
locals array samples[2], int position
{
    // Get memory position from framework
    position = global positions[0]
    
    // Read audio from memory
    read(position, 1, samples)
    
    // Your operator processing
    samples[0] = processOperator(samples[0])
    samples[1] = processOperator(samples[1])
    
    // Write back to memory
    write(position, 1, samples)
    
    return 1  // Signal that we processed the audio
}</p>
<p>// Optional: Implement operator 2
function operate2()
returns int processed
{
    // Similar to operate1, but for second operator slot
    // Can be different algorithm or same with different parameters
    return 1
}</p>
<p>// Your operator implementation
function processOperator(int input)
returns int output
{
    // Your algorithm here
    output = input  // Placeholder
}</code></pre></p>
<h2>Chapter 5: Migration Strategies</h2>
<h3>From Mod Patch to Full Patch</h3>
<p>When your Mod patch outgrows the operator model:</p>
<pre><code>// Original Mod patch operator
function operate1()
returns int processed
locals array samples[2]
{
    read(global positions[0], 1, samples)
    samples[0] = complexEffect(samples[0])
    write(global positions[0], 1, samples)
    return 1
}
<p>// Migrated to Full patch
function process()
{
    loop {
        // Direct audio access
        global signal[0] = complexEffect(global signal[0])
        global signal[1] = complexEffect(global signal[1])
        yield()
    }
}</code></pre></p>
<strong>Migration Checklist</strong>:
<ul><li>‚úÖ Change <code>global array positions[2]</code> to <code>global array signal[2]</code></li><li>‚úÖ Replace <code>operate1()</code> with <code>process()</code> + <code>loop</code> + <code>yield()</code></li><li>‚úÖ Replace <code>read()</code>/<code>write()</code> with direct <code>signal[]</code> access</li><li>‚úÖ Implement parameter handling in <code>update()</code></li><li>‚úÖ Implement LED control manually</li><li>‚úÖ Add initialization in <code>init()</code> if needed</li></ul>
<h3>From Full Patch to Mod Patch</h3>
<p>When you want to integrate with Permut8's features:</p>
<pre><code>// Original Full patch
function process()
{
    loop {
        global signal[0] = simpleEffect(global signal[0])
        yield()
    }
}
<p>// Migrated to Mod patch
function operate1()
returns int processed
locals array samples[2]
{
    read(global positions[0], 1, samples)
    samples[0] = simpleEffect(samples[0])
    write(global positions[0], 1, samples)
    return 1
}</code></pre></p>
<strong>Migration Checklist</strong>:
<ul><li>‚úÖ Change <code>global array signal[2]</code> to <code>global array positions[2]</code></li><li>‚úÖ Replace <code>process()</code> with <code>operate1()</code> and/or <code>operate2()</code></li><li>‚úÖ Replace direct <code>signal[]</code> access with <code>read()</code>/<code>write()</code></li><li>‚úÖ Remove manual parameter handling (framework handles it)</li><li>‚úÖ Remove manual LED control (framework handles it)</li><li>‚úÖ Simplify to focus on core algorithm</li></ul>
<h2>Chapter 6: Real-World Examples</h2>
<h3>Example 1: Bitcrusher (Perfect for Mod Patch)</h3>
<pre><code>// === BITCRUSHER MOD PATCH ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>global array positions[2]
global array params[PARAM_COUNT]
global array displayLEDs[4]</p>
<p>global int bitDepth = 8
global int sampleRateReduction = 1</p>
<p>function update()
{
    // Map parameters to bit crushing settings
    global bitDepth = 1 + global params[OPERAND_1_HIGH_PARAM_INDEX] / 32  // 1-8 bits
    global sampleRateReduction = 1 + global params[OPERAND_1_LOW_PARAM_INDEX] / 64  // 1-4x
}</p>
<p>function operate1()
returns int processed
locals array samples[2], int crushedSample, int mask
{
    read(global positions[0], 1, samples)
    
    // Create bit mask for bit depth reduction
    mask = 0xFFFF << (16 - global bitDepth)
    
    // Apply bit crushing
    crushedSample = samples[0] & mask
    
    // Apply sample rate reduction (simple hold)
    if ((global clock % global sampleRateReduction) == 0) {
        samples[0] = crushedSample
    }
    // else keep previous sample (sample rate reduction)
    
    write(global positions[0], 1, samples)
    return 1
}</code></pre></p>
<strong>Why Mod Patch?</strong>:
<ul><li>‚úÖ Simple operator-style processing</li><li>‚úÖ Benefits from Permut8's delay/feedback</li><li>‚úÖ Automatic parameter and LED integration</li><li>‚úÖ Can be combined with other operators</li></ul>
<h3>Example 2: Custom Reverb (Requires Full Patch)</h3>
<pre><code>// === CUSTOM REVERB FULL PATCH ===
const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>global array signal[2]
global array params[PARAM_COUNT]
global array displayLEDs[4]</p>
<p>// Reverb state (complex, requires total control)
global array reverbBuffer[32768]  // 0.74 second at 44.1kHz
global int writePos = 0
global array tapDelays[8] = {100, 200, 400, 600, 1200, 1800, 2400, 3200}
global int reverbTime = 500
global int wetLevel = 128</p>
<p>function update()
{
    global reverbTime = global params[OPERAND_1_HIGH_PARAM_INDEX] * 4
    global wetLevel = global params[OPERAND_1_LOW_PARAM_INDEX]
}</p>
<p>function process()
locals int input, int wet, int dry, int output, int i, int tapSample, int readPos
{
    loop {
        input = global signal[0]
        
        // Write to reverb buffer
        global reverbBuffer[global writePos] = input
        
        // Calculate reverb (sum of multiple taps)
        wet = 0
        for (i = 0 to 7) {
            readPos = global writePos - global tapDelays[i]
            if (readPos < 0) readPos = readPos + 32768
            
            tapSample = global reverbBuffer[readPos]
            wet = wet + tapSample / 8  // Mix all taps
        }
        
        // Apply reverb time (feedback)
        wet = wet * global reverbTime / 1000
        
        // Mix wet and dry
        dry = input * (255 - global wetLevel) / 255
        wet = wet * global wetLevel / 255
        output = dry + wet
        
        global signal[0] = output
        global signal[1] = output  // Mono reverb
        
        // Advance write position
        global writePos = (global writePos + 1) % 32768
        
        yield()
    }
}</code></pre></p>
<strong>Why Full Patch?</strong>:
<ul><li>‚úÖ Complex buffer management needs total control</li><li>‚úÖ Multi-tap delay requires custom memory allocation</li><li>‚úÖ Timing-critical for reverb algorithm</li><li>‚úÖ Custom wet/dry mixing</li></ul>
<h2>Chapter 7: Performance Considerations</h2>
<h3>CPU Usage Comparison</h3>
<pre><code>// Mod Patch: Framework overhead
function operate1()
returns int processed
{
    read(position, 1, samples)     // Memory access overhead
    samples[0] = process(samples[0]) // Your algorithm
    write(position, 1, samples)    // Memory access overhead
    return 1
}
<p>// Full Patch: Direct processing
function process()
{
    loop {
        global signal[0] = process(global signal[0])  // Direct access
        yield()
    }
}</code></pre></p>
<strong>Performance Guidelines</strong>:
<ul><li><strong>Full patches</strong>: 5-10% lower CPU usage for simple algorithms</li><li><strong>Mod patches</strong>: Easier to optimize due to framework assistance</li><li><strong>Complex algorithms</strong>: Performance difference becomes negligible</li><li><strong>Memory access</strong>: Mod patches have slight overhead</li></ul>
<h3>Memory Usage Patterns</h3>
<pre><code>// Mod Patch: Memory shared with framework
global array positions[2]  // Small footprint
// Framework manages delay buffers, feedback paths, etc.
<p>// Full Patch: You manage all memory
global array signal[2]           // Direct audio
global array delayBuffer[44100]  // Your delay buffer
global array workingMemory[1024] // Your workspace
// You allocate everything you need</code></pre></p>
<h2>Chapter 8: Testing and Debugging</h2>
<h3>Testing Mod Patches</h3>
<pre><code>// Test with known inputs using trace()
function operate1()
returns int processed
locals array samples[2]
{
    read(global positions[0], 1, samples)
    
    // Debug: trace input values
    if ((global clock % 1000) == 0) {
        trace("Input: " + intToString(samples[0]))
    }
    
    samples[0] = processOperator(samples[0])
    
    // Debug: trace output values
    if ((global clock % 1000) == 0) {
        trace("Output: " + intToString(samples[0]))
    }
    
    write(global positions[0], 1, samples)
    return 1
}</code></pre>
<h3>Testing Full Patches</h3>
<pre><code>// Test with direct signal monitoring
function process()
locals int input, int output
{
    loop {
        input = global signal[0]
        
        // Debug: Monitor signal levels
        if ((global clock % 1000) == 0) {
            trace("Level: " + intToString(abs(input)))
        }
        
        output = processEffect(input)
        
        // Safety: Always clamp output
        if (output > 2047) output = 2047
        if (output < -2047) output = -2047
        
        global signal[0] = output
        global signal[1] = output
        
        yield()
    }
}</code></pre>
<h2>Chapter 9: Common Pitfalls and Solutions</h2>
<h3>Pitfall 1: Wrong Architecture Choice</h3>
<strong>Problem</strong>: Chose Mod patch for complex reverb
<pre><code>// BAD: Trying to implement reverb as operator
function operate1()
returns int processed
{
    // Complex reverb doesn't fit operator model well
    // Limited memory, timing issues, integration problems
    return 1
}</code></pre>
<strong>Solution</strong>: Use Full patch for complex effects
<pre><code>// GOOD: Full patch gives total control for reverb
function process()
{
    loop {
        // Complete control over timing and memory
        yield()
    }
}</code></pre>
<h3>Pitfall 2: Inefficient Memory Access</h3>
<strong>Problem</strong>: Unnecessary memory operations in Mod patch
<pre><code>// BAD: Multiple read/write operations
function operate1()
returns int processed
{
    read(global positions[0], 1, samples1)
    read(global positions[0], 1, samples2)  // Redundant!
    // Process
    write(global positions[0], 1, result1)
    write(global positions[0], 1, result2)  // Redundant!
    return 1
}</code></pre>
<strong>Solution</strong>: Minimize memory operations
<pre><code>// GOOD: Single read/write pair
function operate1()
returns int processed
{
    read(global positions[0], 1, samples)
    // Process samples in place
    write(global positions[0], 1, samples)
    return 1
}</code></pre>
<h3>Pitfall 3: Not Returning from Operators</h3>
<strong>Problem</strong>: Forgetting to return from operator functions
<pre><code>// BAD: No return value
function operate1()
{
    read(global positions[0], 1, samples)
    // Process
    write(global positions[0], 1, samples)
    // Missing: return 1;
}</code></pre>
<strong>Solution</strong>: Always return 1 for processed audio
<pre><code>// GOOD: Clear return value
function operate1()
returns int processed
{
    read(global positions[0], 1, samples)
    // Process
    write(global positions[0], 1, samples)
    return 1  // Signal successful processing
}</code></pre>
<h2>Chapter 10: Decision Flowchart</h2>
<p>Use this flowchart to choose your architecture:</p>
<pre><code>START: What type of effect are you building?
<p>‚îú‚îÄ Simple operator-style effect (distortion, filter, etc.)
‚îÇ  ‚îú‚îÄ Want integration with Permut8 features? ‚Üí MOD PATCH
‚îÇ  ‚îî‚îÄ Need maximum performance? ‚Üí FULL PATCH
‚îÇ
‚îú‚îÄ Complex time-based effect (reverb, delay, etc.)
‚îÇ  ‚îî‚îÄ ‚Üí FULL PATCH
‚îÇ
‚îú‚îÄ Multi-band or spectral processing
‚îÇ  ‚îî‚îÄ ‚Üí FULL PATCH
‚îÇ
‚îú‚îÄ Synthesizer or tone generator
‚îÇ  ‚îî‚îÄ ‚Üí FULL PATCH
‚îÇ
‚îú‚îÄ Learning/prototyping
‚îÇ  ‚îî‚îÄ ‚Üí MOD PATCH (easier to start)
‚îÇ
‚îî‚îÄ Production/commercial use
   ‚îú‚îÄ Simple effect ‚Üí MOD PATCH
   ‚îî‚îÄ Complex effect ‚Üí FULL PATCH</code></pre></p>
<h2>Summary and Next Steps</h2>
<h3>Quick Decision Reference</h3>
<strong>Choose Mod Patch for</strong>:
<ul><li>Simple effects (distortion, basic filters)</li><li>Rapid prototyping</li><li>Integration with Permut8 features</li><li>Learning firmware development</li></ul>
<strong>Choose Full Patch for</strong>:
<ul><li>Complex effects (reverb, delay, spectral)</li><li>Maximum performance requirements</li><li>Complete control over audio path</li><li>Synthesizers and generators</li></ul>
<h3>Next Steps</h3>
<p>1. <strong>Practice Implementation</strong>: <a href="complete-development-workflow.md">Complete Development Workflow Tutorial</a>
   - Learn the end-to-end development process
   - Practice compiling and testing both architectures</p>
<p>2. <strong>Study Examples</strong>: Explore cookbook recipes
   - <strong>Mod Patch Examples</strong>: <a href="../cookbook/audio-effects/bitcrusher.md">Bitcrusher</a>, <a href="../cookbook/fundamentals/basic-filter.md">Basic Filter</a>
   - <strong>Full Patch Examples</strong>: <a href="../cookbook/audio-effects/make-a-delay.md">Make a Delay</a>, <a href="../cookbook/audio-effects/reverb-simple.md">Reverb</a></p>
<p>3. <strong>Advanced Techniques</strong>: <a href="../../assembly/gazl-assembly-introduction.md">Assembly Integration Guide</a>
   - Learn optimization techniques for both architectures</p>
<h3>Architecture Decision Template</h3>
<pre><code>Project: _______________
Effect Type: ___________
Complexity: ____________
Performance Requirements: _______
Integration Needs: _____________
<p>Decision: [ ] Mod Patch  [ ] Full Patch
Reasoning: ________________________</code></pre></p>
<p>---</p>
<p>You now have the knowledge to make informed architectural decisions for your Permut8 firmware projects. This foundational understanding will guide every aspect of your development process.</p>
<em>Part of the Permut8 Foundation Tutorial Series</em>
</div>


<div class="file-section" id="basic-filter">
    <div class="file-title">üìÑ Basic Filter</div>
    <h1>Basic Filter</h1>
<em>Shape frequency content with simple digital filters</em>
<h2>What This Does</h2>
<p>Filters selectively reduce or emphasize certain frequencies in audio signals. Use them to remove unwanted frequencies, shape tone character, or create classic synthesizer effects like resonant sweeps.</p>
<h2>Quick Reference</h2>
<strong>Essential Parameters:</strong>
<ul><li><code>params[0]</code>: Cutoff frequency (0-255, controls filter frequency)</li><li><code>params[1]</code>: Resonance (0-255, emphasis at cutoff)</li><li><code>params[2]</code>: Filter type (0-255, low/high/band-pass)</li><li><code>params[3]</code>: Dry/wet mix (0-255, blend control)</li></ul>
<strong>Filter Types:</strong>
<ul><li><strong>Low-pass</strong>: Removes high frequencies (creates warmth)</li><li><strong>High-pass</strong>: Removes low frequencies (adds clarity)</li><li><strong>Band-pass</strong>: Isolates middle frequencies (telephone effect)</li></ul>
<strong>Key Concepts:</strong> Frequency response, cutoff frequency, resonance, filter state
<h2>Complete Code</h2>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>// Required native function declarations
extern native yield             // Return control to Permut8 audio engine</p>
<p>// Standard global variables
global array signal[2]          // Left/Right audio samples
global array params[8]          // Parameter values (0-255)
global array displayLEDs[4]     // LED displays</p>
<p>// Simple filter state
global int filter_state1 = 0    // First filter state variable
global int filter_state2 = 0    // Second filter state variable</p>
<p>function process()
locals int cutoff, int resonance, int filter_type, int mix, int input, int filter_amount, int low_pass, int high_pass, int band_pass, int filtered, int output
{
    loop {
        // Read parameters
        cutoff = ((int)global params[0] >> 3) + 1;    // 1-32 filter strength
        resonance = ((int)global params[1] >> 3) + 1; // 1-32 resonance amount
        filter_type = ((int)global params[2] >> 6);   // 0-3 filter types
        mix = (int)global params[3];                  // 0-255 dry/wet mix
        
        input = (int)global signal[0];
        
        // Simple one-pole low-pass filter
        global filter_state1 = global filter_state1 + ((input - global filter_state1) >> cutoff);
        low_pass = global filter_state1;
        
        // High-pass = input - low-pass
        high_pass = input - low_pass;
        
        // Second filter stage for band-pass
        global filter_state2 = global filter_state2 + ((high_pass - global filter_state2) >> cutoff);
        band_pass = global filter_state2;
        
        // Select filter type
        if (filter_type == 0) {
            filtered = low_pass;       // Low-pass filter
        } else if (filter_type == 1) {
            filtered = high_pass;      // High-pass filter
        } else if (filter_type == 2) {
            filtered = band_pass;      // Band-pass filter
        } else {
            filtered = input;          // No filtering
        }
        
        // Add resonance (feedback)
        if (resonance > 1) {
            filter_amount = (filtered * resonance) >> 5;
            filtered = filtered + filter_amount;
            
            // Prevent resonance from getting too loud
            if (filtered > 2047) filtered = 2047;
            if (filtered < -2047) filtered = -2047;
        }
        
        // Mix dry and wet signals
        output = ((input <em> (255 - mix)) + (filtered </em> mix)) >> 8;
        
        // Prevent clipping
        if (output > 2047) output = 2047;
        if (output < -2047) output = -2047;
        
        // Output result
        global signal[0] = output;
        global signal[1] = output;
        
        // Show activity on LEDs
        global displayLEDs[0] = cutoff << 3;
        global displayLEDs[1] = resonance << 3;
        global displayLEDs[2] = filter_type << 6;
        global displayLEDs[3] = (mix >> 2);
        
        yield();
    }
}</code></pre></p>
<h2>How It Works</h2>
<strong>One-Pole Filter</strong>: Uses a simple recursive filter that mixes the current input with the previous output.
<strong>Filter Types</strong>:
<ul><li><strong>Low-pass</strong>: Smooth changes by averaging with previous values</li><li><strong>High-pass</strong>: Subtracts the low-pass from the input to get high frequencies</li><li><strong>Band-pass</strong>: Applies low-pass filtering to the high-pass output</li></ul>
<strong>Cutoff Control</strong>: Lower cutoff values = stronger filtering, higher values = more transparent.
<strong>Resonance</strong>: Adds feedback to emphasize frequencies near the cutoff point.
<strong>Parameter Control</strong>:
<ul><li><strong>Knob 1</strong>: Cutoff frequency (lower = more filtering)</li><li><strong>Knob 2</strong>: Resonance (higher = more emphasis)</li><li><strong>Knob 3</strong>: Filter type (0-63=low, 64-127=high, 128-191=band, 192-255=bypass)</li><li><strong>Knob 4</strong>: Dry/wet mix (blend filtered with original)</li></ul>
<h2>Try These Settings</h2>
<pre><code>// Warm low-pass
params[0] = 128;  // Medium cutoff
params[1] = 64;   // Light resonance
params[2] = 32;   // Low-pass
params[3] = 200;  // Mostly filtered
<p>// Bright high-pass
params[0] = 200;  // High cutoff
params[1] = 100;  // Medium resonance
params[2] = 100;  // High-pass
params[3] = 150;  // Balanced mix</p>
<p>// Telephone effect
params[0] = 100;  // Low cutoff
params[1] = 150;  // Strong resonance
params[2] = 160;  // Band-pass
params[3] = 220;  // Mostly wet</p>
<p>// Classic synth sweep
params[0] = 50;   // Start low
params[1] = 200;  // High resonance
params[2] = 32;   // Low-pass
params[3] = 255;  // Full wet
// (slowly increase params[0] for sweep effect)</code></pre></p>
<h2>Understanding Filters</h2>
<strong>Frequency Response</strong>: Filters change the balance of frequencies in your signal. Low-pass filters make sounds warmer and darker, high-pass filters make them brighter and thinner.
<strong>Cutoff Frequency</strong>: The point where the filter starts to take effect. Above this frequency (low-pass) or below this frequency (high-pass), the signal is gradually reduced.
<strong>Resonance</strong>: Boosts frequencies right at the cutoff point, creating emphasis and character. High resonance can make filters "ring" or even self-oscillate.
<strong>Filter Order</strong>: This is a simple one-pole filter. Higher-order filters (two-pole, four-pole) have steeper slopes but require more computation.
<h2>Try These Changes</h2>
<ul><li><strong>Stereo filtering</strong>: Use different cutoff frequencies for left and right channels</li><li><strong>LFO modulation</strong>: Slowly vary the cutoff frequency for automatic filter sweeps</li><li><strong>Envelope control</strong>: Link filter cutoff to input level for dynamic filtering</li><li><strong>Multiple stages</strong>: Chain two filters in series for steeper response</li></ul>
<h2>Related Techniques</h2>
<ul><li><strong><a href="basic-oscillator.md">Basic Oscillator</a></strong>: LFO sources for filter modulation</li><li><strong><a href="envelope-basics.md">Envelope Basics</a></strong>: Dynamic filter control</li></ul>
<p>---
<em>Part of the <a href="../index.md">Permut8 Cookbook</a> series</em></p>
</div>


<div class="file-section" id="simplest-distortion">
    <div class="file-title">üìÑ Simplest Distortion</div>
    <h1>Your First Distortion Effect</h1>
<em>From clean audio to guitar pedal sound in 15 minutes - Progressive distortion tutorial</em>
<p>---</p>
<h2>What You'll Build</h2>
<p>By the end of this tutorial, you'll have:
<ul><li>A working distortion effect that sounds like a real guitar pedal</li><li>Understanding of how different math creates different distortion sounds</li><li>Control over distortion amount using hardware knobs</li><li>Foundation for building any distortion-based effect</li></ul></p>
<strong>Prerequisites</strong>: <a href="how-dsp-affects-sound.md">How DSP Affects Sound</a>, <a href="getting-audio-in-and-out.md">Getting Audio In and Out</a>  
<strong>Time</strong>: 15 minutes hands-on  
<strong>Next Tutorial</strong>: <a href="../../../fundamentals/audio-engineering-for-programmers.md">Audio Engineering for Programmers</a>
<p>---</p>
<h2>The Journey: Clean ‚Üí Harsh ‚Üí Musical</h2>
<p>We'll build distortion in three progressive steps:</p>
<p>1. <strong>Step 1</strong>: Basic gain boost (2 minutes) - Make it louder
2. <strong>Step 2</strong>: Safe clipping (5 minutes) - Prevent harsh overload  
3. <strong>Step 3</strong>: Musical curves (8 minutes) - Sound like real guitar pedals</p>
<p>Each step builds on the previous one, so you'll always have working audio.</p>
<p>---</p>
<h2>Step 1: Basic Gain Boost (2 minutes)</h2>
<h3>The Simplest Distortion</h3>
<p>The most basic distortion is just <strong>making audio louder than it should be</strong>:</p>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
extern native yield
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>function process() {
    loop {
        // Basic distortion: just make it louder!
        signal[0] = signal[0] * 3;  // 3x louder
        signal[1] = signal[1] * 3;  // Both channels
        
        yield();
    }
}</code></pre></p>
<h3>Try It Right Now</h3>
<p>1. <strong>Compile</strong>: <code>PikaCmd.exe compile basic_gain.impala</code>
2. <strong>Load</strong>: Load <code>basic_gain.gazl</code> via plugin interface
3. <strong>Play</strong> some audio and <strong>listen</strong></p>
<strong>What You'll Hear</strong>: Much louder audio that starts to sound harsh and buzzy when the input is loud. This harshness IS distortion - you're hearing the audio system struggle with numbers that are too big.
<h3>Why This Works</h3>
<ul><li><strong>Quiet parts</strong> (small numbers): <code>100 * 3 = 300</code> ‚Üí Still clean</li><li><strong>Loud parts</strong> (big numbers): <code>1000 * 3 = 3000</code> ‚Üí Too big! Gets automatically limited to 2047</li><li><strong>The limiting creates distortion</strong> - that harsh, buzzy sound</li></ul>
<strong>Key Insight</strong>: Distortion happens when audio numbers get too big for the system to handle cleanly.
<p>---</p>
<h2>Step 2: Safe Clipping (5 minutes)</h2>
<p>The basic gain boost works, but it's unpredictable. Sometimes it's clean, sometimes harsh. Let's take control.</p>
<h3>Controlled Clipping</h3>
<p>Instead of hoping the system limits our audio safely, <strong>we'll do the limiting ourselves</strong>:</p>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
extern native yield
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>function process() {
    loop {
        // Read knob for distortion amount
        int distortionKnob = params[0];  // 0-255
        int gainAmount = 1 + (distortionKnob / 32);  // 1x to 9x gain
        
        // Apply gain to both channels
        int leftGained = signal[0] * gainAmount;
        int rightGained = signal[1] * gainAmount;
        
        // Safe clipping - WE control when distortion happens
        if (leftGained > 2047) leftGained = 2047;
        if (leftGained < -2047) leftGained = -2047;
        if (rightGained > 2047) rightGained = 2047;
        if (rightGained < -2047) rightGained = -2047;
        
        // Output the controlled distortion
        signal[0] = leftGained;
        signal[1] = rightGained;
        
        // Show distortion amount on LED
        displayLEDs[0] = distortionKnob;
        
        yield();
    }
}</code></pre></p>
<h3>Try the Controlled Version</h3>
<p>1. <strong>Compile and load</strong> this new version
2. <strong>Turn Knob 1</strong> from left (clean) to right (distorted)
3. <strong>Listen</strong> to how the distortion becomes predictable and controlled</p>
<strong>What You'll Hear</strong>: 
<ul><li><strong>Knob left</strong>: Clean audio (1x gain, no clipping)</li><li><strong>Knob middle</strong>: Mild distortion (moderate gain, some clipping)</li><li><strong>Knob right</strong>: Heavy distortion (high gain, lots of clipping)</li></ul>
<h3>Why This Is Better</h3>
<ul><li><strong>Predictable</strong>: You control exactly when distortion starts</li><li><strong>Safe</strong>: Never damages speakers or ears with unexpected volume spikes</li><li><strong>Musical</strong>: Distortion amount follows your knob movements</li><li><strong>Visual</strong>: LED shows current distortion setting</li></ul>
<strong>Key Insight</strong>: Professional distortion effects control the clipping instead of letting it happen randomly.
<p>---</p>
<h2>Step 3: Musical Curves (8 minutes)</h2>
<p>Hard clipping sounds harsh and digital. Real guitar pedals use <strong>soft clipping</strong> that sounds warm and musical.</p>
<h3>Understanding Clipping Curves</h3>
<p>Different clipping shapes create different sounds:</p>
<pre><code>Hard Clipping (harsh):          Soft Clipping (warm):
     ____                            ____
    |                               /
----+----  ‚Üí  _____|_____          /
    |              |               |
    ____           ____            ____</code></pre>
<h3>Soft Clipping Implementation</h3>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
extern native yield
<p>global array signal[2]
global array params[8]
global array displayLEDs[4]</p>
<p>function softClip(int input, int threshold) {
    // Soft clipping algorithm - sounds warm like tube amps
    if (input > threshold) {
        int excess = input - threshold;
        return threshold + (excess / 4);  // Gentle compression above threshold
    } else if (input < -threshold) {
        int excess = input + threshold;
        return -threshold + (excess / 4);  // Gentle compression below threshold
    } else {
        return input;  // No change in normal range
    }
}</p>
<p>function process() {
    loop {
        // Distortion controls from knobs
        int driveKnob = params[0];     // 0-255: Distortion amount
        int toneKnob = params[1];      // 0-255: Clipping threshold
        
        // Calculate gain (1x to 8x)
        int gainAmount = 1 + (driveKnob / 36);
        
        // Calculate clipping threshold (500 to 1800)
        int clipThreshold = 500 + ((toneKnob * 1300) / 255);
        
        // Process both channels
        int leftGained = signal[0] * gainAmount;
        int rightGained = signal[1] * gainAmount;
        
        // Apply soft clipping for musical distortion
        int leftClipped = softClip(leftGained, clipThreshold);
        int rightClipped = softClip(rightGained, clipThreshold);
        
        // Final safety clipping (just in case)
        if (leftClipped > 2047) leftClipped = 2047;
        if (leftClipped < -2047) leftClipped = -2047;
        if (rightClipped > 2047) rightClipped = 2047;  
        if (rightClipped < -2047) rightClipped = -2047;
        
        // Output the musical distortion
        signal[0] = leftClipped;
        signal[1] = rightClipped;
        
        // Visual feedback
        displayLEDs[0] = driveKnob;      // Drive amount
        displayLEDs[1] = toneKnob;       // Tone control
        
        yield();
    }
}</code></pre></p>
<h3>Try Your Musical Distortion</h3>
<p>1. <strong>Compile and load</strong> the soft clipping version
2. <strong>Experiment with both knobs</strong>:
   - <strong>Knob 1</strong> (Drive): Amount of distortion
   - <strong>Knob 2</strong> (Tone): Character of distortion
3. <strong>Listen</strong> for the warm, musical quality</p>
<strong>What You'll Hear</strong>:
<ul><li><strong>Low drive</strong>: Clean or very mild overdrive</li><li><strong>High drive</strong>: Rich, warm distortion like vintage tube amps</li><li><strong>Low tone</strong>: Gentle, smooth clipping</li><li><strong>High tone</strong>: Brighter, more aggressive clipping</li></ul>
<h3>Why This Sounds Better</h3>
<p>#### <strong>Soft vs Hard Clipping</strong>:
<pre><code>// Hard clipping (harsh, digital):
if (signal > 1000) signal = 1000;</p>
<p>// Soft clipping (warm, musical):
if (signal > 1000) {
    excess = signal - 1000;
    signal = 1000 + (excess / 4);  // Gentle transition
}</code></pre></p>
<p>#### <strong>The Magic</strong>:
<ul><li><strong>Hard clipping</strong>: Immediate cutoff ‚Üí harsh sound</li><li><strong>Soft clipping</strong>: Gradual compression ‚Üí warm sound</li><li><strong>Variable threshold</strong>: Different tone characters</li><li><strong>Gain staging</strong>: Professional volume control</li></ul></p>
<p>---</p>
<h2>Understanding Your Distortion Pedal</h2>
<h3>What You Built</h3>
<p>You now have a professional-quality distortion effect with:</p>
<p>1. <strong>Drive Control</strong> (Knob 1): How much distortion
2. <strong>Tone Control</strong> (Knob 2): Character of distortion  
3. <strong>Soft Clipping</strong>: Musical, warm sound
4. <strong>Safety Limiting</strong>: No damage or surprises
5. <strong>Visual Feedback</strong>: LED shows settings</p>
<h3>How It Compares to Commercial Pedals</h3>
<strong>Your firmware</strong> vs <strong>$200 Distortion Pedal</strong>:
<ul><li>‚úÖ <strong>Gain staging</strong>: Professional volume control</li><li>‚úÖ <strong>Soft clipping</strong>: Warm, musical distortion  </li><li>‚úÖ <strong>Tone shaping</strong>: Variable clipping character</li><li>‚úÖ <strong>Safety features</strong>: No damage or surprises</li><li>‚úÖ <strong>Real-time control</strong>: Immediate response to knobs</li></ul>
<strong>You built the core of a professional distortion pedal!</strong>
<p>---</p>
<h2>Advanced Variations</h2>
<p>Now that you understand the fundamentals, try these modifications:</p>
<h3>1. Asymmetrical Clipping</h3>
<pre><code>// Different clipping for positive and negative
if (input > threshold) {
    return threshold + ((input - threshold) / 4);
} else if (input < -threshold) {
    return -threshold + ((input + threshold) / 2);  // Different ratio!
}</code></pre>
<h3>2. Multiple Stages</h3>
<pre><code>// Run through soft clipping twice for more saturation
int stage1 = softClip(input * gain1, threshold1);
int stage2 = softClip(stage1 * gain2, threshold2);</code></pre>
<h3>3. Frequency-Dependent Distortion</h3>
<pre><code>// Different distortion for different frequencies
// (Requires filtering - see advanced tutorials)</code></pre>
<p>---</p>
<h2>The Distortion Spectrum</h2>
<p>You now understand how different approaches create different sounds:</p>
<h3><strong>Clean</strong>: <code>signal = signal</code></h3>
<ul><li>No processing</li><li>Original audio unchanged</li></ul>
<h3><strong>Volume</strong>: <code>signal = signal * gain</code>  </h3>
<ul><li>Louder but clean (until clipping)</li><li>Linear volume control</li></ul>
<h3><strong>Hard Distortion</strong>: <code>clamp(signal * gain, -limit, +limit)</code></h3>
<ul><li>Harsh, digital sound</li><li>Immediate cutoff</li></ul>
<h3><strong>Soft Distortion</strong>: <code>softClip(signal * gain, threshold)</code></h3>
<ul><li>Warm, musical sound  </li><li>Gradual compression</li></ul>
<h3><strong>Professional Distortion</strong>: Multiple stages + tone shaping</h3>
<ul><li>Complex harmonic content</li><li>Musical and controllable</li></ul>
<p>---</p>
<h2>Key Concepts Learned</h2>
<h3>1. Distortion Is Controlled Overload</h3>
<ul><li>Make audio too loud ‚Üí System limits it ‚Üí Creates distortion</li><li>Control when/how limiting happens ‚Üí Control distortion character</li></ul>
<h3>2. Clipping Shapes Define Sound</h3>
<ul><li><strong>Hard clipping</strong>: Immediate cutoff ‚Üí harsh sound</li><li><strong>Soft clipping</strong>: Gradual compression ‚Üí warm sound  </li><li><strong>Asymmetrical</strong>: Different positive/negative ‚Üí unique character</li></ul>
<h3>3. Professional Features</h3>
<ul><li><strong>Gain staging</strong>: Control how much signal hits the distortion</li><li><strong>Threshold control</strong>: Adjust where distortion begins</li><li><strong>Safety limiting</strong>: Prevent damage and surprises</li><li><strong>Visual feedback</strong>: Show users what's happening</li></ul>
<h3>4. Real Guitar Pedal Architecture</h3>
<ul><li>Input gain ‚Üí Soft clipping ‚Üí Tone shaping ‚Üí Output limiting</li><li>Multiple controls for musical flexibility</li><li>Warm, musical algorithms instead of harsh digital</li></ul>
<p>---</p>
<h2>What's Next?</h2>
<h3><strong>Immediate Next Steps</strong>:</h3>
1. <strong><a href="../../../fundamentals/audio-engineering-for-programmers.md">Audio Engineering for Programmers</a></strong> - Professional concepts
2. <strong><a href="../audio-effects/waveshaper-distortion.md">Waveshaper Distortion</a></strong> - Advanced mathematical approaches
3. <strong><a href="../../parameters/parameter-mapping.md">Parameter Mapping</a></strong> - Professional parameter design
<h3><strong>Building on Distortion</strong>:</h3>
<ul><li><strong><a href="../audio-effects/multi-band-compressor.md">Multi-band Compressor</a></strong> - Frequency-specific processing</li><li><strong><a href="../audio-effects/chorus-effect.md">Chorus Effect</a></strong> - Modulation-based effects</li><li><strong><a href="../../tutorials/complete-development-workflow.md">Complete Development Workflow</a></strong> - Professional practices</li></ul>
<h3><strong>Advanced Distortion</strong>:</h3>
<ul><li><strong><a href="../../../performance/optimization-basics.md">Optimization Basics</a></strong> - Performance improvement</li><li><strong><a href="../../../advanced/advanced-memory-management.md">Advanced Memory Management</a></strong> - Complex algorithms</li></ul>
<p>---</p>
<h2>Quick Reference</h2>
<h3><strong>Basic Distortion Pattern</strong>:</h3>
<pre><code>// 1. Control input gain
int gained = signal[0] * gainAmount;
<p>// 2. Apply clipping algorithm  
int clipped = softClip(gained, threshold);</p>
<p>// 3. Safety limiting
if (clipped > 2047) clipped = 2047;
if (clipped < -2047) clipped = -2047;</p>
<p>// 4. Output result
signal[0] = clipped;</code></pre></p>
<h3><strong>Soft Clipping Function</strong>:</h3>
<pre><code>function softClip(int input, int threshold) {
    if (input > threshold) {
        return threshold + ((input - threshold) / compressionRatio);
    } else if (input < -threshold) {
        return -threshold + ((input + threshold) / compressionRatio);
    }
    return input;
}</code></pre>
<h3><strong>Professional Controls</strong>:</h3>
<ul><li><strong>Drive/Gain</strong>: How much signal hits the distortion</li><li><strong>Tone/Threshold</strong>: Where and how distortion begins  </li><li><strong>Output Level</strong>: Final volume control</li><li><strong>Safety Limiting</strong>: Prevent damage</li></ul>
<p>You now understand the fundamentals of distortion and have built a professional-quality effect! This knowledge applies to all overdrive, distortion, and saturation effects.</p>
<p>---</p>
<em>Next: <a href="../../../fundamentals/audio-engineering-for-programmers.md">Audio Engineering for Programmers</a> - Essential audio concepts in programming terms</em>
</div>


<div class="file-section" id="bitcrusher">
    <div class="file-title">üìÑ Bitcrusher</div>
    <h1>Bitcrusher</h1>
<em>Create digital distortion effects through bit depth reduction and sample rate downsampling</em>
<h2>What This Does</h2>
<p>Generates digital distortion by reducing the bit depth and sample rate of audio signals, creating characteristic lo-fi artifacts, digital stepping, and harmonic distortion. Perfect for vintage sampler emulation and modern digital textures.</p>
<h2>Quick Reference</h2>
<strong>Essential Parameters:</strong>
<ul><li><code>params[0]</code>: Bit depth (0-255, controls quantization amount)</li><li><code>params[1]</code>: Sample rate reduction (0-255, hold factor) </li><li><code>params[2]</code>: Dry/wet mix (0-255, blend control)</li><li><code>params[3]</code>: Output gain (0-255, level compensation)</li></ul>
<strong>Key Concepts:</strong> Quantization distortion, sample-and-hold, digital artifacts, aliasing effects
<strong>Common Settings:</strong>
<pre><code>// Vintage sampler: moderate crushing with character
int vintage_bits = 180, vintage_rate = 60, vintage_mix = 200, vintage_gain = 220
<p>// Lo-fi texture: heavy digital artifacts
int lofi_bits = 100, lofi_rate = 120, lofi_mix = 180, lofi_gain = 240</p>
<p>// Extreme digital: maximum destruction
int extreme_bits = 30, extreme_rate = 200, extreme_mix = 255, extreme_gain = 200</code></pre></p>
<h2>Complete Code</h2>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>// Required native function declarations
extern native yield             // Return control to Permut8 audio engine</p>
<p>// Standard global variables
global array signal[2]          // Left/Right audio samples
global array params[8]          // Parameter values (0-255)
global array displayLEDs[4]     // LED displays</p>
<p>// Simple bitcrusher state
global int hold_left = 0         // Held sample for left channel
global int hold_right = 0        // Held sample for right channel
global int hold_counter = 0      // Counter for sample rate reduction</p>
<p>function process()
locals int bits
locals int rate_div
locals int mix
locals int gain
locals int crushed_left
locals int crushed_right
locals int shift_amount
locals int dry_left
locals int dry_right
locals int wet_left
locals int wet_right
locals int output_left
locals int output_right
{
    loop {
        // Read parameters
        bits = ((int)global params[0] >> 4) + 1;        // 1-16 effective bit depth
        rate_div = ((int)global params[1] >> 3) + 1;    // 1-32 rate division
        mix = (int)global params[2];                    // 0-255 dry/wet mix
        gain = ((int)global params[3] >> 1) + 64;       // 64-191 output gain
        
        // Sample rate reduction (hold samples)
        global hold_counter = global hold_counter + 1;
        if (global hold_counter >= rate_div) {
            global hold_counter = 0;
            global hold_left = (int)global signal[0];
            global hold_right = (int)global signal[1];
        }
        
        // Calculate bit reduction for 12-bit audio (-2047 to 2047)
        shift_amount = 12 - bits;                       // Amount to shift for quantization
        if (shift_amount < 0) shift_amount = 0;         // Prevent negative shifts
        if (shift_amount > 11) shift_amount = 11;       // Prevent excessive shifts
        
        // Bit depth reduction through shift quantization
        crushed_left = (global hold_left >> shift_amount) << shift_amount;
        crushed_right = (global hold_right >> shift_amount) << shift_amount;
        
        // Store dry signals
        dry_left = (int)global signal[0];
        dry_right = (int)global signal[1];
        
        // Apply output gain to wet signals
        wet_left = (crushed_left * gain) >> 7;          // Apply gain with scaling
        wet_right = (crushed_right * gain) >> 7;
        
        // Clip gained signals to valid range
        if (wet_left > 2047) wet_left = 2047;
        if (wet_left < -2047) wet_left = -2047;
        if (wet_right > 2047) wet_right = 2047;
        if (wet_right < -2047) wet_right = -2047;
        
        // Mix dry and wet signals
        output_left = ((dry_left <em> (255 - mix)) + (wet_left </em> mix)) >> 8;
        output_right = ((dry_right <em> (255 - mix)) + (wet_right </em> mix)) >> 8;
        
        // Output final mixed audio
        global signal[0] = output_left;
        global signal[1] = output_right;
        
        // Show activity on LEDs with bounds checking
        global displayLEDs[0] = ((bits - 1) << 4) & 255;      // Show effective bit depth
        global displayLEDs[1] = ((rate_div - 1) << 3) & 255;  // Show rate reduction
        global displayLEDs[2] = mix;                          // Show dry/wet mix
        global displayLEDs[3] = (gain - 64) << 1;             // Show output gain
        
        yield();
    }
}</code></pre></p>
<h2>How It Works</h2>
<strong>Bit Depth Reduction</strong>: Uses right-shift quantization to reduce effective bit depth from 12-bit to 1-16 bits, creating digital stepping artifacts.
<strong>Sample Rate Reduction</strong>: Holds samples for multiple cycles (1-32x), creating characteristic stepping and aliasing effects.
<strong>Dry/Wet Mixing</strong>: Blends original signal with crushed signal for controlled intensity.
<strong>Output Gain</strong>: Compensates for level changes caused by bit reduction and provides creative gain staging.
<strong>Parameter Control</strong>:
<ul><li><strong>Knob 1</strong>: Bit depth (1-16 effective bits) </li><li><strong>Knob 2</strong>: Sample rate reduction (1-32x)</li><li><strong>Knob 3</strong>: Dry/wet mix (0% = clean, 100% = crushed)</li><li><strong>Knob 4</strong>: Output gain (compensate for level changes)</li></ul>
<strong>LED Feedback</strong>: Shows bit depth, rate reduction, mix level, and output gain.
<h2>Try These Settings</h2>
<pre><code>// Vintage lo-fi (moderate crushing)
params[0] = 128;  // 8-bit depth
params[1] = 64;   // 8x rate reduction  
params[2] = 180;  // 70% wet mix
params[3] = 200;  // +6dB gain compensation
<p>// Extreme digital destruction  
params[0] = 32;   // 2-bit depth
params[1] = 200;  // 25x rate reduction
params[2] = 255;  // 100% wet
params[3] = 255;  // Maximum gain</code></pre></p>
</div>


<div class="file-section" id="make-a-delay">
    <div class="file-title">üìÑ Make A Delay</div>
    <h1>Make a Delay</h1>
<h2>What This Does</h2>
Creates a simple delay effect with adjustable delay time and feedback amount. The delayed signal is mixed with the original to create echo effects ranging from short slap-back delays to long ambient trails.
<h2>Quick Reference</h2>
<strong>Parameters</strong>:
<ul><li><strong>Knob 1 (params[0])</strong>: Delay time (1-1000 samples, timing varies with sample rate)</li><li><strong>Knob 2 (params[1])</strong>: Feedback amount (0-90% to prevent runaway)</li><li><strong>Knob 3 (params[5])</strong>: [Available for expansion]</li><li><strong>Knob 4 (params[6])</strong>: [Available for expansion]</li></ul>
<strong>Key Concepts</strong>: Memory read/write operations, feedback loops, circular buffering
<h2>Complete Code</h2>
<pre><code>const int PRAWN_FIRMWARE_PATCH_FORMAT = 2
<p>// Required native function declarations
extern native yield             // Return control to Permut8 audio engine
extern native read              // Read from delay line memory
extern native write             // Write to delay line memory</p>
<p>// Standard global variables
global array signal[2]          // Left/Right audio samples
global array params[8]          // Parameter values (0-255)
global array displayLEDs[4]     // LED displays</p>
<p>// Delay processing variables
global array delayBuffer[2]     // Temporary buffer for memory operations
global int delayIndex = 0       // Current position in delay buffer
global int maxDelayTime = 1000  // Maximum delay in samples (timing varies with sample rate)</p>
<p>// Utility function for audio clipping
function clipAudio(int sample) returns int clipped {
    if (sample > 2047) clipped = 2047
    else if (sample < -2047) clipped = -2047
    else clipped = sample
}</p>
<p>function process() {
    loop {
        operate1()  // Process left channel
        operate2()  // Process right channel
    }
}</p>
<p>function operate1() {
    // === PARAMETER READING ===
    int delayTime = ((int)params[0] * maxDelayTime / 255) + 1  // 1-1000 samples
    int feedbackAmount = (int)params[1] * 90 / 255             // 0-90% feedback
    
    // === DELAY PROCESSING ===
    // Read delayed sample from memory (fixed offset from write position)
    int readPos = (delayIndex - delayTime + maxDelayTime) % maxDelayTime
    read(readPos, 1, delayBuffer)
    int delayedSample = delayBuffer[0]
    
    // Mix input with delayed signal for output
    int input = signal[0]
    int output = input + (delayedSample * feedbackAmount / 100)
    output = clipAudio(output)
    
    // Store new sample (input + feedback) for next delay iteration
    delayBuffer[0] = input + (delayedSample * feedbackAmount / 100)
    delayBuffer[0] = clipAudio(delayBuffer[0])
    
    write(delayIndex, 1, delayBuffer)
    
    // Update delay buffer position (fixed circular buffer)
    delayIndex = (delayIndex + 1) % maxDelayTime
    
    // === OUTPUT AND VISUALIZATION ===
    // Show delay activity on LEDs (lights when delayed signal is audible)
    int ledPattern = 0
    if (delayedSample > 100 || delayedSample < -100) {
        ledPattern = (1 << (delayIndex % 8))
    }
    displayLEDs[0] = ledPattern
    
    signal[0] = output
    yield()
}</p>
<p>function operate2() {
    // === RIGHT CHANNEL PROCESSING ===
    // Identical delay processing for right channel using offset memory location
    int delayTime = ((int)params[0] * maxDelayTime / 255) + 1
    int feedbackAmount = (int)params[1] * 90 / 255
    
    // Use offset memory location to avoid interference with left channel
    int readPos = ((delayIndex - delayTime + maxDelayTime) % maxDelayTime) + maxDelayTime
    read(readPos, 1, delayBuffer)
    int delayedSample = delayBuffer[0]
    
    int input = signal[1]
    int output = input + (delayedSample * feedbackAmount / 100)
    output = clipAudio(output)
    
    // Store sample with feedback
    delayBuffer[0] = input + (delayedSample * feedbackAmount / 100)
    delayBuffer[0] = clipAudio(delayBuffer[0])
    
    write(delayIndex + maxDelayTime, 1, delayBuffer)
    
    signal[1] = output
    yield()
}</code></pre></p>
<h2>Try These Changes</h2>
<ul><li><strong>Longer delays</strong>: Increase <code>maxDelayTime</code> to 5000 or 10000 samples for longer echoes</li><li><strong>Shorter delays</strong>: Set <code>maxDelayTime</code> to 100 for tight slap-back echo effects</li><li><strong>Stereo ping-pong</strong>: Use different delay times for left/right channels to bounce audio</li><li><strong>Higher feedback</strong>: Carefully increase the 90% limit for more repeats (watch for runaway!)</li><li><strong>Modulated delay</strong>: Add LFO modulation to <code>delayTime</code> for chorus-like effects</li></ul>
<h2>How It Works</h2>
The delay effect stores incoming audio samples in memory using the <code>read()</code> and <code>write()</code> functions, then plays them back after a specified time interval. The core algorithm uses a fixed-size circular buffer approach where <code>delayIndex</code> tracks the current write position, wrapping at <code>maxDelayTime</code> to maintain consistent memory management.
<p>The read position is calculated as an offset from the write position: <code>(delayIndex - delayTime + maxDelayTime) % maxDelayTime</code>. This ensures the delay time can be changed without causing audio artifacts or memory discontinuity.</p>
<p>The feedback control mixes a percentage of the delayed signal back into the delay buffer itself, creating multiple repeats that gradually fade away. This feedback loop is carefully limited to 90% to prevent mathematical runaway that would cause infinite amplification.</p>
<p>The memory addressing uses separate regions for left and right channels (<code>delayIndex</code> vs <code>delayIndex + maxDelayTime</code>) to prevent interference between stereo channels while maintaining proper circular buffer behavior for both channels.</p>
<h2>Related Techniques</h2>
<ul><li><strong><a href="chorus-effect.md">Chorus Effect</a></strong>: Uses multiple short delays for thickening</li><li><strong><a href="../timing/sync-to-tempo.md">Sync to Tempo</a></strong>: Tempo-synchronized delay timing</li><li><strong><a href="../fundamentals/memory-basics.md">Memory Basics</a></strong>: Memory read/write fundamentals</li></ul>
<p>---
<em>Part of the <a href="../index.md">Permut8 Cookbook</a> series</em></p>
</div>

        <div style="margin-top: 60px; padding-top: 20px; border-top: 2px solid #ecf0f1; text-align: center; color: #7f8c8d;">
            <p><strong>Permut8 Firmware Documentation</strong></p>
            <p>Generated on June 15, 2025 | Complete offline reference</p>
        </div>
    </div>
</body>
</html>